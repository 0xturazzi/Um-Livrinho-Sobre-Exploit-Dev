- [Double Free como Dangling Pointer](#double-free-como-dangling-pointer)
  - [Free em um Fastbin](#free-em-um-fastbin)

# Double Free como Dangling Pointer
Expandindo a definição de um double free como um pointer que nao 
foi zerado (e pode ser usado para chamar free em um endereço). 

Porem, como em free o heap se movimenta (consolidações e etc), nos 
podemos considerar o `double free` como um `free em um endereço arbitrário`.

Assim, nos podemos moldar o heap, colocando um chunk arbitrário 
naquele endereço, e assim chamar free nele

## Free em um Fastbin 

Por exemplo, vamos supor que o programa nao nos permite usar 
fastbins. Com um double free, voce pode forjar um fastchunk 
naquele endereço, e ao chamar free (por meio do double free), voce 
terá gerado um fastchunk legitimo.

```py
chunk_A = malloc(0x88) # qualquer size > 0x80 
chunk_B = malloc(0x88) # mesma coisa

free(chunk_A)
free(chunk_B)


  0x0000000000000000	0x0000000000021001	 <-- Top chunk

o heap esta vazio, mas o programa tem um double free, então o 
pointer para, por exemplo, o chunk_B pode ser free de novo

assim, se forjarmos um chunk com o size no mesmo endereço que o 
size do chunk_B, temos um free em um chunk de tamanho arbitrário

eu vou edit(chunk_B, "BBBBB") pra ficar mais fácil de 
identificar, mas voce nao precisa. 

  0x0000000000000000	0x0000000000021001
  0x00007f9e2c144b58	0x00007f9e2c144b58
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000090	0x0000000000000090 <- aqui
  0x4242424242424242	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000

nos podemos fazer isso tanto com um UAF para dar write em um chunk 
falso, um overflow a partir de outro chunk ou remaindering

como os outros métodos sao intuitivos, so vou explicar remaindering

voce quer criar um chunk de tamanho X (ex: 0x20)
voce comeca alocando um chunk de tamanho 0x80+X

chunk_C =  malloc(0x80 + 0x20)
chunk_top = malloc (0x88) # Prevenir consolidação com o top
free(chunk_C)

	0x0000000000000000	0x00000000000000b1 <-- chunk_C
  0x00007efc47c42b58	0x00007efc47c42b58 unsortedbin[all][0]
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000090	0x0000000000000090 chunk_B antigo
  0x4242424242424242	0x0000000000000000
  0x0000000000000000	0x0000000000000091 <-- chunk_top
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000020ee1
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000020ec1 <-- Top chunk

agora nos pegamos um chunk que va causar remaindering no chunk_C
e criar um chunk de tamanho X com o size na mesma posição do 
size antigo do chunk_B

chunk_D = malloc(0x88)

  0x0000000000000000	0x0000000000000091 <-- chunk_D
  0x00007efc47c42b58	0x00007efc47c42b58
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000 BBBBB substituído por pointers
  0x0000000000000090	0x0000000000000021 <-- unsortedbin[all][0]
  0x00007fcbb3712b58	0x00007fcbb3712b58 MESMO ENDEREÇO DO CHUNK_B
  0x0000000000000020	0x0000000000000090 <-- chunk_top
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000020ee1
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000020ec1 <-- Top chunk

agora, o pointer do chunk_B aponta para um size 0x20

para testar, podemos dar free nele e consequentemente criar um 
fastbin

OBS: se lembre de tirar esse teste depois, pois nos precisamos 
fazer mais coisa antes para termos um exploit funcional

  0x0000000000000000	0x0000000000000091
  0x00007efc47c42b58	0x00007efc47c42b58
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000090	0x0000000000000021 <-- fastbins[0x20][0], unsortedbin[all][0]
  0x0000000000000000	0x00007fcbb3712b58 1 pointer = null
  0x0000000000000020	0x0000000000000090 <-- chunk_top
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000020ee1
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000020ec1 <-- Top chunk

então, ate agora temos
chunk_A = malloc(0x88)
chunk_B = malloc(0x88)

free(chunk_A)
free(chunk_B)

chunk_C = malloc(0x80 + 0x20) # o chunk gerado sera de size 0x20
chunk_TOP = malloc(0x88)
free(chunk_C)

chunk_D = malloc(0x88) # remainder
# free(chunk_B) # checar double free
```
