# House of Spirit

- [House of Spirit](#house-of-spirit)
- [Teoria](#teoria)
- [Fastbins](#fastbins)
- [Smallbins](#smallbins)
- [Exec: Converter em Fastbin Dup](#exec-converter-em-fastbin-dup)

# Teoria
House Of Spirit é uma tecnica que nos permite dar `free` um chunk falso que 
fica por exemplo, no `heap`, `stack*`, `data`,... ou qualquer outro lugar

A tecnica é parecida com um fastbin dup, porem menos versátil e mais difícil de 
executar, porem nos permite usar vulnerabilidades fora do heap (como um stack 
bof) e traze-las para o contexto do heap.

Assim, nos criamos um chunk falso e chamamos `free()` nele!

Um exemplo da vida real seria por exemplo, por meio de um stack bof alterar
um pointer para o heap, ja que eles sao muito comuns, e apontar para o chunk 
falso.

Entre as restrições no chunk falso temos:
- tamanho
  - Voce devera passar pelas mitigações ja pre-existentes para aquele tipo de 
  chunk
  - `fastbins` é o mais fácil
  - `small` tem mais mitigações porem pode ser usado junto com remaindering 
  para criar mais um chunk logo em frente do chunk falso
  - Eu nao vejo pq usar `large` poderia ser vantajoso, mas se quiser testar 
- flags
  - Para precisarmos passar pelo menor numero de mitigações possível, temos: 
  - PREV_USE = 1
  - IS_MMAPED = 0
  - NON_MAIN = 0
  - bit sem uso = 0
- Endereço
  - Pointer alinhado a 16 bytes
  - smallbins: endereço <= heap + top_size 

Alem disso, malloc ira checar se o tamanho do proximo chunk é valido :
`&chunk + chunk.size + 8`
```
0000000000000000  0000000000000031 <--| fake 
0000000000000000  0000000000000000    |
0000000000000000  0000000000000000 ___| 
0000000000000000   TAMANHO VALIDO  < &fake + fake.size + 8 = tamanho valido
0000000000000000  0000000000000000
```
Então voce pode simplesmente lotar aquela area com fenceposts ou qualquer valor razoável, sei la, `0x21`... nao importa muito

# Fastbins
Fazer a HoS é mais fácil com os fastbins, e voce so deve usar outro tipo caso 
seja vital voce usar remaindering (ou outra capacidade de chunk maiores) ou 
caso voce nao possa controlar o tamanho... Caso contrario use um fastbin... 

Nos poderíamos por exemplo, num programa que armazena nosso `username` no 
`data`, nos vamos usa-lo para armazenar o chunk falso, assim definindo-o como:

```py
username = flat(
    0x31,
    0,0,0,0,0,
    0x21,# tamanho valido
)
```
O programa possui pointers no heap para o `data` (`+ 0x10`) dos chunks... 
Porem alguém vacilou e deixou passar um BoF, e como o pointer é uma variável 
local da função, voce nao precisara nem se quer acertar o canary:
```
| Buf | Dados | Buf Buf | pointers | Buf Buf Buf | canary, rbp, rip, essas coisas
              | Overflow aqui
```
Assim, se por meio do overflow colocarmos um dos pointers como: `username + 0x10` 
( + 0x10 para ajustar, levando em consideração que o pointer originalmente 
apontava para o `data` de um chunk...

E agora quando o programa chamar `free` nesse pointer, BOOM! Chunk falso no 
fastbin!


# Smallbins
Para os smallbins o procedimento é similar!

A parte do overflow continua tudo igual, a única mudança é que ao apos o 
tamanho valido, colocamos um fencepost...

Assim, nos evitamos que o chunk consolide para frente!

```py
username = flat(
    0xa1,
    0,0,0,0,0,
    0x11, # tamanho valido
    0
    0x11, # nao consolidar
    0
```

Alem disso, o endereço do chunk falso deve ser ANTES do heap, para evitar uma 
mitigação

# Exec: Converter em Fastbin Dup
Bom, e como podemos prosseguir? nos podemos alocar esse chunk e usa-lo para 
dar write, mas isso nao e la muito util, se nos ja podíamos escrever 
naquela região pra inicio de conversa... então vamos precisar de algo a mais 
para conseguir uma shell

Para conseguir execução de código, nos poderíamos por exemplo corromper o 
malloc_hook... mas `find_fake_fast` em condições normais somente retornara um 
chunk de tamanho `7f` incompatível com o House Of Spirit por causa das flags...

Então vamos voltar a essencia do que esse ataque: free esta sendo chamado num 
pointer, e nos podemos dar overflow nesse pointer

Esse se nos apontarmos esse pointer para um chunk que ja foi liberado? 

**Double Free!!!!** 

Vamos continuar com o exemplo anterior, nos podemos alterar pointers para o 
heap:
```
| Buf | Dados | Buf Buf | pointers | Buf Buf Buf | canary, rbp, rip, essas coisas
              | Overflow aqui
```
E vamos supor o estado atual do heap:
```x86asm
0x70 - chunk_A
0x20 - Chunk_B
0x70 - chunk_C
0x50 - chunk_D
```
e o nosso overflow corrompe primeiro o pointer para chunk_D!
```
| Buf Buf | pointer_D pointer_C pointer_B pointer_A |
AAAAAAAAA  
```
Para tornar o ataque independente de heap leak, nos podemos alterar somente o 
LSB do pointer

Se alteramos para `0x00`, ele apontara para o inicio do heap, portanto se 
alterarmos para `0x10`, estaremos apontando para a user_data do chunk_A

E se mudarmos para `0x80`, para a user_data do chunk_B

Assim, podemos escolher um deles para dar um double free, eu vou escolher o A!

Como o A é um fastbin, nos convertemos a House Of Spirit em um fastbin dup...

mesmo se o programa manualmente cuidar dos chunks para previvir um double free,
esse ataque ainda funcionaria, pois tecnicamente a gente chamou free em 
pointers diferentes :D

```py
overflow(b"A"*0x120 + "\x10") # pointer_D -> chunk_A
free(pointer_A)
free(pointer_C) # Free num chunk do mesmo fastbin
free(pointer_D) # Fastbin dup
```
> Agora o fastbin 0x70 fica:\
> head: chunk_A -> chunk_B -> chunk_A

E voce pode prosseguir normalmente com o fastbin dup, agora podendo criar um 
chunk falso no malloc_hook... Ja que o tamanho `7f` é compatível com o fastbin 
dup :D