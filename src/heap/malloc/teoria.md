# Teoria
- [Teoria](#teoria)
- [Chunk](#chunk)
- [Top](#top)
- [Arena](#arena)
- [Binlists](#binlists)
    - [Fastbins](#fastbins)
    - [Unsorted bin](#unsorted-bin)
      - [Remaindering](#remaindering)
    - [Small Bins](#small-bins)
    - [Large Bins](#large-bins)
- [Outras operações](#outras-operações)
- [Hooks](#hooks)
- [TCache](#tcache)
  - [Struct](#struct)
  - [Environment](#environment)
  - [Mitigações](#mitigações)
    - [Key 2.29 / Double Free](#key-229--double-free)
  - [Operações](#operações)
    - [Dump / Transferência](#dump--transferência)
- [Obs](#obs)

O Heap é composto por chunks, alocados por meio de `malloc()` e liberados por meio de `free()`.

Malloc recebe normalmente 1 parâmetro: tamanho! Porem esse valor a esse valor é 
adicionado `0x08` e arredondado para cima. Por exemplo:
- malloc(0x18) -> 0x20 -> 0x20
- malloc(0x20) -> 0x28 -> 0x30
- malloc(1)    -> 0x20 TAMANHO MINIMO!

Esse é o tamanho (`size`) do chunk!


# Chunk
O chunk, quando alocado consiste em:
```
0000000000000000        size      -> Lembrando que size inclui os metadados
0000000000000000 0000000000000000 <- dados do usuário
0000000000000000 0000000000000000
```

A visão do usuário e a visão interna de um chunk sao diferentes:
```x86asm
0000000000000000 0000000000000031 <- visão malloc
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB <- visão usuário
CCCCCCCCCCCCCCCC EEEEEEEEEEEEEEEE
FFFFFFFFFFFFFFFF 0000000000000020 <- visão malloc
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB <- visão usuário
CCCCCCCCCCCCCCCC 
``` 
Nos vamos usar a visão do malloc daqui em diante! Portanto:
`Chunk + 0x08 -> size` e `Chunk + 0x10 -> dados` 

O tamanho do chunk, por ser alinhado a 16 bytes, nas usa os últimos 4 bits do size,
e assim eles sao usados pra flags:
- 1 - PREV_INUSE
  - `1` se o `chunk adjacente anterior` esta em uso (nao free)
  - Se o `chunk anterior` esta livre (`0`), o nosso chunk rouba a ultima qword (a 
    logo antes do `size`) para armazenar o `size do chunk anterior`: `PREV_SIZE`
- 2 - IS_MMAPPED
  - `1` se o chunk foi adquirido via `mmap` 
  - Os outros bits sao ignorados pois: 
    - Nao possui chunks adjacente
    - Nao faz parte de uma arena
- 4 - NON_MAIN_ARENA
    - `0` se esta na `main_arena`
    - `1` se esta em qualquer outra thread
- 8 - Sem uso atualmente

# Top
O chunk `top` fica na borda do heap:
```x86asm
0000000000000000 0000000000000031 <- chunk 1
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB
CCCCCCCCCCCCCCCC EEEEEEEEEEEEEEEE 
FFFFFFFFFFFFFFFF 0000000000000020 <- chunk 2
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB
CCCCCCCCCCCCCCCC 0000000000003f41 <- top
``` 
O top chunk tem um tamanho enorme, e quando nos alocamos um novo chunk, estamos 
tirando uma fatia dele.

Se ele ficar pequeno de mais, pode ser extendido por meio da syscall `sbrk` (system 
break)

O system break é um limite de quanta memoria nos podemos gastar, e é controlado pelo 
sistema operacional.

Alem disso, caso o chunk que passe do limite do `top` seja enorme (0x5000 por 
exemplo) ao envés de gastar o `top` todo e precisar chamar `srbk`, basta alocar o 
espaço desse chunk em outro canto usando `mmap`.

# Arena
Uma arena é um agregador de metadados referentes a aquele heap, com cada thread tendo
uma. A da main thread é chamada de `main_arena` !

Entre os metadados armazenados nos temos, por exemplo:
- Endereço do top chunk
- Head das binlists
- Pointer para outras arenas
- Quanta memoria o sistema operacional disponibilizou

A main_arena é uma variável global, enquanto as outras sao segmentos de heap!

O comportamento do `top` descrito anteriormente somente ocorre na main_arena
# Binlists
Quando um chunk nao é mais util, voce pode chamar `free()` passando o chunk como 
parâmetro!

Quando um chunk é liberado, ele é colocado em uma binlist e a sua estrutura muda!

Binlists sao linked lists (single ou double | circular ou nao circular) que 
armazenam os free chunks, com cada chunk sendo um node na list.

Sao as head dessas binlists que sao armazenadas na main arena!

Elas sao classificadas pelo tamanho do chunk que armazenam:
- Fastbins: 0x20, 0x30,....., 0x80
- Unsorted bin: * 
- smallbins
- largebins
 
### Fastbins
Os fastbins sao usados para rapidamente alocar e liberar chunks.

Cada um deles contem uma singly-linked-list de chunks de mesmo tamanho. 

O local aonde ficaria os `dados`, em um free chunk sera usado para metadados, e 
no caso dos fastbins, por ser uma singly-linked-list somente um pointer (`FD`) para 
o proximo chunk na lista.

Alem disso, essa lista é nao circular, isto é: o ultimo chunk tem FD=0 (NULL)

Como os fastbins nao sao consolidados com outros free chunks adjacentes, eles sempre
possuem `PREV_INUSE`=`1`

Então por exemplo um chunk do fastbin 0x30 contem: 
```x86asm
0000000000000000     size=0x31
        FD       0000000000000000
0000000000000000 0000000000000000
0000000000000000
```

Alem disso, os fastbins sao `LIFO`, assim como uma stack:
```C++
head: chunk 1 -> chunk 3 -> 0 (NULL)

free(chunk 4)
head: chunk 4 -> chunk 1 -> chunk 3 -> 0 (NULL)

malloc()
head: chunk 1 -> chunk 3 -> 0 (NULL)

free(chunk 5)
head: chunk 5 -> chunk 1 -> chunk 3 -> 0 (NULL)

free(chunk 10)
head: chunk 10 -> chunk 5 -> chunk 1 -> chunk 3 -> 0 (NULL)

malloc()
head: chunk 5 -> chunk 1 -> chunk 3 -> 0 (NULL)
```

Então por exemplo:
```C++
Código:
malloc() 6 vezes
free(Chunk 4)
free(Chunk 2)
free(Chunk 5)
free(Chunk 3)

Main Arena:
Fastbin 0x20 = & Chunk 3   
Fastbin 0x20 : Chunk 3 -> Chunk 5 -> Chunk 2 -> Chunk 4 -> 0 (NULL)

Heap:
0000000000000000 0000000000000021 <- Chunk 1
0000000000000000 0000000000000000
0000000000000000 0000000000000021 <- Chunk 2 - Fastbin 0x20 [3]
    & Chunk 4    0000000000000000
0000000000000000 0000000000000021 <- Chunk 3 - Fastbin 0x20 [4]
    & Chunk 5    0000000000000000
0000000000000000 0000000000000021 <- Chunk 4 - Fastbin 0x20 [0]
   00000 (NULL)  0000000000000000
0000000000000000 0000000000000021 <- Chunk 5 - Fastbin 0x20 [1]
    & Chunk 2    0000000000000000
0000000000000000 0000000000000021 <- Chunk 6
0000000000000000 0000000000000000
0000000000000000 0000000000003d11 <- top
```

### Unsorted bin
O unsorted bin armazena chunks de tamanho diversos, que serão distribuídos 
(**SORT**) para uma `small`/`large` bin de tamanho apropriado

A Unsorted bin é uma doubly linked list (`FD` e `BK`) circular!

Na hora de procurar um chunk de tamanho adequado para um `malloc()`, começa-se 
a busca pela `tail` e somente retorna um chunk de tamanho idêntico 
(`exact fit`) ao pedido! 

Conforme essa lista vai sendo atravessada, o processo de **SORT** vai ocorrer!

Quando o chunk de tamanho correto é encontrado, ele sofre um 
[parcial unlink](https://0xturazzi.github.io/book/heap/malloc/PartialUnlink.html) !

#### Remaindering
Caso a busca chegue no `ultimo chunk do unsorted bins` e ele seja maior do que 
o pedido, ele sera dividido em 2 em um processo chamado `remaindering`:
```
 _________
|    |size|
| FD | BK |
|         |
|         |
|         |
|         |
|         |
|         |
|         |
|         |
|_________|

Divide o chunk em 2
 _________
|    |size|
| FD | BK |
|         |
|         |
|         |
|_________|
|         |
|         |
|         |
|         |
|_________|

Retorna o primeiro

Coloca o segundo no unsortedbin e 
      o define como last_remainder 
      (pointer na main_arena que 
      aponta para o ultimo chunk
      a ser dividido) 
 _________
|    |size| <- Nosso chunk
|  dados  |
| AAAAAAA |
|         |
|         |
|_________|
|    |size| <-- Unsorted Bins e last_remainder
| FD | BK |
|         |
|         |
|_________|

```
### Small Bins

Os small bins sao similares ao unsorted bin, sendo 
`double-linked -lists` (fd e bk) e circulares. Com essa lista 
sendo `FIFO`(`first-in first-out`), os chunks `entram/free` pela \
head e `saem/malloc` pela tail.

Cada small bins armazena somente um tamanho especifico de chunk, 
de `0x20` a `0x3f0`. Como voce pode perceber, existe uma 
intercessão entre os tamanhos de fast e small. Nos podemos 
migrar um fast chunk para o unsorted bins (e consequentemente para 
o respectivo small bins usando malloc consolidate())   

### Large Bins
Os Large Bins sao:
- size >= 0x400
- Double linked lists (fd e bk)
- Listas Circulares
Existem 64, com apenas 63 sendo usados 
  - Large 0x400: 0x400, 0x410, 0x420 e 0x430
  - Large 0x440: 0x440, 0x450, 0x460 e 0x470
  - ...

Quanto maior o size, mais tamanhos de chunks ele armazena, em uma escala 
logarítmica
- Large 0x400: 0x400, 0x410, 0x420 e 0x430
- Large 0x5000: 0x5000, 0x5010, ... , 0x5ff0   
- Large 0x80000: size >= 0x80000 (teoricamente infinito)

Os chunks ficam em ordem decrescente de tamanho em relação a head:

`head:> 0x430 --- 0x420 --- 0x410 --- 0x400 <:tail` 

Para manter essa ordem de tamanho, sao usadas skiplists, explicadas depois.

Os primeiros chunks de cada size, alem de `fd` e `bk`, possuem `fd_nextsize` 
e`fd_nextsize`. Esses chunks que contem metadados adicionais sao chamados de 
skipchunks

```py
head:  0x430  0x430     0x420   0x420   0x410     0x400   0x400 :tail
 ...>|      |>|     |>|      |>|     |>|      |>|      |>|     |>... fd
 ...<| skip |<|     |<| skip |<|     |<| skip |<| skip |<|     |<... bk
        ^ |              ^ |              ^ |      ^ |
.....___| |______________| |______________| |______| |___________.....
            fd_nextsize      fd_nextsize               fd_nextsize

E mesma coisa com o bk_nextsize.

Com o fd_nextsize apontando para um tamanho MENOR
Com o bk_nextsize apontando para um tamanho MAIOR
```
Assim, os `fd_nextsize` e `fd_nextsize` formam uma 
`doubly linked circular list`, contendo a primeira instancia de cada tamanho de 
chunk presente naquele largebin. Essa "meta-lista" é a skiplist :D

Quando um chunk de tamanho novo é `free()`, ele é colocado na skiplist do 
respectivo largebin. Em seguida, todos os chunks com aquele tamanho, serão 
colocados logo apos o primeiro, sem interferir com a skiplist.

Mesma coisa com alocações, com o chunk retirado sendo o mais recente a entrar 
naquela skiplist (`LIFO`). Portanto o skipchunk sera o ultimo a ser 
alocado entre os chunks daquele tamanho. Assim, nao interferindo com a 
skiplist. 

Assim, garantindo a ordem de tamanhos dentro de um largebin :D 

> Obs: Quando um chunk **NAO** skipchunk é sort para um large bin, os seus 
> bk_nextsize e fd_nextsize SAO **NULLIFICADOS**

> Obs 2: o unlink nos largebins ocorre pelo fd, para evitar 
> alocar o skipchunk. E alem disso eles sempre sofrem um unlink **COMPLETO**,
> pois o chunk pode vir do meio da lista! (safe unlink)

# Outras operações
- `calloc( size )`: igual `malloc()` porem inicializa a região para NULL
  - Ineficiente porem mais seguro
- `realloc( chunk , size )`: muda o tamanho de um chunk
  - Chama `free()` no chunk, `malloc()` um novo chunk de tamanho `size` e transfere os dados do chunk antigo para o novo
  - Se `size == 0`, simplesmente atua como um `free()`: muitos devs nao sabem disso
    - Sanitizam os `free()`s corretamente, mas esquecem de sanitizar os `realloc()`s
- Consolidar para frente (por exemplo, no free)
  - Algorítimo
    - Começa no endereço do chunk_A 
    - Anda chunk_A.`size` para encontrar o chunk_B
    - Anda chunk_B.`size` para encontrar o chunk_C (sem checar se size é valido)
    - Checa `prev_in_use` do chunk_C para saber se o chunk_B é free
    - Se for free, consolida chunk_A e chunk_B
  - Evitar
    - Forjar fenceposts apos o chunk_A
      - edit(chunk_A, flat(0, 0, 0, 0x10, 0, 0x10 )) 
    - Alterar chunk_A.size = 0x1
      - Ele vai andar 0 e se auto-checar 
- `malloc_consolidate()` pega todos os fast chunks de uma arena e os coloca no unsorted bin
  - Assim, consolidando todos os chunks, e diminuindo a fragmentação do heap 
  - Como ele vai contra a logica dos fastbins, somente ocorre em situações extremas
  - chamado de 2 lugares no malloc, e em 1 no free
    - malloc 
      - malloc >= 0x400 : Apos o consolidate, esse chunk vai ser alocado a partir dos unsorted bins
        - Isso pode ser um problema se voce tiver um chunk falso que nao passe: (fencepost < chunk <= system_mem). Voce tem 2 opções
        - 1 : Criar e liberar um chunk falso logo no inicio do exploit, fazendo com que o malloc aloque ele antes de chegar no chunk_fake
        - 2 : alterar o  size do malloc(0x400) para um valor acima do fast_consolidate_threshold, evitando que o unsorted bin se quer seja pesquisado
          - Cada distro tem um
          - Padrão: 0x10000 
    - free 
      - Se consolidar um chunk normal com um chunk >= fast_consolidate_threshold
      - O top_chunk obviamente é maior   


# Hooks
- __after_morecore_hook
- __morecore
  - os morecore sao ativados quando o top chunk é consumido
  - difícil de passar argumentos
- __free_hook
  - Nao alinhado 16 bytes (addr termina em 8) (nem sempre, depende
   do compilador)
- __malloc_hook
- __malloc_initialize_hook
  - raro de usar, chamado no inicio da execução 
- __memalign_hook
  - usado quando vc da malloc pedindo um alinhamento especifico 
- __realloc_hook
  - Nao alinhado 16 bytes (addr termina em 8) (nem sempre, depende 
  do compilador)

> Dica: Colocar breakpoint em hooks usando hardware breaks
> gdb> rwatch __malloc_hook 
> Quando o programa tentar dar read nele (pra usa-lo), vai pausar

# TCache

O TCache (Thread Cache), vem ativado por padrão a partir de 2.25. 
E ele acaba enfraquecendo muitas mitigações, facilitando nossa vida.
Ele também pode ser chamado de Magazine (nome da primeira 
implementação no JEmalloc do Solari)


Cada Thread em um processo recebe uma arena (e heap), porem o 
numero de arenas é limitado pelo numero de cores do processo

Assim, as vezes múltiplas thread dividem a mesma arena, e para 
prevenir races malloc usa locks. Porem, isso deixa ele 
drasticamente mais lento. Portanto foi criado o TCache! 

Cada Thread contem o seu, e ele é uma mini-arena (implementado por 
meio de um chunk no heap, com a primeira thread sendo no inicio do 
heap, e as outras, em qualquer posição. Esse chunk se comporta como 
qualquer outro, podendo  por exemplo, ser consolidado)... 

Assim, quando uma thread da free, esse chunk pode ir para o seu 
TCache, e em um malloc seguinte ser fornecido por ele, sem precisar 
esperar outra thread terminar suas alocações. Por ser mais rápido, 
ele toma precedente em relação a arena real (Por exemplo um free 
0x20 vai para o `Tcachebin 0x20` e nao para o `fastbin 0x20`, o 
mesmo vale para alocações).

## Struct
O Tcache possui duas partes: Counts (contagens) e Entries (entradas)
, 64 de cada 

Cada Entry age como uma fastbin, sendo a head de uma lista nao 
circular LIFO (ultimo free = head), de tamanho especifico (0x20 - 
0x410 (maior do que isso vai para os unsortedbins como normalmente acontece)). 

A única diferença é que a entry aponta para a `data` e nao 
para o inicio real do chunk (isso continua pelo resto da lista, com 
o fd apontando para o data)

Ja cada Count mantem uma contagem de quantos elementos estão em cada bin 

> OBS: O tamanho do count muda: 1 byte (2.26 a 2.29), 2 bytes (>= 2.30)... Assim, o TCache como um todo pode ter size 0x250 ou 0x290


Assim, quando vc da free em um chunk 0x20, por exemplo, ao envés de 
ir pro fastbin 0x20, ele vai para o `tcachebins [0x20]` e a 
primeira qword do tcache sera +=1

## Environment
- tcache_count
  - encontra usando gdb> mp
  - Padrão: 7
  - Cada tcachebin somente pode ter X chunks, caso voce de free e aquele bin 
  ja esteja cheio, vai para o comportamento de free normal (0x20 pra fast 0x20 por exemplo)

## Mitigações 
### Key 2.29 / Double Free
A partir da versão 2.29, quando um chunk vai pro tcachebin, 
o endereço do seu `bk` é reutilizado como `key` (aponta para o 
tcache)

Assim, se o chunk tem key, quer dizer que ele esta free... eles 
serão NULL quando alocados

Como se fosse um prev_in_use. mas para o chunk atual

Sempre que um chunk é free (mesmo se nao estiver no tcache), a key 
é checada... se ela aponta para o tcache, corre o risco de ser um 
double free (mas nao da pra ter 100% de certeza pq pode ser so 
bytes aleatórios que coincidiram)

Então para poder checar de novo para ter certeza. ele itera sobre 
**TODOS** os chunks daquele tcache bin vendo se alguém aponta para 
ele. Se encontrar algum, o programa crasha.

Para passar a mitigação:
- Corromper a Key
- Esse check nao ocorre se voce estiver transferindo um chunk

## Operações
### Dump / Transferência
O `tcache 0x20` ta vazio

O `fast 0x20` tem chunks

Se vc alocar um chunk 0x20, ele vai vai vir pra vc, e alguns dos chunks 
do `fast 0x20` vao ser transferidos para encher o `tcache 0x20`

> Ele faz isso iterando atraves do chunks ate que encontre um fd=0 ou chegue ao limite do tcache_count

O Mesmo se aplica aos smallbins

Para os unsortedbins, ao envés de alocar um, e transferir o resto, ele vai:
- Vai andando pelos unsorted bins
- SORT os chunks
- Se ele tem o tamanho exato que vc pediu, manda pro tcache
- Continua
- Ao final, pega o ultimo chunk que foi mandado pra tcache e aloca ele

Então a ordem é ao contrario: primeira transfere, depois aloca o ultimo a ser transferido

# Obs
- Calloc nao aloca do tcache