# Teoria
- [Teoria](#teoria)
- [Chunk](#chunk)
- [Top](#top)
- [Arena](#arena)
- [Binlists](#binlists)
    - [Fastbins](#fastbins)
    - [Unsorted bin](#unsorted-bin)
      - [Remaindering](#remaindering)
    - [Small Bins](#small-bins)
    - [Large Bins](#large-bins)
- [Outras operações](#outras-operações)

O Heap é composto por chunks, alocados por meio de `malloc()` e liberados por meio de `free()`.

Malloc recebe normalmente 1 parâmetro: tamanho! Porem esse valor a esse valor é 
adicionado `0x08` e arredondado para cima. Por exemplo:
- malloc(0x18) -> 0x20 -> 0x20
- malloc(0x20) -> 0x28 -> 0x30
- malloc(1)    -> 0x20 TAMANHO MINIMO!
Esse é o tamanho (`size`) do chunk!


# Chunk
O chunk, quando alocado consiste em:
```
0000000000000000        size      -> Lembrando que size inclui os metadados
0000000000000000 0000000000000000 <- dados do usuário
0000000000000000 0000000000000000
```

A visão do usuário e a visão interna de um chunk sao diferentes:
```x86asm
0000000000000000 0000000000000031 <- visão malloc
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB <- visão usuário
CCCCCCCCCCCCCCCC EEEEEEEEEEEEEEEE
FFFFFFFFFFFFFFFF 0000000000000020 <- visão malloc
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB <- visão usuário
CCCCCCCCCCCCCCCC 
``` 
Nos vamos usar a visão do malloc daqui em diante! Portanto:
`Chunk + 0x08 -> size` e `Chunk + 0x10 -> dados` 

O tamanho do chunk, por ser alinhado a 16 bytes, nas usa os últimos 4 bits do size,
e assim eles sao usados pra flags:
- 1 - PREV_INUSE
  - `1` se o `chunk adjacente anterior` esta em uso (nao free)
  - Se o `chunk anterior` esta livre (`0`), o nosso chunk rouba a ultima qword (a 
    logo antes do `size`) para armazenar o `size do chunk anterior`: `PREV_SIZE`
- 2 - IS_MMAPPED
  - `1` se o chunk foi adquirido via `mmap` 
  - Os outros bits sao ignorados pois: 
    - Nao possui chunks adjacente
    - Nao faz parte de uma arena
- 4 - NON_MAIN_ARENA
    - `0` se esta na `main_arena`
    - `1` se esta em qualquer outra thread
- 8 - Sem uso atualmente

# Top
O chunk `top` fica na borda do heap:
```x86asm
0000000000000000 0000000000000031 <- chunk 1
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB
CCCCCCCCCCCCCCCC EEEEEEEEEEEEEEEE 
FFFFFFFFFFFFFFFF 0000000000000020 <- chunk 2
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB
CCCCCCCCCCCCCCCC 0000000000003f41 <- top
``` 
O top chunk tem um tamanho enorme, e quando nos alocamos um novo chunk, estamos 
tirando uma fatia dele.

Se ele ficar pequeno de mais, pode ser extendido por meio da syscall `sbrk` (system 
break)

O system break é um limite de quanta memoria nos podemos gastar, e é controlado pelo 
sistema operacional.

Alem disso, caso o chunk que passe do limite do `top` seja enorme (0x5000 por 
exemplo) ao envés de gastar o `top` todo e precisar chamar `srbk`, basta alocar o 
espaço desse chunk em outro canto usando `mmap`.

# Arena
Uma arena é um agregador de metadados referentes a aquele heap, com cada thread tendo
uma. A da main thread é chamada de `main_arena` !

Entre os metadados armazenados nos temos, por exemplo:
- Endereço do top chunk
- Head das binlists
- Pointer para outras arenas
- Quanta memoria o sistema operacional disponibilizou

A main_arena é uma variável global, enquanto as outras sao segmentos de heap!

O comportamento do `top` descrito anteriormente somente ocorre na main_arena
# Binlists
Quando um chunk nao é mais util, voce pode chamar `free()` passando o chunk como 
parâmetro!

Quando um chunk é liberado, ele é colocado em uma binlist e a sua estrutura muda!

Binlists sao linked lists (single ou double | circular ou nao circular) que 
armazenam os free chunks, com cada chunk sendo um node na list.

Sao as head dessas binlists que sao armazenadas na main arena!

Elas sao classificadas pelo tamanho do chunk que armazenam:
- Fastbins: 0x20, 0x30,....., 0x80
- Unsorted bin: * 
- smallbins
- largebins
 
### Fastbins
Os fastbins sao usados para rapidamente alocar e liberar chunks.

Cada um deles contem uma singly-linked-list de chunks de mesmo tamanho. 

O local aonde ficaria os `dados`, em um free chunk sera usado para metadados, e 
no caso dos fastbins, por ser uma singly-linked-list somente um pointer (`FD`) para 
o proximo chunk na lista.

Alem disso, essa lista é nao circular, isto é: o ultimo chunk tem FD=0 (NULL)

Como os fastbins nao sao consolidados com outros free chunks adjacentes, eles sempre
possuem `PREV_INUSE`=`1`

Então por exemplo um chunk do fastbin 0x30 contem: 
```x86asm
0000000000000000     size=0x31
        FD       0000000000000000
0000000000000000 0000000000000000
0000000000000000
```

Alem disso, os fastbins sao `LIFO`, assim como uma stack:
```C++
head: chunk 1 -> chunk 3 -> 0 (NULL)

free(chunk 4)
head: chunk 4 -> chunk 1 -> chunk 3 -> 0 (NULL)

malloc()
head: chunk 1 -> chunk 3 -> 0 (NULL)

free(chunk 5)
head: chunk 5 -> chunk 1 -> chunk 3 -> 0 (NULL)

free(chunk 10)
head: chunk 10 -> chunk 5 -> chunk 1 -> chunk 3 -> 0 (NULL)

malloc()
head: chunk 5 -> chunk 1 -> chunk 3 -> 0 (NULL)
```

Então por exemplo:
```C++
Código:
malloc() 6 vezes
free(Chunk 4)
free(Chunk 2)
free(Chunk 5)
free(Chunk 3)

Main Arena:
Fastbin 0x20 = & Chunk 3   
Fastbin 0x20 : Chunk 3 -> Chunk 5 -> Chunk 2 -> Chunk 4 -> 0 (NULL)

Heap:
0000000000000000 0000000000000021 <- Chunk 1
0000000000000000 0000000000000000
0000000000000000 0000000000000021 <- Chunk 2 - Fastbin 0x20 [3]
    & Chunk 4    0000000000000000
0000000000000000 0000000000000021 <- Chunk 3 - Fastbin 0x20 [4]
    & Chunk 5    0000000000000000
0000000000000000 0000000000000021 <- Chunk 4 - Fastbin 0x20 [0]
   00000 (NULL)  0000000000000000
0000000000000000 0000000000000021 <- Chunk 5 - Fastbin 0x20 [1]
    & Chunk 2    0000000000000000
0000000000000000 0000000000000021 <- Chunk 6
0000000000000000 0000000000000000
0000000000000000 0000000000003d11 <- top
```

### Unsorted bin
O unsorted bin armazena chunks de tamanho diversos, que serão distribuídos 
(**SORT**) para uma `small`/`large` bin de tamanho apropriado

A Unsorted bin é uma doubly linked list (`FD` e `BK`) circular!

Na hora de procurar um chunk de tamanho adequado para um `malloc()`, começa-se 
a busca pela `tail` e somente retorna um chunk de tamanho idêntico 
(`exact fit`) ao pedido! 

Conforme essa lista vai sendo atravessada, o processo de **SORT** vai ocorrer!

Quando o chunk de tamanho correto é encontrado, ele sofre um 
[parcial unlink](https://0xturazzi.github.io/book/heap/malloc/PartialUnlink.html) !

#### Remaindering
Caso a busca chegue no `ultimo chunk do unsorted bins` e ele seja maior do que 
o pedido, ele sera dividido em 2 em um processo chamado `remaindering`:
```
 _________
|    |size|
| FD | BK |
|         |
|         |
|         |
|         |
|         |
|         |
|         |
|         |
|_________|

Divide o chunk em 2
 _________
|    |size|
| FD | BK |
|         |
|         |
|         |
|_________|
|         |
|         |
|         |
|         |
|_________|

Retorna o primeiro

Coloca o segundo no unsortedbin e 
      o define como last_remainder 
      (pointer na main_arena que 
      aponta para o ultimo chunk
      a ser dividido) 
 _________
|    |size| <- Nosso chunk
|  dados  |
| AAAAAAA |
|         |
|         |
|_________|
|    |size| <-- Unsorted Bins e last_remainder
| FD | BK |
|         |
|         |
|_________|

```
### Small Bins

Os small bins sao similares ao unsorted bin, sendo 
`double-linked -lists` (fd e bk) e circulares. Com essa lista 
sendo `FIFO`(`first-in first-out`), os chunks `entram/free` pela \
head e `saem/malloc` pela tail.

Cada small bins armazena somente um tamanho especifico de chunk, 
de `0x20` a `0x3f0`. Como voce pode perceber, existe uma 
intercessão entre os tamanhos de fast e small. Nos podemos 
migrar um fast chunk para o unsorted bins (e consequentemente para 
o respectivo small bins usando malloc consolidate())   

### Large Bins
# Outras operações
- `calloc( size )`: igual `malloc()` porem inicializa a região para NULL
  - Ineficiente porem mais seguro
- `realloc( chunk , size )`: muda o tamanho de um chunk
  - Chama `free()` no chunk, `malloc()` um novo chunk de tamanho `size` e transfere os dados do chunk antigo para o novo
  - Se `size == 0`, simplesmente atua como um `free()`: muitos devs nao sabem disso
    - Sanitizam os `free()`s corretamente, mas esquecem de sanitizar os `realloc()`s