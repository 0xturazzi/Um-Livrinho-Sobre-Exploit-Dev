- [Teoria](#teoria)
- [.data](#data)
  - [Exploit](#exploit)
    - [Safe Unlink](#safe-unlink)
    - [Edit no usr123 para controlar todos os pointers](#edit-no-usr123-para-controlar-todos-os-pointers)
    - [Arbwrite - Definir alvo](#arbwrite---definir-alvo)
    - [Arbwrite - Definir valor](#arbwrite---definir-valor)
  - [Unindo tudo](#unindo-tudo)
- [Outros exemplos](#outros-exemplos)

## Teoria
O safe unlink depende muito da implementação do programa, isso quer dizer 
que nao existe uma formula bonitinha para conseguir uma shell...

A mitigação que foi introduzida se consiste em:
- `assert`(vitima.fd.bk == vitima)
- `assert`(vitima.bk.fd == vitima)

Assim, agora alem de o `fd falso` e `bk falso` precisarem ser endereços 
validos, precisaremos de que:
- `fd falso` + 0x18 == pointer para `vitima`
- `bk falso` + 0x10 == pointer para `vitima`

Assim, precisamos de 1 ou 2 pointers que apontam para o nosso chunk, e que 
esse pointer seja importante.

## .data
Caso o programa tenha um struct com pointers para o heap, e acesse o heap por meio deles
```x86asm
.data
struct UsuárioLogado:
    nome: pointer para chunk, -> aponta para vitima
    senha: pointer para chunk,
    metadados: pointer para chunk,

```

E o programa use:
```
edit( * usr123.nome, novo_nome )
```
### Exploit
#### Safe Unlink
Nos podemos mirar o `fd falso` e `bk falso` apontando para o pointer que 
aponta para a vitima, passando o check de segurança...

Agora `fd` sera escrito no `*bk` e `bk` sera escrito no `*fd` (+ os offsets), 
mas os dois sao o mesmo alvo, então como consequência somente teremos a 
alteração de `usr123.nome` para o valor de `fd/bk` isto e:
ele aponta para ele mesmo (ou antes por causa dos offsets (+0x16,0x10,...))
`usr123.nome` = `& usr123.nome`

#### Edit no usr123 para controlar todos os pointers
Agora, caso tentemos editar o nome, vamos na verdade ter um write no struct 
`usr123` (e adjacentes)
```
edit( * usr123.nome, novo_nome )
```

E agora que controlamos todos os pointers por meio do `novo_nome`, podemos 
altera-los, com cada um abrindo uma nova avenida de exploitação... 

#### Arbwrite - Definir alvo

O mais obvio é alterar o `usr123.nome` de novo... nos dando um `arbwrite`
```
edit( * usr123.nome, __malloc_hook - 0x20 )
```
#### Arbwrite - Definir valor

agora `usr123.nome` aponta para o `__malloc_hook` e o proximo edit vai 
altera-lo...

### Unindo tudo

> `mudarNome`(`novo_nome`) = wrapper para interagir com o programa chamando o código de editar o nome

- Start
    - `usr123.nome` -> vitima
- Safe Unlink apontando para `usr123.nome`
    - `usr123.nome` -> `usr123.nome`
- mudarNome( `__malloc_hook` - `0x20` ) 
    - `usr123.nome` -> antes do `__malloc_hook`
- mudarNome( `A`*`pad` + `libc.system` )

## Outros exemplos
Outros cenários que podem ser viáveis passar essa mitigação incluem:
- Pointer na stack para o chunk
    - talvez de para alterar o ret salvo
- Voce forjar o seu próprio pointer caso tenha um heap leak
- Os metadados de um free chunk que aponte para vitima