# House of Lore

- [House of Lore](#house-of-lore)
- [UnsortedBin](#unsortedbin)
  - [Ataque](#ataque)
  - [Obs](#obs)


Na house of Lore vamos colocar um chunk falso no UnsortedBin, SmallBins ou LargeBins.

Porem, nao iremos chamar `free()` no chunk falso (como na House 
of Spirit) ou um double free (como no fastbin dup).

Esse foi um dos ataques do malloc malleficarium

# UnsortedBin
> Versão < 2.29
Para a HoL nos unsortedbins, precisamos de um `write-after-free` em um chunk 
dos unsorted bins.... Seja isso por meio de um overflow, ou o programa 
permitindo alterar chunks livres...

Isso deve te lembrar do Partial Unlink nos Unsorted Bins e da House of Orange.
Porem, nesses casos a parte importante era o write na hora da alocação, e nao 
a alocação em si, com na HoO ate usando o crash mitigação nessa alocação ao
nosso favor.

Porem neses caso, nos queremos que o chunk seja usável quando nos alocamos e 
que o programa nao crash... então precisaremos mudar um pouco a estrategia ...

## Ataque
Nos podemos usar o UAF no chunk do heap para alterar o bk, da mesma maneira que 
faríamos com o ataque dos unsortedbins...

Assim, vamos supor que o chunk falso sera criado no `username` (armazenado na 
`data` section)

```py
change_username(flat(
    0,
    0xc0,# size
    0,#fd
    0,#bk

)) 

edit_chunk_A(flat(
    0,# fd
    elf.sym.username
))
```
Assim, o unsorted bin fica:
> head bk: chunk_A -> username -> 0 
Em seguida, nos poderíamos alocar o chunk_A e sem seguida o nosso chunk falso

Porem, durante a alocação desses chunks, um ataque do unsorted bin acidental 
ocorreria, ok se mostra ok no caso do chunk_A, pois aponta para memoria valida 
( a data section aonde o chunk falso fica)

Entretanto, no caso do chunk falso, ele tentaria fazer um ataque dos 
unsortedbins em `0 + 0x10`, memoria invalida: SEGFAULT!!!!

Assim, nos precisamos garantir que o bk do chunk falso aponta para memoria 
escrevível! A solução mais fácil é aponta-lo para ele mesmo, corrompendo os 
8 bytes inúteis antes do size

```py
change_username(flat(
    0,
    0xc0,# size
    0,#fd
    elf.sym.username - 0x10,#bk
)) 
```
Agora basta realizar um malloc com o size do chunk falso, e pronto! Nos temos 
um chunk na data section (ou aonde vc criou o chunk falso)

## Obs
Como nos controlamos o bk do chunk falso, podemos apontar para outro chunk 
falso, ou ate pra ele mesmo contanto que voce nao danifique o bk entre 
alocações :D

Voce pode ter pode ter a 8 flag acidentalmente ligada que nao interfere

O size precisa < do que system_mem

o bk do chunk falso precisa apontar para memoria escrevível

Quando tentar encontrar sizes que ocorrem naturalmente, eles PODEM nao estar 
alinhados