# Fastbins Dup
- [Fastbins Dup](#fastbins-dup)
  - [Teoria](#teoria)
  - [Ataques](#ataques)
    - [Alocar um chunk](#alocar-um-chunk)
      - [Obs: __malloc_hook](#obs-__malloc_hook)
    - [Exec](#exec)
    - [Escrever um valor na main_arena](#escrever-um-valor-na-main_arena)
    - [Alocar um chunk na main_arena](#alocar-um-chunk-na-main_arena)
      - [Exemplo malloc antigo](#exemplo-malloc-antigo)


## Teoria
Se o chunk tiver nos fastbins (`0x20` a `0x80`), voce pode passar 
pelas mitigações de double free.

Se:
- free chunk_A
- free chunk_A

As mitigações vao ser ativadas... porem se:
- free chunk_A
- free chunk_B
- free chunk_A

Voce consegue linkar o chunk_A duas vezes em um fastbin (double free).

## Ataques
### Alocar um chunk

Os fastbins sao linkados numa `single-linked-list`, portanto somente usa 
o `fd`. Então, o `fd` fica na **PRIMEIRA QWORD** do parte dos dados.

- Double free
  - free chunk_A
  - free chunk_B
  - free chunk_A
> head : chunk_A -> Chunk_B -> chunk_A -> [...]
- chunk_A = malloc()
> head : Chunk_B -> chunk_A -> [...]
- chunk_B = malloc()
> head : chunk_A -> [...]
- edit(chunk_A, **ALVO**)
> head : chunk_A -> ALVO
- malloc()
> head : ALVO

> O Proximo malloc ira alocar um chunk em ALVO
- alvo = malloc()
- edit(alvo, blablabla)
> Nos temos um write arbitrário

Porem existe uma excesso, o **ALVO + 0x8** precisa ser **IGUAL AO TAMANHO DO FASTBIN**

Assim, se for o `fastbin 0x60`,  `ALVO + 0x8 == 0x60`

Para achar um chunk que se encaixa nesses critérios, voce pode usar  
`find_fake_fast` no `pwntools`

#### Obs: __malloc_hook
Normalmente o malloc_hook so pode ser corrompido por um chunk de tamanho `7f`,
assim, o seu fastbin dup tem que ser no fastbin `0x70`!

### Exec

Nos podemos, por exemplo, fazer o anterior com **ALVO = __malloc_hook**
- Double free
> head : chunk_A -> Chunk_B -> chunk_A -> [...]
- chunk_A = malloc()
- chunk_B = malloc()
- edit(chunk_A, **__malloc_hook**)
- malloc()
- alvo = malloc()
- edit(alvo, one_gadget)
- malloc() **ativar o hook**

### Escrever um valor na main_arena

O valor das `head`s fica armazenado na `main_arena`, assim invés de 
colocar um endereço em `alvo`, podemos colocar um valor:

- Double free
> head : chunk_A -> Chunk_B -> chunk_A -> [...]
- chunk_A = malloc()
- chunk_B = malloc()
> head : chunk_A -> [...]
- edit(chunk_A, **0x123**)
- malloc()
> head : 0x123

Com esse valor podemos facilitar outros tipo de exploit, por exemplo:

### Alocar um chunk na main_arena

Repetindo o anterior usando um Fastbin Dup no `0x60`:
- Double free
> head : chunk_A -> Chunk_B -> chunk_A -> [...]
- chunk_A = malloc()
- chunk_B = malloc()
> head : chunk_A -> [...]
- edit(chunk_A, **0x50**)
- malloc()
> head : 0x50

Agora usar a técnica de alocar um chunk, usando um Fastbin Dup no `0x50`:
- Double free
> head : chunk_A -> Chunk_B -> chunk_A -> [...]
- chunk_A = malloc()
- chunk_B = malloc()
- edit(chunk_A, **main_arena + 48 - 8**)
- malloc()
- fake = malloc() **Fake Chunk Na Main_Arena**

Agora temos um chunk que nos permite dar write na main_arena

> OBS :
> fastbin 0x60 dentro da main arena == main_arena + 48
>
> alvo == main_arena + 48 - 8
>
> alvo + 8 == head do 0x60 fastbin a.k.a. "0x50", passando o 
> teste ja que o nosso fake chunk tem tamanho 0x50

> OBS 2 : Esse endereço pode mudar dependendo da versão do malloc, calcula 
> de novo ai

#### Exemplo malloc antigo
Agora, por exemplo, em versões antigas podemos alterar o `top` na main_arena

- top = malloc()
- edit(top, b'G'*48 + p64(libc.sym.__malloc_hook-0x24)) 
```
              Pad    +            top
```
Agora o proximo malloc vai alocar proximo ao **__malloc_hook**

- malloc(b'H'*20 + p64(one_gadget)) **Esse chunk ocupa o __malloc_hook** 
