- [Prerrequisitos](#prerrequisitos)
- [Ataque](#ataque)
  - [Chunk falso](#chunk-falso)
    - [OBS: libc <](#obs-libc-)
  - [Free](#free)
- [Vitima adjacente ao top](#vitima-adjacente-ao-top)
- [Info leak](#info-leak)

Na House of Einherjar, nos queremos que malloc retorne um chunk 
**FORA** do heap (`.data`, etc...) usando um 
`single null byte overflow` (aka `poison null byte`) contra um 
chunk alocado. Quando somente um null byte vaza o buffer, 
comumente sendo um null byte de finalização de strings....

# Prerrequisitos 
Para isso. alem do overflow, vamos precisar de um infoleak do 
heap, e um do endereço do chunk falso. Pois nos vamos consolidar 
um chunk ate o nosso chunk falso.

Alem disso, o chunk vitima do overflow precisa ter tamanho 0x100, 
0x200, etc... Pois, caso o tamanho fosse, por exemplo 0x30, ele 
simplesmente viraria 0x00, o que nao seria muito util. Assim, o 
nosso overflow nao muda o tamanho do chunk, somente as flags:
> 0x0201 -> 0x0200 (mesmo size, sem prev_use)

Assim, quando chamarmos free no chunk vitima, por ter seu 
`prev_use=0`, ele vai tentar consolidar com o chunk de trás (obs: 
considerações adicionais sobre consolidar pra frente com o top 
chunk ao final do post). 

Assim, nos devemos alterar o `prev-size` e deixa-lo enorme, para 
que alcance o chunk falso:

```
 ____________  
|     | size | <- FAKE
|  fd |  bk  |      
|____________|
     ....

     ....

     ....

     ....
 ____________
|     | size |
| AAAAAAAAAA |
| AAAAAAAAAA |
|     ...    |
| AAAAAAAAAA |
| prev | 200 | -> prev_use desativado
|____________|

```

o `prev` deve ser igual ao offset: 
> &`vitima` - &`FAKE`

# Ataque
## Chunk falso

Alem disso, como nos vamos consolidar, precisaremos passar pelo 
SAFE unlink... Portanto, basta colocar:
>  `fd` = `bk` = &`FAKE`

Alem disso, por causo do check: `corrupted size versus prev size`, 
nos precisamos que o size do chunk falso também seja:
> &`vitima` - &`FAKE`

### OBS: libc < 
Nessas versões do libc, a implementação do 
`corrupted size versus prev size` foi mal feita:

```C
if ( __builtin_expect (chunksize(P) != prev_size (next_chunk(P)) ,0))
    malloc_printerr ("corrupted size versus prev size");
```

O prev_size usado nao é o certo, e sim calculado usando o próprio 
chunk fake

```
 _____________  
|      | size | 
|  fd  |  bk  | 
|             |
|     ...     |
|             |
| prev |      | <<<<<<<< E SIM ESSE
|_____________|
     ....

     ....

     ....

     ....
 ____________
|     | size |
| AAAAAAAAAA |
| AAAAAAAAAA |
|     ...    |
| AAAAAAAAAA |
| prev | 200 | <<<<<<<< NAO SERA ESSE
|____________|

```

Isso quer dizer que durante a criação do chunk falso, basta 
colocar um `prev_size` (do fake) igual ao `size`....

Porem existe um truque mais fácil: basta colocar `size=8`

Assim, o endereço dos dois fica igual... ja que o `prev_size` sera 
calculado com :
> &`FAKE` + `size` - `8`

Em condições normais, isso retorna o `prev_size` do proximo chunk..
Porem com `size=8`, nos temos que ele aponta para o mesmo endereço 
do `size`. Com isso, eles sao necessariamente iguais, passando o 
`corrupted size versus prev size`

Portanto, voce tem no minimo 3 maneiras diferentes de burlar o 
mecanismo de segurança :D

## Free

Com tudo isso pronto, basta chamar `free()` na vitima, que ela 
sera consolidada com o chunk falso...

Agora, basta chamar malloc que o chunk falso sera alocado, te 
dando elevado controle sobre a `.data`...

# Vitima adjacente ao top
Caso a vitima esteja do lado do top chunk, ele sera consolidado 
com ela e com o fake:

```
 _____________  
|      | size | 
|  fd  |  bk  | 
|             |
|     ...     |
|             |
| prev |      |
|_____________|
     ....

     ....

     ....

     ....
 ____________
|     | size |
| AAAAAAAAAA |
| AAAAAAAAAA |
|     ...    |
| AAAAAAAAAA |
| prev | 200 |
|     ...    |
|     ...    |
|     ...    |
|      | top |
|____________|

```
Assim, movendo o endereço do top para &`FAKE`

```
 _____________  
|      |  top | 
|_____________| 
|             |
|             |
|             |
|             |
|_____________|
     ....

     ....

     ....

     ....
 ____________
|            |
|            |
|            |
|            |
|            |
|            |
|            |
|            |
|            |
|            |
|____________|

```
Com todas as alocações seguintes vindo de la!

# Info leak

Para gerar infoleaks, ao envés de consolidar com um chunk falso, 
consolida com um chunk anterior no heap e usa as técnicas 
mostradas em:
> Google Poison Null Byte: Infoleaks 

As duas convergem nesse aspecto