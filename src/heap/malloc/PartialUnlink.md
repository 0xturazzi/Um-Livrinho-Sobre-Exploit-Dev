# Unsorted bins: Partial Unlink

Nos unsorted bins, nao é necessário fazer um unlink completo.
Quando procurando um chunk nos unsorted bins, segue o procedimento:
- Segue da Tail -> Head
- Conforme vai andando, `sort` os chunks no bins apropriados
    - `small bins` ou `large bins`
    - Quando ele vai ser transferido da `unsorted` para `small/large`, faz um **parcial unlink**
- Caso encontre um tamanho exato `exact fit`: `malloc`
    - Quando vai ser alocado, faz um **parcial unlink** 

> Obs: Isso é uma simplificação, ignorando `remainder` e outros fatores...

O processo de parcial unlink é similar ao unlink completo, porem somente o bk!

```
 head              vitima                tail  
 _V_   bk  ___       _V_       ___       _V_ 
|   | --> |   | --> |   | --> |   | --> |   |
|___| <-- |___| <-- |___| <-- |___| <-- |___|
      fd 

            vitima.fd.bk = vitima.bk
                    copiado
 head             |---------|            tail  
 _V_       ___    |   bk    V  ___       _V_ 
|   | --> |   | --> ----> --> |   | --> |   |
|___| <-- |___| <--   X   <-- |___| <-- |___|
                 fd ignorado
                     ___ 
                    |   |
                    |___| 
```
assim, nos seus UAF e semelhantes, basta somente fazer: user_data = `p64`(`0`) + `p64`(`target`)

Assim, temos um `write` em que `CONTROLAMOS O ENDEREÇO`, mas **NAO** 
controlamos o valor

O valor é o endereço da `head` do `small/large bin` de tamanho vitima.`size`

Para propósitos de exploit, isso quer dizer que estamos apontando algo
para o nosso chunk... Essa técnica sera util na House Of Orange !