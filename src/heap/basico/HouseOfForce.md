# House of Force

# Teoria
A tecnica da House Of Force consiste em usar um heap overflow para alterar o 
tamanho do top_chunk para o valor maximo ( 0xffffffffffffffff ) ... permitindo 
que um malloc enorme seja alocado pelo top_chunk!

Esse chunk enorme ira cobrir a distancia entre o alvo e o heap atual!

```py
 ______________________________
|                              |  
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |  <- malloc(0x18)
|   AAAAAAAAAAAAAAAAAAAAAAA    |  <- write("A"*0x20)
|______________________________|
|                              |  
| Top size: 0x3c0              |  <- Nao teve overflow
|______________________________|

 Agora, vamos usar o overflow para deixar o top_chunk.size gigante
 ______________________________
|                              |  
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |  <- malloc(0x18)
|   AAAAAAAAAAAAAAAAAAAAAAA    |  <- write("A"*0x20 + p64(0xffffffffffffffff))
|______________________________|
|                              |  
| Top size: 0xffffffffffffffff |
|______________________________|

Agora, vamos alocar um chunk gigante!

Vamos supor que o heap comeca em 0x40000 e o alvo esta em 0x60704

Alem disso, vamos supor que o top_size esta no endereco 0x400d0

Assim, queremos alocar um chunk que pare um pouco antes do alvo, 
esse chunk servira somente para "andar ate la"

Assim, quando alocarmos um chunk, ele vai ocupar a mesma posicao que o alvo

>>> hex((0x60704 - 0x20) - 0x400d0)
'0x20614'
 ______________________________  ___ 0x40000
|                              | 
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |
|   AAAAAAAAAAAAAAAAAAAAAAA    |
|______________________________| ___ 0x400d0 -> top_size ficava aqui
|                              |
|     NAO ESCREVER NESSE       |  <- malloc(0x20614)
|     CHUNK, ELE PODE ESTAR    |  
|     PASSANDO POR MEMORIA     |
|  READ_ONLY E CAUSAR SEGFAULT |
|                              |  
 ... ...  ... ... ...  ...  ...
|______________________________| ___ 0x606e4 -> alvo - 0x20
|                              |  
| Top size: 0xfffffffffffdf9eb |
|______________________________|

Agora, um ultimo chunk para cobrir alvo

 ______________________________  ___ 0x40000
|                              | 
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |
|   AAAAAAAAAAAAAAAAAAAAAAA    |
|______________________________| ___ 0x400d0 -> top_size ficava aqui
|                              |
|     NAO ESCREVER NESSE       |
|     CHUNK, ELE PODE ESTAR    |  
|     PASSANDO POR MEMORIA     |
|  READ_ONLY E CAUSAR SEGFAULT |
|                              |  
 ... ...  ... ... ...  ...  ...
|______________________________| ___ 0x606e4
|             | Size: 0x30     |  
|                              | <- malloc(0x28) 
|                              |  
|                              | ___ 0x60704 -> alvo
|                              |  
|______________________________| ___ 0x60714 
|                              |  
| Top size: 0xfffffffffffdf9cb |
|______________________________|

Um edit no chunk pode alterar o alvo!

def Resumo():
    Chunk_1 -> top size = 0xfff...
    Chunk_2 -> gigante, usado para atravessar a distancia
    Chunk_3 -> Pode alterar o alvo


Na pratica, o Chunk_3 talvez tenha um tamanho que 
voce nao controle! Ou, alguma outra limitacao assim!

A situacao ideal ocorre quando o inicio da user_data do Chunk_3 
coincide com o endereco do alvo! pois voce nao precisa usar 
padding para alcancar o alvo e portanto, nao arrisca 
danificar outras partes da memoria!

Entao quando estiver praticando, vale a pena ficar brincando com o tamanho do 
Chunk_2 para acertar a mira direitinho :D
```

# VA Wrap-Around

No caso anterior, o endereco do alvo era maior que o do heap!

heap: 0x40000 <------> alvo: 0x60704 

E caso seja ao contrario? Vamos precisar dar uma volta no VA space!

> VA = Virtual Address = Endereco Virtual = 0x0000000000000000 ate 0xffffffffffffffff

Os enderecos no VA space dao um loop, assim:
> Se voce esta em 0xffffffffffffff45 e anda para frente, voce vai terminar em 0x0000000000000000a3 ! Dando uma volta no VA space! 

Nos podemos fazer o mesmo com o `Chunk_2` ! Permitindo que o `Chunk_3` fique 
em um endereco anterior ao heap! :D

Para encontrar o tamanho do `Chunk_2` que possibilite isso, podemos usar a funcao:

```py
def wrap(A,B):
    return (0xffffffffffffffff - A)+B
    #      || tamanho ate        || O quanto andar depois
    #      || O fim do VA space  || de dar o loop 
    
    # Com A = base_do_heap + quantidade_gasta = top_size
    # B = alvo - 0x20 (tamanho do Chunk_3)  
```

# Limitacoes
- Requer um heap leak
- Versao Glibc < 2.29

# Fontes e Materiais para praticar
- [shellphish/how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c)
- La tambem tem o link pra alguns ctfs que usam house of force!
- [O curso de Heap Exploits do Max Kamperi](https://www.udemy.com/share/1039QMBEYadFpWRXo=/) 