- [Resumo](#resumo)
- [Perspectiva de Atacante](#perspectiva-de-atacante)
  - [RELRO Parcial](#relro-parcial)
  - [RELRO Full](#relro-full)
- [Analise A Fundo PLT e ld.so ~TODO~](#analise-a-fundo-plt-e-ldso-todo)

# Resumo
- A GOT armazena o endereço da funcao apos ser resolvido!
  
- Quando nos chamamos uma funcao do libc, nao estamos chamando elas  diretamente, e sim a sua entrada na PLT.

- A PLT checa a GOT, caso o endereço ja tenha sido resolvido, `jmp` la

- Caso a funcao **NAO** tenha sido chamada e consequentemente o endereço ainda 
nao tenha sido resolvido, coordena com `ld.so` para resolver!

```x86asm
pwndbg> disassemble vuln
        push   rbp
        mov    rbp,rsp
        sub    rsp,0x20
break > lea    rdi,[rip+0xec3]

        call   0x401030 <puts@plt>

break > lea    rax,[rbp-0x20]
        mov    rdi,rax
        mov    eax,0x0
        call   0x401040 <gets@plt>
        nop
        leave  
        ret

pwndbg> b vuln
pwndbg> b *vuln+20

-------------------------------------
- Antes de puts ter sido executada  -
-------------------------------------

pwndbg> got

GOT protection: Partial RELRO | GOT functions: 2
 
[0x404018] puts@GLIBC_2.2.5 -> 0x401036 (puts@plt+6) ◂— push   0 /* 'h' */
[0x404020] gets@GLIBC_2.2.5 -> 0x401046 (gets@plt+6) ◂— push   1

pwndbg> disassemble 0x401036
    jmp    QWORD PTR [rip+0x2fe2]        # 0x404018 <puts@got.plt>
    push   0x0
    jmp    0x401020


-------------------------------------
- Depois de puts ter sido executada -
-------------------------------------

pwndbg> got

GOT protection: Partial RELRO | GOT functions: 2
 
[0x404018] puts@GLIBC_2.2.5 -> 0x7ffff7e655f0 (puts) ◂— push   r14
[0x404020] gets@GLIBC_2.2.5 -> 0x401046 (gets@plt+6) ◂— push   1

```

# Perspectiva de Atacante
## RELRO Parcial

Caso o RELRO seja parcial, nos podemos alterar o valor na got, fazendo uma call 
ser redirecionada para, por exemplo, um shellcode!

Esse tipo de cenário pode ser encontrado em vulnerabilidades 
`escrever-n-bytes---em-algum-lugar` !

Alem disso podemos ler ela e obter um leak, descrito no proximo exemplo!

## RELRO Full

Com RELRO Full, nos podemos somente ler a GOT (que ja vem com valores 
pre-resolvidos).

Porem isso se mostra util pois, podemos mandar esse endereco de volta 
( por meio de um `puts` por exemplo ) e usar esse leak para desativar ASLR!

Ou podemos calcular a distancia dentro do libc entre a `funcao do leak` e 
`system`. 

Em seguida ajustar esse valor (`pop rbp; add rax, rbp`, com `rax = leak`) e chama-lo: `call rax`, novamente burlando ASLR! :D

# Analise A Fundo PLT e ld.so ~TODO~