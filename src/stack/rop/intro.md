# Intro ROP

- [Intro ROP](#intro-rop)
- [Teoria](#teoria)
  - [Ret](#ret)
  - [Gadgets](#gadgets)
  - [Chains](#chains)
- [Ferramentas](#ferramentas)
- [Curiosidades](#curiosidades)

ROP (programação orientada ao retorno) foi um técnica desenvolvida 
para burlar todas as limitações e mecanismos de segurança 
impostos no `RIP`!

Vamos considerar que todas mitigações exceto `PIE` estão ativas!

# Teoria

## Ret
O que faz o `RIP` ser especial? Em um nível abstrato, quais sao 
suas propriedades genéricas que o dao sua funcionalidade??

- [1] ~ O RIP aponta para um endereço na memoria
- [2] ~ Em seguida, ele age com base no valor presente
- [3] ~ Ele automaticamente avança (aumenta seu endereço)
- [4] ~ jmp [1]

Existe algum outro que possa operar dessa maneira? Sim! o `RSP`! 

Quando o processador executa `RET`, o endereço no topo da stack 
(aonde `RSP` aponta) sera colocado no `RIP` e o `RSP` se ajusta: 
`RSP += 8`! :D

## Gadgets

Um gadget consiste em uma sequencia de instruções, seguidas de um 
`RET`. Por exemplo:

```x86asm
gadget_1:
    mov rax rbx
    mov r12 r13
    ret

gadget_2:
    pop rdi
    pop rbp
    ret

```
Vamos supor que apos um BoF, o `RIP` salvo esta num offset de 40.

```py
payload = b"A" * 40
payload += gadget_1
payload += b"B" * 8
```
Quando a função vulnerável retornar, o valor no topo da stack sera 
`&gadget_1`

```x86asm
vulnerável:             stack:
    ...                 AAAAAAAA
    leave               ...
    ret     <- RIP      AAAAAAAA
                        gadget_1 <- RSP
                        BBBBBBBB


A execução sera redirecionada, e o RSP ira avançar


gadget_1:               stack:
    mov rax rbx <- RIP  AAAAAAAA
    mov r12 r13         ...
    ret                 AAAAAAAA
                        gadget_1
                        BBBBBBBB <- RSP

As duas instruções serão executadas!

gadget_1:               stack:
    mov rax rbx         AAAAAAAA
    mov r12 r13         ...
    ret     <- RIP      AAAAAAAA
                        gadget_1
                        BBBBBBBB <- RSP

E agora, a funcao retornara para BBBBBBBB, um endereço invalido, gerando uma SEGFAULT
```
E caso a instrução seja um  `POP`? o `RSP` andaria? Sim, e precisamos levar 
isso em consideração
```py
payload = b"A" * 40
payload += gadget_2
payload += b"T" * 8 # RDI
payload += b"Y" * 8 # RBP
payload += b"B" * 8 # RET
```
E vamos supor que os registers sao inicializados com `OOOOOOOO`
```x86asm
vulnerável:             stack:              
    ...                 AAAAAAAA
    leave               ...
    ret     <- RIP      AAAAAAAA
                        gadget_2 <- RSP
                        TTTTTTTT
                        YYYYYYYY
                        BBBBBBBB


A execução sera redirecionada, e o RSP ira avançar !
Ate aqui foi igual ao anterior!

gadget_2:               stack:              registers:
    pop rdi <- RIP      AAAAAAAA                RDI = OOOOOOOO    
    pop rbp             ...                     RBP = OOOOOOOO
    ret                 AAAAAAAA
                        gadget_2
                        TTTTTTTT <- RSP
                        YYYYYYYY 
                        BBBBBBBB

pop rdi sera executado, salvando o valor no topo da stack em RDI e avançando RSP

gadget_2:               stack:              registers:
    pop rdi             AAAAAAAA                RDI = TTTTTTTT    
    pop rbp <- RIP      ...                     RBP = OOOOOOOO
    ret                 AAAAAAAA
                        gadget_2
                        TTTTTTTT 
                        YYYYYYYY <- RSP
                        BBBBBBBB


pop rbp sera executado, salvando o valor no topo da stack em RBP e avançando RSP

gadget_2:               stack:              registers:
    pop rdi             AAAAAAAA                RDI = TTTTTTTT    
    pop rbp             ...                     RBP = YYYYYYYY
    ret     <- RIP      AAAAAAAA
                        gadget_2
                        TTTTTTTT 
                        YYYYYYYY
                        BBBBBBBB <- RSP

E agora, a funcao retornara para BBBBBBBB, um endereço invalido, gerando uma SEGFAULT
```
## Chains

E se, ao invés de retornarmos para `BBBBBBBB`, retornássemos para outro gadget? 

Seria tipo uma corrente: 

___com um gadget executando e redirecionando para o proximo....

___com um gadget executando e redirecionando para o proximo....

___com um gadget executando e redirecionando para o proximo....

___com um gadget executando e redirecionando para o proximo....

Assim, poderíamos devagarinho reconstruir o nosso shellcode, a partir de partes 
pre-existentes do código!

E como `PIE` esta desativado, a secao de código do binário NAO tem seu 
endereço randomizado!

> OBS: Voce nao pode usar a secao de código do libc como gadgets, pois ele tem 
> o endereço randomizado (ASLR)

```x86asm
gadget_1:
    mov rax rbx
    mov r12 r13
    ret

gadget_2:
    pop rdi
    pop rbp
    ret
```
```py
payload = b"A" * 40
payload += gadget_1
payload += gadget_2 
payload += b"T" * 8 # RDI
payload += b"Y" * 8 # RBP
payload += gadget_1
payload += gadget_1
payload += gadget_1
payload += gadget_2 
payload += b"T" * 8 # RDI
payload += b"Y" * 8 # RBP
payload += gadget_1
payload += b"B" * 8 # SEGFAULT
```

Essa chain em especifico nao faz nada de util, somente demonstrar como chains 
podem ser construidas!

Numa situação real nao teríamos uma `SEGFAULT` no final, pois ja teríamos uma 
shell antes de chegar a esse ponto!

# Ferramentas

Existem múltiplas ferramentas capazes de encontrar gadgets e ate gerar chains 
automaticamente!

Eu recomendo voce testar e ver o que prefere!

- [ropium](https://github.com/Boyan-MILANOV/ropium)
- [ropper](https://github.com/sashs/Ropper)
- [ropGadget](https://github.com/JonathanSalwan/ROPgadget)
- [O submodulo do pwntools](https://docs.pwntools.com/en/latest/rop.html)

---
E enquanto eu pegava os links no github..
eu encontrei esse em rust:
[ropr](https://github.com/Ben-Lichtman/ropr/tree/master/src)

Que parece ser bem interessante, mas ainda vou testar!

---
Todas as ferramentas possuem funcionalidade de filtrar gadgets com badchars, 
automaticamente gerar chains...

Eu pessoalmente gosto de ropper e do pwntools (pq ter tudo dentro do mesmo 
framework == incrível)

# Curiosidades

Em arquiteturas `RISC`, todas as instruções tem o mesmo tamanho (em bytes)...

Porem em `x86` (`CISC`), as instruções podem desde 2 bytes, ate 5/6/7 bytes!

Assim, as ferramentas que encontram gadgets podem criar instruções que 
originalmente nao existiam no programa!

```
Exemplo (fictício, pq eu to com preguiça ler o manual e ver os bytecodes)

O programa originalmente ve:

12 34   56 78 91    12 34  90
|       |           |      |
Add     Pop         Add    NOP

Porem, a ferramenta pode escolher um offset com alinhamento diferente do anterior:

12      34 56 78    91 12   34 90
|       |           |       |
AND     Sub         Push    XOR

Mesmos bytes, instruções diferentes

```