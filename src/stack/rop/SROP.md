# SROP

```x86asm
   0x00000000000012a7 <+0>:	endbr64 
   0x00000000000012ab <+4>:	push   rbp
   0x00000000000012ac <+5>:	mov    rbp,rsp
   0x00000000000012af <+8>:	mov    eax,DWORD PTR [rip+0x2d63]        # 0x4018 <alloc_size>
   0x00000000000012b5 <+14>:	movsxd rcx,eax
   0x00000000000012b8 <+17>:	mov    rax,QWORD PTR [rip+0x2d61]        # 0x4020 <memory>
   0x00000000000012bf <+24>:	mov    edx,0x2
   0x00000000000012c4 <+29>:	mov    rsi,rcx
   0x00000000000012c7 <+32>:	mov    rdi,rax
   0x00000000000012ca <+35>:	call   0x1150 <mprotect@plt>
   0x00000000000012cf <+40>:	nop
   0x00000000000012d0 <+41>:	pop    rbp
   0x00000000000012d1 <+42>:	ret  

edx = flags
rsi (from rcx) = page size
rdi (from rax) = addr

Breakpoint 4, 0x00005555555552ca in foo ()
edx            0x2                 2
rsi            0x1000              4096
rcx            0x1000              4096
rdi            0x7ffff7fc7000      140737353904128
rax            0x7ffff7fc7000      140737353904128

```

```x86asm
   0x00005555555552a7 <+0>:	endbr64 
   0x00005555555552ab <+4>:	push   rbp
   0x00005555555552ac <+5>:	mov    rbp,rsp
=> 0x00005555555552af <+8>:	mov    eax,DWORD PTR [rip+0x2d63]        # 0x555555558018 <alloc_size>
   0x00005555555552b5 <+14>:	movsxd rcx,eax
   0x00005555555552b8 <+17>:	mov    rax,QWORD PTR [rip+0x2d61]        # 0x555555558020 <memory>
   0x00005555555552bf <+24>:	mov    edx,0x2
   0x00005555555552c4 <+29>:	mov    rsi,rcx
   0x00005555555552c7 <+32>:	mov    rdi,rax
   0x00005555555552ca <+35>:	call   0x555555555150 <mprotect@plt>
   0x00005555555552cf <+40>:	nop
   0x00005555555552d0 <+41>:	pop    rbp
   0x00005555555552d1 <+42>:	ret  
```

```
'--> cat gdbs
set disassembly-flavor intel
disassemble foo

b *0x00005555555552b5
b *0x00005555555552b8
b *0x00005555555552bf
b *0x00005555555552ca

r
info registers $eax
c
info registers $eax $rcx
c
info registers $rax
c
info registers $edx $rsi $rcx $rdi $rax
```

```C
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

static int alloc_size;
static char* memory;

// gcc c.c -o c

void segv_handler (int signal_number) 
{
 printf ("memory accessed!\n");
 mprotect (memory, alloc_size, PROT_READ | PROT_WRITE);
} 

void foo() {
 mprotect (memory, alloc_size, 2);
}

int main ()
{
 int fd;
 struct sigaction sa;

 /* Install segv_handler as the handler for SIGSEGV. */
 memset (&sa, 0, sizeof (sa));
 sa.sa_handler = &segv_handler;
 sigaction (SIGSEGV, &sa, NULL);
 
 /* Allocate one page of memory by mapping /dev/zero. Map the memory
   as write-only, initially. */
 alloc_size = getpagesize ();
 fd = open ("/dev/zero", O_RDONLY);
 memory = mmap (NULL, alloc_size, PROT_WRITE, MAP_PRIVATE, fd, 0);
 close (fd);

 /* Write to the page to obtain a private copy. */
 memory[0] = 0;
 
 foo();
 /* Write to the allocated memory region. */
 memory[0] = 1;

 /* All done; unmap the memory. */
 printf ("all done\n");
 munmap (memory, alloc_size);
 return 0;
}
```
