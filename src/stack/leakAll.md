
Isso e uma tradução / resumo desse post [nickgregory: pivoting-around-memory](https://www.nickgregory.me/security/2019/04/06/pivoting-around-memory/)

Todos os créditos vao para o autor original! :D

# Intro
Existem 4 regiões importantes quando exploitando um programa:
- O binário
- Stack
- LibC
- Heap

Em resumo:
![Imagem representando rotas entre as partes](./src/stack/mem_region_pivoting.png)
![Imagem representando rotas entre as partes](https://raw.githubusercontent.com/0xturazzi/Um-Livrinho-Sobre-Exploit-Dev/main/src/stack/mem_region_pivoting.png)

- [Intro](#intro)
- [Bin -> LibC : GOT](#bin---libc--got)
- [LibC <-> Heap : main_arena pointers](#libc---heap--main_arena-pointers)
- [Stack -> Bin e/ou LibC : Ler ret salvo](#stack---bin-eou-libc--ler-ret-salvo)
- [LibC -> Stack : __libc_argv ou environ](#libc---stack--__libc_argv-ou-environ)
- [LibC -> ld -> Bin](#libc---ld---bin)

# Bin -> LibC : GOT
Se `PIE == False` ou se voce tem um leak da base do programa, 
basta ler a GOT.

# LibC <-> Heap : main_arena pointers
Se voce tem um read arbitrário ou read-after-free, voce pode 
conseguir o endereço do libc se a arena for a main ... 
normalmente como o `next` pointer nas `freelists`

Seguindo o outro sentido, se voce consegue ler no libc, basta 
ler `main_arena` para conseguir um pointer para o heap

# Stack -> Bin e/ou LibC : Ler ret salvo
Ler o valor do ret salvo pode te dar um pointer para uma função 
do `bin` (derrotando `PIE`) ou para uma do `LibC` (ou de outra lib... o que pode ser util para a exploit chain)

# LibC -> Stack : __libc_argv ou environ
Se voce tem um read no `LibC`, voce pode ler os símbolos: 
`__libc_argv` ou ` environ`. Eles apontam para valores bem altos 
na stack, e muitas vezes existe uma diferença **ALEATORIA** 
(`ASLR`) entre eles e o `RSP`.

De qualquer maneira, voce tem um leak de um pointer na stack, e 
pode iterar ate encontrar o ret salvo que aponta para 
`__libc_start_main`, para encontrar a parte importante da stack. 

# LibC -> ld -> Bin
Nessa tecnica e nescessario passar por um nivel de abstracao, dado 
que o `LibC` nao tem pointers para `Bin` ! Assim:

**LibC -> ld**

O Linker Dinamico (`ld`) sempre esta na memoria e `LibC` sempre 
contem pointers para ele: `GOT do libc -> _dl_runtime_resolve`

E na maior parte dos casos, `ld` esta em um offset constante em 
relação ao `LibC` pois:
- `mmap` usa valores alinhados a `PAGE_SIZE`
- Normalmente, `LibC` e `ld` costumam ser as 2 primeiras libs a 
serem carregadas e portanto "`mmap`adas"

**ld -> Bin**

O valor `name` dentro do struct `_dl_rtld_libname` aponta para 
`.interp`, mais especificamente para uma string com o `path` do 
linker, assim, calculando o offset dela dentro de `.interp` e 
consequentemente leakando a base do `Bin` .