- [DEP | NX | W^X](#dep--nx--wx)
- [System ASLR](#system-aslr)
- [PIE](#pie)
- [RELRO](#relro)
	- [Parcial](#parcial)
	- [Full](#full)
	- [Fontes e Recursos Adicionais](#fontes-e-recursos-adicionais)
- [Canaries](#canaries)
- [Outras](#outras)
	- [Linux](#linux)
		- [Pointer Guard](#pointer-guard)
	- [Windows](#windows)

# DEP | NX | W^X

Todas essas pretendem impedir a execução de código em 
partes da memoria que sejam "escreviveis".

Impedir que x atacante execute o código escrito 
pelx mesmx, previne que Shellcodes sejam usados! :D

Assim, ou uma parte da memoria ou pode ser escrita, ou 
executável, mas nunca as duas simultaneamente: 
**W**rite **XOR(^)** e**X**ecute

Você vai ouvir pessoas usando os 3 nomes para representar 
esse conceito, e dependendo do contexto não tem problema!

Porem eles são tecnicamente diferentes:

**DEP** (**P**revencao da **E**xecucao de **D**ados): 
a implementação do **Windows**

**N**ao e**X**ecute: um bit que pode ser colocado para 
garantir a exclusão mutua em processadores **AMD**.

Intel tem um outro nome, que eu não lembro... 
e não importa o suficiente para eu pesquisar! :P

> Atualmente, a exclusão mutua de escrever e executar 
ocorre por meio de paging: o sistema operacional decide 
as permissões das paginas de memorias, e garante que uma 
não viole W^X . **No momento que você esta lendo, isso 
pode ter mudado!**

# System ASLR

ASLR randomiza os endereços das coisas na memoria! Porem 
com as suas limitações, dado que depende doo sistema 
operacional!

Cada OS implementa de um jeito, mas em geral se randomiza:

- Imports dinamicos (LIBC,...)
- Segmentos do executável (Data, ROData, ...)
- Stack e Heap

**Porem, o endereço do código não muda!**

# PIE

Para garantir que o código também tenha sua posição 
randomizada, o binário precisa ser compilado com PIE !

PIE (**E**xecucao **I**ndependente da **P**osição) impede 
que o codigo possa ser executado independente da sua  
posição na memoria (duh :P)

Para garantir isso, todos endereços precisam ser relativos ao invés de absolutos!

```
			Endereço	Instrução
Sem PIE     0x0001	jmp 0x0003 <- EIP	
			0x0002	add 1 2
			0x0003	add 1 3

Com PIE     ------	jmp EIP+2  <- EIP
			------	add 1 2
			------	add 1 3
```

No primeiro caso, se o executável mudar de endereço 
o `JMP` pularia para a instrução errada, por causa do 
endereço absoluto.

# RELRO

Realocacoes Read-only: Dividido em 2 tipos: Parcial e Full

Atualmente, somente o RELRO Parcial vem como padrao no gcc

- PARCIAL: `gcc -Wl,-z,relro` ou nenhuma flag, em versoes modernas
- FULL: `gcc -Wl,-z,relro,-z,now`

## Parcial
- As `sections` de dados do ELF (`got`,`dtors`,`ctors`) precedem as do programa 
(`data`,`bss`). Assim, caso tenha um BoF no programa a estrutura do ELF fica 
intacta. 


## Full
- Tudo do parcial
- Re-Mapeia a GOT como `r--`, impedindo que a usemos para ganhar execucao.

Porem para fazer isso torna-se nescessario pre-resolver todas as calls 
dinamicas. Assim. desativando `RTLD_LAZY` e consequentemente tornando a 
inicializacao mais lenta.

Da nossa perspectiva, ficamos com opcoes reduzidas para execucao de codigo, 
tendo de usar tecnicas como corromper os `malloc hooks` ou o `vtable` pointer 
do `stdio`. (mais sobre esses no futuro!)

## Fontes e Recursos Adicionais
- [trapkit: RELRO A (not so well known) Exploit Mitigation Technique](https://www.trapkit.de/articles/relro/)
- [Self Protecting GOT](https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/em386/Self-Protecting-GOT.html)

--- 
TODO

--- 

# Canaries

# Outras

## Linux 
### Pointer Guard
## Windows