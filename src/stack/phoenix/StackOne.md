- [ðŸŽ¯ Objetivo](#-objetivo)
- [ðŸ’¡ Dicas](#-dicas)
- [ðŸ’« ExplicaÃ§Ã£o](#-explicaÃ§Ã£o)
  - [Input](#input)
  - [Endian](#endian)
    - [ðŸŒ™ Dica: Usando valores hex diretamente](#-dica-usando-valores-hex-diretamente)
- [ðŸ”¥ SoluÃ§Ã£o](#-soluÃ§Ã£o)

# ðŸŽ¯ Objetivo
Agora o objetivo nÃ£o Ã© sÃ³ alterar `changeme`, Ã© alterar para um valor especifico!

Lembra aquilo de controlar o valor depois do preenchimento (`padding`) ?

Pois Ã©, ele vai ser super util agora!

# ðŸ’¡ Dicas
Ver a representaÃ§Ã£o hex de cada letra:
> $ man ascii

Dar um Google sobre Endianess.

# ðŸ’« ExplicaÃ§Ã£o
Se lembra de que no tutorial passado a gente trocou `changeme` pra **41** e **42**?

O que ta acontecendo por trÃ¡s das cenas Ã© que as letras estÃ£o virando a sua representaÃ§Ã£o hex.

EntÃ£o `print("A"*5)` Ã© equivalente Ã  `print(b"\x41"*5)`
> Presta atenÃ§Ã£o no b"" : esse b indica que sÃ£o Bytes! :D

As vezes o python3 vai reclamar de vocÃª usar valores arbitrÃ¡rios pra esses bytes,
entÃ£o vocÃª pode usar o python2 (o print nÃ£o tem parÃªnteses, mas o resto Ã© igual):
> $ python -c "print 'blablabla'"

Nesse caso, changeme ta sendo comparada com **0x496c5962**
```C
  if (locals.changeme == 0x496c5962) {
    puts("Well done, you have successfully set changeme 
				to the correct value");
```
O buffer tem tamanho 64 de novo, entÃ£o podemos usar 64 caracteres para preenche-lo, igual na anterior! uhuuuu :D

## Input
Nesse caso, o programa nÃ£o ta usando o gets pra abrir um input.

Ele ta usando o `argv` (o que vem depois do nome do programa quando
vocÃª executa no terminal)
> ./stack-one teste batata
```
argv[0] = stack-one (o nome do programa)
argv[1] = teste
argv[2] = batata
... e assim por diante
```
> argc Ã© a contagem: quantas coisas tem no argv! E aqui tÃ¡ checando se Ã© menor que 2!

entÃ£o no nosso caso, para mandar o input do python para o argv vai funcionar assim:
> $ ./stack-one $(python -c "print b'A' * 64")
o `$()` executa o comando dentro dos parÃªnteses e usa o valor retornado como input do outro!

entÃ£o `$(python....)` vai executar, e em seguida:
> ./stack-one AAAAAAAAAAAAAA...

## Endian
O valor de changeme tem tamanho 4 bytes, pq ele Ã© um integer (integers sÃ£o 32 ou 64 bits, entÃ£o 4 ou 8 bytes). Isso quer dizer que a gente pode colocar 4 letras :D
```
./stack-one $(python -c "print b'A' * 64 + 'BCDE'")
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x45444342, we want 0x496c5962
```
O programa nos diz o valor de `changeme`, que nos alteramos por ter __overflow-ado__ o buffer

Ue, que esquisito, vc reparou algo de estranho?

A gente mandou `BCDE (42 43 44 45)` e ele colocou `EDCB (45 44 43 42)`, por que isso?

Os computadores armazenam integers usando um sistema Little Endian (LE) ou Big Endian (BE), esses sistemas decidem como os nÃºmeros sÃ£o representados.
> Esses sistemas se referem a magnitude dos dÃ­gitos, Centena, Dezena, Unidade,...

> Em um sistema BE, os numeros sÃ£o representados em ordem decrescente CDU.

> Em um sistema LE, os numeros sÃ£o representados em ordem crescente UDC.
```
Por exemplo, o numero cento e vinte trÃªs:
BE: 123        
LE: 321
```
No dia a dia, nos humanos usamos o sistema BE, mas os computadores preferem LE, entÃ£o eles invertem a ordem dos 4 bytes nos numeros inteiros!

EntÃ£o pra gente conseguir que changeme seja `BCDE`, a gente precisa passar `EDCB` pro computador! :D
```
$ ./stack-one $(python -c "print b'A' * 64 + 'EDCB'")
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x42434445, we want 0x496c5962
```
Isso quer dizer que pra gente definir `changeme = 49 6c 59 62`, e completar
 o desafio, a gente precisa inverter a ordem dos bytes (`62 59 6c 49`)! :D

Mas eu nÃ£o sei que letras sÃ£o equivalentes a esses numeros... e nem todo numero tem uma letra!


### ðŸŒ™ Dica: Usando valores hex diretamente 
Lembra que eu falei que letras sÃ£o valores hex? A gente tambÃ©m pode usar os valores hex diretamente usando \x  :D
> EntÃ£o usar b"\x41" Ã© igual a b"A"!

```
$ ./stack-one $(python -c "print b'A' * 64 + b'\x62\x59\x6c\x49'")
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
```
Yay vitoria! 

Caso vocÃª queira usar as letras, voce pode tambÃ©m!

EntÃ£o `b'\x62\x59\x6c\x49'` Ã© equivalente a `b'bYlI'`
```
$ ./stack-one $(python -c "print b'A' * 64 + b'bYlI'")
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
```
Mas e nos casos que o byte nÃ£o tem um correspondente vÃ¡lido? Vc usa `"\x"` :D

Na verdade, Ã© mais prÃ¡tico usar `\x` 99% das vezes, entÃ£o vale a pena criar o habito!

# ðŸ”¥ SoluÃ§Ã£o
> ./stack-one $(python -c "print b'A' * 64 + b'bYlI'")

