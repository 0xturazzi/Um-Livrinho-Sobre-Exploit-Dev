# ðŸŽ¯ Objetivo
Similar Ã  anterior, a gente precisa mudar o valor da variÃ¡vel changeme,
mas dessa vez ao invÃ©s de usar o input ou argv, vamos usar env!

# ðŸ’« ExplicaÃ§Ã£o
Nesse desafio, o programa usa getenv("ExploitEducation") para ler uma
environment variable. 
## ðŸŒ³ Environment Variable (VariÃ¡vel do ambiente)
Essas variÃ¡veis sÃ£o acessÃ­veis para todos os programas
executando naquela seÃ§Ã£o. E normalmente contem preferÃªncias como cores, o tipo de terminal, etcetc....

VocÃª pode checa-las usando
> $ env

VocÃª pode definir uma atÃ© o resto da seÃ§Ã£o
> $ export Nome=Valor

VocÃª pode definir uma somente para execuÃ§Ã£o daquele programa
> $ Nome=Valor ./stack-two

Para nÃ³s, nÃ£o faz tanta diferenÃ§a se o input Ã© pelas `envs` ou por outro mÃ©todo.

O Ãºnico problema Ã© que nÃ£o podemos usar o Null Byte (0x00), pois ele Ã© usado para indicar o final de uma string ASCII, portanto terminando nossa variÃ¡vel precocemente.

## Overflow
Em seguida, o valor Ã© copiado para um `buffer[64]` usando: `strcpy(buffer, ptr)`. Com `ptr` sendo o valor da `env` 'ExploitEducation'.

A funÃ§Ã£o `strcpy`, assim como `gets`, nÃ£o checa se o valor Ã© maior que o buffer, tornando o programa vulnerÃ¡vel... :(

Por ultimo, o programa checa se `changeme == 0x0d0a090a`
> Levando em consideraÃ§Ã£o que o sistema Ã© LE: 0a 09 0a 0d

Mas pera ai, checando o manual ASCII, esses caracteres sÃ£o usados para encerrar linha, nÃ£o Ã© uma letra do teclado! D:

Pois Ã©, entÃ£o vamos precisar usar os bytes diretamente.
```
Se vocÃª quer tentar resolver sozinhe, agora Ã© a sua hora!

.
.
.
.
.
.
.
.
.
.
.
.
.
```
Eu precisei colocar em caixinhas diferentes para caber na tela :(

> $ ExploitEducation=$(python -c "print b'A'*64 + b'\x0a\x09\x0a\x0d'") ./stack-two 
```
Welcome to phoenix/stack-two, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
```
Uhuuu, esse foi mais fÃ¡cil :D

# ðŸ”¥ SoluÃ§Ã£o
> $ ExploitEducation=$(python -c "print b'A'*64 + b'\x0a\x09\x0a\x0d'") ./stack-two
