- [üìù Descri√ß√£o](#-descri√ß√£o)
- [üí° Dica](#-dica)
- [Conhecimento Preliminar](#conhecimento-preliminar)
  - [Buffer](#buffer)
  - [Stack](#stack)
    - [A stack cresce para valores menores](#a-stack-cresce-para-valores-menores)
    - [Hex](#hex)
    - [Melhorando o exemplo do po√ßo](#melhorando-o-exemplo-do-po√ßo)
- [üéâ Explica√ß√£o](#-explica√ß√£o)
  - [ü•û 1- Alocando as vari√°veis na stack (buffer[64], changeme)](#-1--alocando-as-vari√°veis-na-stack-buffer64-changeme)
  - [üí• 2- Alterar buffer[64] usando gets](#-2--alterar-buffer64-usando-gets)
  - [‚úÖ 3- O programa checa se changeme foi alterada](#-3--o-programa-checa-se-changeme-foi-alterada)
    - [‚ùå 64 As, changeme n√£o alterado](#-64-as-changeme-n√£o-alterado)
    - [‚úÖ 65 As, changeme alterado](#-65-as-changeme-alterado)
    - [üÖ±Ô∏è 64 As e um B (0x42): AAAAAAAAA.....AAAB](#Ô∏è-64-as-e-um-b-0x42-aaaaaaaaaaaab)
- [üëæ Solu√ß√£o](#-solu√ß√£o)

# üìù Descri√ß√£o
Esse n√≠vel demonstra que memoria pode ser acessada fora da sua regi√£o 
inicialmente alocada, como as vari√°veis s√£o alocadas na stack, e que altera-las pode mudar a execu√ß√£o do programa.

Objetivo: Alterar a vari√°vel "changeme"

# üí° Dica
```bash
$ python3 -c "print('A' * 10)"
AAAAAAAAAA

$ python3 -c "print('A' * 10)" | ./stack-zero 
```
# Conhecimento Preliminar

## Buffer
Buffers s√£o similares a arrays em outras linguagens de programa√ß√£o,
mas possuem tamanho fixo!

Eles s√£o definidos usando: `tipo nome[tamanho]` 

O `tipo`, √© do que esta sendo armazenado dentro, por exemplo:
```C
char buf[64]; // Armazena 64 caracteres
int buf[32];  // Armazena 32 ints
```
Esses buffers por possu√≠rem tamanho fixo, s√£o armazenados na stack!

## Stack
A stack √© uma por√ß√£o da memoria que armazena como se fosse uma pilha de pratos:
```
Quando voc√™ quer colocar um novo, voc√™ coloca no topo da pilha (push)
Quando voc√™ quer pegar um da pilha, voc√™ pega o do topo (pop)

O ultimo a entrar, √© o primeiro a sair...
o nome desse comportamento √© LIFO (Last in First Out)
```
![Imagem da wikipedia mostrando PUSH e POP](./img/push-pop.png)

### A stack cresce para valores menores
```
Imagina que ela √© um po√ßo que come√ßa na profundidade 15

Quando voc√™ coloca um objeto de tamanho 2 no po√ßo:
ele vai estar apoiado na profundidade 15, e vai at√© a profundidade 13

Em seguida, voc√™ coloca algo de tamanho 3:
vai estar apoiado na profundidade 13, e vai at√© a profundidade 10
```
Conforme voc√™ vai **adicionando** itens, o endere√ßo que eles est√£o vai **diminuindo** em valor.
√â meio confuso, mas com o tempo voc√™ pega o jeito.

Pra complicar um pouco mais, esses endere√ßos t√£o em hexadecimal (0x0 ate 0xF, o "0x" √© pra representar que o valor t√° em hex).

### Hex
Se vc n√£o souber hex: [Wikipedia Sistema de numera√ß√£o hexadecimal](https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_hexadecimal)
. Mas resumindo, em hex voc√™ conta:
```
Hex: 0,1,2,...,8,9,A ,B ,C ,D ,E ,F ,10,11,12,...,19,1A,1B,1C,...,FF
Dec: 0,1,2,...,8,9,10,11,12,13,14,15,16,17,18,...,25,26,27,28,...,127
```
Ent√£o a base da stack √© 0xFFFFFFFF e o topo 0X00000000 !

### Melhorando o exemplo do po√ßo
```
0x0- 	     Topo da stack/Topo do po√ßo
0xA ate 0x1- espa√ßo vazio
0xD-         Segundo item
0xF-         Base da stack/Fundo do po√ßo, primeiro item
```

# üéâ Explica√ß√£o
A fun√ß√£o main() pode estar sendo divida em 3 Partes:
 1. ü•û Alocando as vari√°veis na stack (buffer[64], changeme)
 2. üí• Alterar buffer[64] usando gets()
 3. ‚úÖ Checando se changeme foi alterada

```C
int main(int argc, char **argv) {
			// Definir vari√°veis locais
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf("%s\n", BANNER); // Printar o banner (todo n√≠vel faz isso)

  locals.changeme = 0;
  gets(locals.buffer);   // Alterar o buffer

  if (locals.changeme != 0) { 	// Checar se changeme foi alterada
    puts("Well done, the 'changeme' variable has been changed!");
  } else {
    puts("Uh oh, 'changeme' has not yet been changed");
  }

  exit(0);
}
```
Ue, `changeme` nunca foi alterada... Ela n√£o deveria estar mudando!

Calma que voc√™ ja vai entender :)

## ü•û 1- Alocando as vari√°veis na stack (buffer[64], changeme)
A vari√°vel `buffer[64]` tem  tamanho de 64 bytes (64 letras, assumindo ASCII, um byte por letra).

A vari√°vel `changeme` esta marcada como `vol√°til` para prevenir que o compilador
destrua ela (pq originalmente n√£o seria
alterada, ent√£o seria destru√≠da para otimizar o c√≥digo... 
Mas n√≥s vamos alterar ela por m√©todos... ~risada mal√©fica~ ... n√£o convencionais hehehe).

Nossas duas vari√°veis (buffer[64] e changeme) s√£o empurradas na stack.
```
buffer[64] (preenchido com zeros (vazio))
changeme   (com o valor: 0x00)
ret        - Base dessa stack
```
## üí• 2- Alterar buffer[64] usando gets
A fun√ß√£o `gets()` abre um input no terminal, e escreve o que recebeu no `buffer`.

O problema √© que ela **n√£o** checa se o valor recebido √© maior que o `buffer`, permitindo que 
voc√™ **escreva fora do buffer!!** D:

Ela vai come√ßar a escrever no topo do buffer (menor endere√ßo)
e vai descendo at√© a base da stack.

```
**Stack**
buffer
       [
A           | Gets escreve nesse sentido
A           |
A           \/
...
A
      ]
changeme (com valor 0x00)
ret       - Base dessa stack
```
Ent√£o, caso coloc√°ssemos 100 "A"s no buffer de tamanho 64, as vari√°veis nos pr√≥ximos 36 endere√ßos seriam alteradas.

Essas vari√°veis ficariam com o valor "41", mas pq 41?

O valor ASCII do "A" √© 0x41, voc√™ pode checar o de todas letras usando:

> $ man ascii

Ui, o usu√°rio pode escrever fora memoria dele? perigoso ne! D:

√â por isso que essa fun√ß√£o est√° marcada como _Deprecated_ (fora de uso).

No nosso caso, o buffer tem o tamanho de **64** bytes, se colocarmos **65** "A"s (65 bytes), o valor vai vazar desse buffer.
Isso quer dizer que antes a vari√°vel `changeme` tinha o valor **0x00** e agora tem o valor **0x41** !
```
**Stack**
buffer
      [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
      ]
changeme (com o valor: 41)
ret       - Base dessa stack
```
## ‚úÖ 3- O programa checa se changeme foi alterada
Se foi alterada, quer dizer que a gente _overflow-ou_ (escreveu fora) do buffer, √© vitoria!!! :D

Ta, mas como a gente faz isso na pr√°tica?

`python3 -c "print("A"*65)"` printa 65 "A"s para o terminal

Ent√£o se a gente encaminhar esses "A"s pro programa....
```
Se voc√™ quer tentar resolver sozinhe, agora √© a sua hora!

.
.
.
.
```
### ‚ùå 64 As, changeme n√£o alterado
```bash
$ python3 -c "print('A' * 64)" | ./stack-zero 
Banner
Uh oh, 'changeme' has not yet been changed.
Would you like to try again?
```
### ‚úÖ 65 As, changeme alterado
```bash
$ python3 -c "print('A' * 65)" | ./stack-zero 
Banner
Well done, the 'changeme' variable has been changed!
```

### üÖ±Ô∏è 64 As e um B (0x42): AAAAAAAAA.....AAAB
Para demonstrar melhor esse comportamento do buffer 
ser escrito em um sentido espec√≠fico (pq vai ser muito importante saber disso),
 vou dar outro exemplo:
`python3 -c "print('A' * 64 + 'B')"` 
```md
buffer [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
       ]
changeme (com o valor: 42)   <- B = 42!!!!
ret       - Base dessa stack
```
Os `A`s preenchem certinho a stack, e a gente pode colocar o valor que quiser na vari√°vel!! Uhhuuu :D

Esses As s√≥ pra encher a stack s√£o chamados de `padding` (traduz pra preenchimento).

---
Fim! :D

Ouch... isso foi um bocado de explica√ß√£o, mas relaxa que daqui pra frente fica mais dif√≠cil hehehe :D

Se voc√™ chegou at√© aqui, voc√™ ta de parab√©ns !!!

Pra lembrar bem, desenha uma stack no papel, da um push nas vari√°veis e no buffer, mostra o sentido que o 
buffer escreve, e ele vazando e mudando o valor das outras vari√°veis...


# üëæ Solu√ß√£o
```bash
$ python3 -c "print('A' * 65)" | ./stack-zero
Welcome to phoenix/stack-zero, brought to you 
by https://exploit.education
Well done, the 'changeme' variable has been changed!
```
