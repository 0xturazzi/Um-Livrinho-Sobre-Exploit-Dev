# Ret2LibC
Ret2Libc foi uma técnica desenvolvida para combater W^X. Alem disso, 
ter domínio dessa técnica facilitar a compreensão de ROP. :D 

Por nao podermos colocar o shellcode na stack (ou heap), precisamos 
encontrar outra maneira de conseguir uma shell... Assim, vamos precisar 
encontrar uma parte executável na memoria! Uma funcao do proprio programa!

Voce se lembra de quando chamavamos uma `call_me()` ou `win()` nos desafios 
iniciais? Entao... poderiamos fazer isso... mas ninguem colocaria uma 
funcao pre-pronta pra nos dar uma shell :(

Felizmente, existe LibC, e dentro dela existem multiplas funcoes uteis!

# Funcoes Uteis
## System()
[Compiler Explorer: System](https://godbolt.org/z/691asM)

Para nosso proprosito, ela recebe 1 argumento, o caminho do programa para 
executar (Ex: `/bin/sh`)

Em C:
```C
#include <stdlib.h>
int main() {
    system("/bin/ls");
    return 0;
}
```

Em assembly:
```x86asm
.LC0:
        .string "/bin/ls"
main:
        push    rbp
        mov     rbp, rsp
        mov     edi, OFFSET FLAT:.LC0
        call    System
        mov     eax, 0
        pop     rbp
        ret
```

A funcao recebe um pointer para a string via `rdi` (64 bits) ou os 
argumentos sao passados pela stack (32 bits). Nesse post vou focar em 32 
bits!

#### Conseguindo o pointer para /bin/sh

Usando pwntools: 
```python
x = next(libc.search("/bin/sh\x00"))
```
x sera um pointer contendo o endereco da string `/bin/sh`

Em 32 bits, basta colocar ele no local previamente mencionado!

Em 64 bits, precisaremos de um gadget para colocar esse valor no rdi...
Portanto, voce vai precisar saber ROP, o tema do proximo capitulo!

#### Layout da stack numa call 32 bits
```x86asm
    Func_1
 ____________
|            |
|    RBP     | 
|____________| 
 ____________
|            |
|    RIP     | <--- RSP -> No BOF tradicional, corrompemos esse RIP!
|____________|      Porem, nao costumamos pensar o que acontece depois!
 ____________
|            |      Um ret simplemente significa:
|   ARG_1    |         pop RIP
|____________|         jmp RIP
 ____________           
|            |      E como em qualquer pop, RSP se movimenta
|   ARG_2    |
|____________| 

    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
|    RBP     |   Vamos supor que RIP->System()     |            |
|____________|   Entao da perspectiva de System,   |____________|
 ____________           ARG_1 vira RIP              ____________       
|            |          ARG_2 vira ARG_1           |            |
|    RIP     |                                     |            |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|   ARG_1    | <--- RSP                   RSP ---> |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|   ARG_2    |                                     |   ARG_1    |
|____________|                                     |____________|


    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
| AAAAAAAAAA |    A Func_1 esta vulneravel a BOF   |            |
|____________|                                     |____________|
 ____________                                       ____________       
|            |    E nos controlamos a stack :D     |            |
|  SYSTEM()  |    Entao podemos passar os args     |            |
|____________|    e o RIP de retorno para System   |____________|
 ____________                                       ____________
|            |                                     |            |  
|  DDDDDDD   |                            RSP ---> |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|  /bin/sh   | <<< --------------------------- >>> |   ARG_1    |
|____________|                                     |____________|

                  System (ou qualquer outra 
                  funcao que voce chamar) 
                  vai executar /bin/sh e 
                  tentar retornar para DDDDDDDD

```
Ao tentar retornar para `DDDDDDDD`, ocorrera uma `SEGFAULT`.

Isso sera discutido na proxima secao (`Execve`)....

Mas por enquanto, o que voce precisa saber: `System` cria um novo processo 
(`fork`, gerando um processo secundario: `child_proc`)! 

Entao retornar errado vai crashar o `child_proc` ... mas e esse crash sera 
reportado para o processo principal e nao para o computador!

> `System` AGE COMO UMA EXCESSAO: NAO GERANDO `SEGFAULT` AO RETORNAR ERRADO !!!!!

## Execve() + Exit()

`Execve` e simplesmente um wrapper envolta da syscall de mesmo nome, e 
funciona igual `System`, porem com uma diferenca: `System` cria um novo 
processo para o programa, enquanto `Execve` substitui o atual!

Quando vc sai da shell em `System`, o programa finaliza normalmente. Ja em 
`Execve`, ele age como se estivesse retornando de uma `call`, assim, se voce 
simplesmente chamar ele, quando voce fechar a shell vai gerar uma 
`SEGFAULT` tentando executar `*DDDDDDD`

E com a `SEGFAULT`, um core dump sera gerado... Disparando alarmes e 
ativando mecanismos de seguranca que alertam o dono do servidor!

Assim, precisamos substituir esse valor por `Exit()`, garantindo que o 
programa finalize silenciosamente!

## Mprotect() + ret2shellcode


# Pontos Fracos
## Estaticamente Linkado
Em programas estaticamente linkados ao libc, somente podemos usar uma 
fracao das funcoes presentes, pois somente as que sao originalmente usadas 
pelo programa sao linkadas!

## Dinamicamente Linkado (+ ASLR)
Ja em programas que usam o libc do sistema, voce pode usar o todo o 
potencial do libc. Porem caso o computador possua ASLR ligado, sera 
nescessario primeiro encontrar o endereco aleatorio do libc (libc-leak), ou 
executar o exploit em loop ate voce dar sorte (viavel somente em 
computadores 32 bits).